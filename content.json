[{"title":"箭头函数","date":"2019-07-19T05:04:35.000Z","path":"2019/07/19/arrow-functions/","text":"语法箭头函数和普通的 function 一样，可以接受参数然后返回值，但是它没有自己的 this、arguments 等，且不能当作构造函数使用。 1234const add = (a, b) =&gt; &#123; const res = a + b return res&#125; 仅有一条语句时，可不写函数体的花括号，且这条语句的值会当作返回值： 123// 相当于：(a, b) =&gt; &#123; return a + b &#125;const add = (a, b) =&gt; a + bconsole.log(add(1, 1)) // 2 仅有一个参数的时候，圆括号可写可不写： 12const absolute = (a) =&gt; a &gt; 0 ? a : -1 * aconst absolute = (a) =&gt; &#123; return a &gt; 0 ? a : -1 * a &#125; 没有参数时，箭头前写一对空的圆括号： 12const logNow = () =&gt; console.log(new Date())const logNow = () =&gt; &#123; console.log(new Date()) &#125; 如果需要返回对象字面量如 { hello: &#39;world!&#39; }，或使用解构语法拿到唯一的参数，必须用圆括号把字面量或解构包裹起来： 12345const buildObject = (str) =&gt; &#123; text: str &#125; // 错误❌const buildObject = (str) =&gt; (&#123; text: str &#125;) // 正确✅const buildObject = &#123; text &#125; =&gt; alert(text) // 错误❌const buildObject = (&#123; text &#125;) =&gt; alert(text) // 正确✅ 特性没有自己的 this箭头函数不会绑定 this 的值，它的 this 和其上一级作用域相同： 12345678910111213141516171819202122232425262728293031323334353637383940const that = this// 在 node 中为空对象 &#123;&#125;，浏览器中为 windowconsole.log(that)function addFunc(num1, num2) &#123; console.log('---- Function ----') // this：调用 addFunc 的实例 // node 中为 global，浏览器中为 window console.log(this) // node：false；浏览器：true console.log('that === this: ', that === this) // node：true；浏览器：true console.log('global === this: ', global === this) console.log('---- Function ----\\n\\n') return num1 + num2&#125;const addArrowFunc = (num1, num2) =&gt; &#123; console.log('---- Arrow Function ----') // this：从外部（全局环境）继承来的 this // node 中即空对象 &#123;&#125;，浏览器中为 window console.log(this) // node：true；浏览器：true console.log('that === this: ', that === this) // node：false；浏览器：true console.log('global === this: ', global === this) console.log('---- Arrow Function ----\\n\\n') return num1 + num2&#125;addArrowFunc(1, 1)addFunc(1, 1) 不能作为构造函数箭头函数不能用于构造函数，因此也没有自己的 prototype： 12345678910111213141516171819function Student(name, age) &#123; this.name = name this.age = age&#125;const StudentArrowFunc = (name, age) =&gt; &#123; this.name = name this.age = age&#125;// Student &#123;name: \"Xiaoming\", age: 22&#125;const student1 = new Student('Xiaoming', 22)// TypeError: StudentArrowFunc is not a constructorconst student2 = new StudentArrowFunc('Xiaohua', 16)// &#123;constructor: ƒ&#125;console.log(Student.prototype);// undefinedconsole.log(StudentArrowFunc.prototype); 在类中的表现在 ES6 的 class 中使用箭头函数时，事实上是为每个实例都添加了一个属性，这个属性的值是这个箭头函数的拷贝，而方法的定义则是挂载至类的 prototype，通过原型链调用： 123456789101112131415161718192021222324252627282930class Student &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; sayHi() &#123; alert(`This is $&#123;this.age&#125;-years-old $&#123;this.name&#125;`) &#125; // 相当于在 constructor 中加入 this.sayHiArrowFunc = () =&gt; ... sayHiArrowFunc = () =&gt; alert(`This is $&#123;this.age&#125;-years-old $&#123;this.name&#125;`)&#125;const student1 = new Student('Xiaoming', 22)const student2 = new Student('Xiaohong', 16)// &#123;constructor: ƒ, sayHi: ƒ&#125;console.log(Student.prototype)// Student &#123;sayHiArrowFunc: ƒ, name: \"Xiaoming\", age: 22&#125;console.log(student1)// Student &#123;sayHiArrowFunc: ƒ, name: \"Xiaohong\", age: 16&#125;console.log(student2)// trueconsole.log(student1.sayHi === student2.sayHi)// trueconsole.log(student1.sayHi === Student.prototype.sayHi)// falseconsole.log(student1.sayHiArrowFunc === student2.sayHiArrowFunc) 由于箭头函数定义的方法是每个对象自身的属性，我们在继承的时候，被继承者不仅会继承类父类原型上的属性和方法，也会继承其实例上的属性和方法，于是就会有下面这种情况： 123456789class A &#123; print = () =&gt; console.log('print a')&#125;class B extends A &#123; print() &#123; console.log('print b') &#125;&#125;// 只会输出 print anew B().print() 以上代码执行时，new B() 中的 print() 来自于 A 类的实例属性 print，它直接挂在实例的 this 上，所以其优先级反而会比自身的 print() 方法优先级更高，因此执行的输出是 print a。以上代码相当于： 12345678910111213141516function A() &#123; this.print = () =&gt; console.log('print a')&#125;function B () &#123; // 继承自 A this.print = () =&gt; &#123; console.log('print a') &#125;&#125;// 通过原型实现继承B.__proto__ = A;B.prototype.__proto__ === A.prototype;// 类 B 自身定义的 print 方法B.prototype.print = function () &#123; console.log('print b') &#125;new B().print(); 使用何时使用箭头函数可以很好地简化代码，比如在没有 Set 的 polyfill 时的去重： 12345678const arr = [1, 2, 2, 3, 1]const arrUnique = arr.filter(function onlyUnique(val, i, arr) &#123; return arr.indexOf(val) === i&#125;);// 使用箭头函数const arrUnique = arr.filter((val, i, arr) =&gt; arr.indexOf(val) === i) 在 React 的事件处理器中，使用箭头函数可以很方便地解决每次都需要手动 bind(this) 的问题： 1234567891011121314151617181920class MyComponent extends React.Component &#123; constructor() &#123; super() this.handleClick = this.handleClick.bind(this) &#125; handleClick() &#123; // 如果不绑定 this，在严格模式下这里是 undefined console.log(this); &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;点我！&lt;/button&gt; &#125;&#125;// 使用箭头函数class MyComponent extends React.Component &#123; handleClick = () =&gt; console.log(this) render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;点我！&lt;/button&gt; &#125;&#125; 何时不应使用在对象字面量中使用时，箭头函数的 this 并不会绑定至对象本身，而是其上一级作用域，因此无法访问或操作对象的属性： 12345678910111213const obj = &#123; funcLog() &#123; // 指向 obj console.log(this) &#125;, arrFuncLog: () =&gt; &#123; // node 指向空对象 &#123;&#125;，浏览器指向 window console.log(this) &#125;,&#125;obj.funcLog()obj.arrFuncLog() 在某些需要访问调用者（即 this）的回调函数中也不要使用箭头函数，比如下面是想在按钮点击的时候切换类名，但是使用箭头函数会使得 this 并不指向调用它的按钮： 1234document.querySelector('#btn').addEventListener('click', () =&gt; &#123; // this 等于上一级作用域的 this this.classList.toggle('active')&#125;) 上面也说过，箭头函数定义的属性会在每个实例都拷贝一份，因此在包含大量的组件实例（如一个长列表）时应当避免使用箭头函数，否则会有性能上的损失，如Medium 上 @charpeni 做的一份测试，渲染 100 个组件时的性能： 参考： 箭头函数 - MDN Arrow Functions in Class Properties Might Not Be As Great As We Think ES6 Class Methods 定义方式的差异","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sr2k.top/blog/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sr2k.top/blog/tags/ES6/"}]},{"title":"树和二叉树","date":"2019-04-18T06:32:12.000Z","path":"2019/04/18/树和二叉树/","text":"6.1 树的类型和定义基本术语 结点：数据元素+若干指向子树的分支 结点的度：分枝的个数 树的度：树中所有结点的度的最大值 叶子结点：度为零的结点 分支结点：度大于零的结点 从根到结点的路径：由从根到该结点所经分支和结点构成 一些结点之间的关系： 孩子结点 双亲结点 兄弟结点 祖先结点 子孙结点 结点的层次：假设根结点的层次为1，则第l层的结点的子树跟结点的层次为l+1 树的深度：树中叶子结点所在的最大层次 森林：是$m$（$m\\geqslant 0$）棵互不相交的树的集合 任何一个非空树是一个二元组：$Tree = (root, F)$ $root$被称为根结点 $F$被称为子树森林 有向树（一般我们讨论的都是有向树） 有确定的根 树根和子树根之间为有向关系 有序树与无序树：子树之间是否存在次序关系（一般我们讨论的都是无序树） 和线性结构的比较 线性结构 树结构 第一个数据元素（无前驱） 根结点（无前驱） 最后一个数据元素（无后继） 多个叶子结点（无后继） 其他数据元素（一个前驱、一个后继） 树中其他结点（一个前驱、多个后继） 抽象数据类型数据对象$D$是具有相同特性的数据元素的集合 数据关系若$D$为空集，则称为空树； 若$D$仅含一个数据元素，则$R$为空集，否则$R={H}$，$H$是如下二元关系： 在$D$中存在唯一的成为根的数据元素root，它在$H$下无前驱； 若$D-{root} \\ne \\Phi$，则存在$D-{root}$的一个划分$D_1$，$D_2$，…，$D_m$（$m&gt;0$），对任意$j\\ne k(1\\leqslant j, k\\leqslant m)$有$D_j\\cap D_k=\\Phi$，且对任意的$i$（$1\\leqslant i\\leqslant m$），惟一存在数据元素$x_i\\in D_i$，有$&lt;root, x_i&gt;\\in H$； 对应于$D-{root} \\ne \\Phi$的划分，$H-{&lt;root, x_1&gt;, …, &lt;root, x_m&gt;}$有惟一的一个划分$H_1$，$H_2$，…，$H_n$，对任意$j\\ne k(1\\leqslant j, k\\leqslant m)$有$H_j\\cap H_k=\\Phi$，且对任意的$i$（$1\\leqslant i\\leqslant m$），$H_i$是$D_i$上的二元关系，$(D_i, {H_i})$是一颗符合本定义的树，称为根root的子树。 基本操作查找 Root(T) Value(T, cur_e) Parent(T, cur_e) LeftChild(T, cur_e) RightSibling(T, cur_e) TreeEmpty(T) TreeDepth(T) TraverseTree(T, Visit()) 插入 InitTree(&amp;T) CreateTree(&amp;T, definition) Assign(T, cur_e, value) InsertChild(&amp;T, &amp;p, i, e) 删除 DestroyTree(&amp;T) ClearTree(&amp;T) DeleteChild(&amp;T, &amp;p, i) 6.2 二叉树二叉树或为空树，或是由一个根结点加上两棵分别称为左子树和右子树的、互不交的二叉树组成。 如： 123456789101112graph TDA --- BB --- CC --- DA --- EE --- FF --- GG --- HG --- K 二叉树的五种基本形态： 空树 只含一个根结点 左子树为空树，右子树不为空 左子树不为空，右子树为空树 左右子树都不为空 两类特殊的二叉树 满二叉树：深度为$k$且含有$2^k-1$个结点的二叉树 完全二叉树：书中所含的$n$个结点和满二叉树中编号为$1$至$n$的结点一一对应 1234567891011121314151617181920212223242526272829303132graph TDsubgraph 满二叉树 a1 --&gt; b1 a1 --&gt; c1 b1 --&gt; d1 b1 --&gt; e1 c1 --&gt; f1 c1 --&gt; g1 d1 --&gt; h1 d1 --&gt; i1 e1 --&gt; j1 e1 --&gt; k1 f1 --&gt; l1 f1 --&gt; m1 g1 --&gt; n1 g1 --&gt; o1endsubgraph 完全二叉树 a2 --&gt; b2 a2 --&gt; c2 b2 --&gt; d2 b2 --&gt; e2 c2 --&gt; f2 c2 --&gt; g2 d2 --&gt; h2 d2 --&gt; i2 e2 --&gt; j2 e2 --&gt; k2 f2 --&gt; l2end 性质 在二叉树的第$i$层上至多有$2^{i-1}$个结点（$i\\geqslant 1$）； 深度为$k$的二叉树上至多含$2^k-1$个结点（$k\\geqslant 1$）； 对于任何一棵二叉树，若他含有$n_0$个叶子结点、$n_2$个度为2的结点，则必存在关系式：$n_0=n_2+1$； 具有$n$个结点的完全二叉树的深度为$\\lfloor\\log_2n\\rfloor+1$； 若对含$n$个结点的二叉树从上到下且从左到右进行$1$至$n$的编号，则对二叉树中任意一个编号为$i$的结点： 若$i=1$，则该结点事二叉树的根，无双亲；否则，编号为$\\lfloor i/2\\rfloor$的结点为其双亲结点； 若$2i&gt;n$，则该结点无左孩子结点；否则，编号为$2i$的结点为其左孩子结点； 若$2i+1&gt;n$，则该结点无右孩子结点；否则，编号为$2i+1$的结点为其右孩子结点。 基本操作查找 Root(T) Value(T, e) 关系查找： Parent(T, e) LeftChild(T, e) RightChild(T, e) LeftSibling(T, e) RightSibling(T, e) 状态查询： BiTreeEmpty(T) BiTreeDepth(T) 遍历： PreIrderTraverse(T, Visit()) InOrderTraverse(T, Visit()) PostOrderTraverse(T, Visit()) LevelOrderTraverse(T, Visit()) 插入 InitBiTree(&amp;T) Assign(T, &amp;e, value) CreateBiTree(&amp;T, definition) InsertChild(T, p, LR, c) 删除 ClearBiTree(&amp;T) DestroyBiTree(&amp;T) DeleteChild(T, p, LR) 6.3 二叉树的存储结构二叉树的顺序存储表示12345// 二叉树的最大结点数#define MAX_TREE_SIZE 100;// 0 号但愿存储根结点typedef TElemType SqBiTree[MAX_TREE_SIZE];SqBiTree bt; 补全成满二叉树（或完全二叉树）后，按照编号存储即可。 缺点：存储非完全二叉树时会造成空间浪费。 二叉树的链式存储表示二叉链表12345typedef struct BiTNode &#123; TElemType data; // 左右孩子指针 struct BiTNode *lchild, *rchild;&#125; BiTNode, *BiTree; 双亲链表123456789101112131415typedef struct BPTNode &#123; TElemType data; // 指向双亲的指针 int *parent; // 左、右孩子标志域 char LRTag;&#125;typedef struct BPTree &#123; BPTNode nodes[MAX_TREE_SIZE]; // 结点数目 int num_node; // 根结点的位置 int root;&#125; BPTree; 6.4 二叉树的遍历对于二叉树而言，可以有三条搜索路径： 先上后下的按层次遍历; 先左（子树）后右（子树）的遍历； 先右（子树）后左（子树）的遍历； 先左后右的遍历算法先（根）序的遍历算法若二叉树为空树，则空操作，否则： 访问跟结点 先序遍历左子树 先序遍历右子树 递归实现1234567void Preorder(BiTree T, void (*visit)(TElemType &amp;e)) &#123; if (T) &#123; visit(T -&gt; data); Preorder(T -&gt; lchild, visit); Preorder(T -&gt; rchild, visit); &#125;&#125; 中（根）序的遍历算法若二叉树为空树，则空操作，否则： 中序遍历左子树 访问跟结点 中序遍历右子树 非递归实现12345678910111213141516Status InorderTraverse(BiTree T, Status (*Visit)(TElemType e)) &#123; InitStack(S); Push(S, T); while (!StackEmpty(S)) &#123; while (GetTop(S, p) &amp;&amp; p) Push(S, p -&gt; lchild); Pop(S, p); if (!StackEmpty(S)) &#123; Pop(S, p); if (!Visit(p -&gt; data)) return ERROR; Push(S, p -&gt; rchild); &#125; &#125; return OK;&#125; 后（根）序的遍历算法若二叉树为空树，则空操作，否则： 后序遍历左子树 中序遍历右子树 访问跟结点 二叉树遍历的应用统计二叉树中叶子结点的个数12345678void CountLeaf(BiTree T, int &amp;count) &#123; if (T) &#123; if ((!T -&gt; lchild) &amp;&amp; (!T -&gt; rchild)) count++; CountLeaf(T -&gt; lchild, count); CountLeaf(T -&gt; rchild, count); &#125;&#125; 求二叉树的深度（后序遍历）12345678910int Depth(BiTree T) &#123; if (!T) depthval = 0; else &#123; depthL = Depth(T -&gt; lchild); depthR = Depth(T -&gt; rchild); depthval = 1 + (depthL &gt; depthR ? depthL : depthR); &#125; return depthval;&#125; 复制二叉树（后续遍历）1234567891011121314BiTree *CopyTree(BiTNode *T) &#123; if (!T) return NULL; if (T -&gt; lchild) newlptr = CopyTree(T -&gt; lchild); else newlptr = NULL; if (T -&gt; rchild) newrptr = CopyTree(T -&gt; rchild); else newrptr = NULL; newnode = GetTreeNode(T -&gt; data, newlptr, newrptr); return newnode;&#125; 建立二叉树的存储结构不同的定义方法有不同的存储方法。 按给定的先序序列建立二叉链表12345678910111213Status CreateBiTree(BiTree &amp;T) &#123; scanf(&amp;ch); if (ch == '') T = NULL; else &#123; if (!(T = (BiTNode*)malloc(sizeof(BiTNode)))) exit(OVERFLOW); T -&gt; data = ch; CreateBiTree(T -&gt; lchild); CreateBiTree(T -&gt; rchild); &#125; return OK;&#125; 按给定的表达式建立相应二叉树// 略 6.5 线索二叉树遍历二叉树的结果是求得结点的一个线性序列。 指向该线性序列中的「前驱」和「后继」的指针，称作「线索」； 包含「线索」的存储结构，称作「线索链表」； 与其相应的二叉树，「线索二叉树」。 线性链表的约定：在二叉链表的结点中增加两个标志域，并作如下规定： 若该结点的左子树不空，则lchild域的指针指向其左子树，且左标志域的值为0；否则，lchild域的指针指向其「前驱」，且左标志的值为1； 若该结点的右子树不空，则rchild域的指针指向其右子树，且右标志域的值为0；否则，lchild域的指针指向其「后继」，且右标志的值为1； 线性链表的结构描述： 12345678910111213typedef enum &#123; // Link == 0：指针 Link, // Thread == 1：线索 Thread&#125; PointerThr;typedef struct BiThrNode &#123; TElemType data; // 左右指针 struct BiThrNode *lchild, *rchild; // 左右标志 PointerThr LTag, RTag;&#125; BiThrNode, *BiThrTree; 线索链表的遍历算法12for (p = firstNode(T); p; p = Succ(p)) Visit(p); 以中序线索化链表的遍历算法为例： 12345678910111213141516171819Status InOrderTraverse_Thr(BiThrTree T, Status (*Visit)(TElemType e)) &#123; // p指向根结点 p = T -&gt; lchild; // 空树或遍历结束时p==T while (p != T) &#123; while (P -&gt; LTag == Link) p = p -&gt; lchild; if (!Visit(p -&gt; data)) return ERROR; while (p -&gt; RTag == Thread &amp;&amp; p -&gt; rchild != T) &#123; // 访问后继结点 p = p -&gt; rchild; Visit(p -&gt; data); &#125; // p行进至右子树根 p = p -&gt; rchild; &#125; return OK;&#125; 建立线索链表在中序遍历的过程中修改结点的左、右指针域，以保存当前访问结点的「前驱」和「后继」信息。遍历过程中，附设指针pre，并始终保持指针pre指向当前访问的、指针p所指结点的前驱。 1234567891011121314void InThreading(BiThrTree p) &#123; if (p) &#123; InThreading(p -&gt; lchild); if (!p -&gt; lchild) &#123; p -&gt; LTag = Thread; p -&gt; lchild = pre; &#125; if (!p -&gt; rchild) &#123; p -&gt; RTag = Thread; p -&gt; rchild = p; &#125; InThreading(p -&gt; rchild); &#125;&#125; 6.6 树和森林的表示方法树的三种存储结构双亲表示法123456#define MAX_TREE_SIZE 100typedef struct PTNode &#123; Elem data; // 双亲位置域 int parent;&#125; PTNode; 树结构： 1234typedef struct &#123; PTNode nodes[MAX_TREE_SIZE]; int r, n;&#125; PTree; 如树： 1234567graph TDA --- BA --- CA --- DC --- EC --- FF --- G 可以存储为： data parent 0 A -1 1 B 0 2 C 0 3 D 0 4 E 2 5 F 2 6 G 5 孩子链表表示法123456789101112typedef struct CTNode &#123; int child; struct CTNode *next;&#125; *ChildPtr;typedef struct &#123; Elem data; ChildPtr firstchild;&#125; CTBox;typedef struct &#123; CTBox nodes[MAX_TREE_SIZE]; int n, r;&#125; CTree; 如上链表可表示为： data firstchild（此处写的是链表） 0 A 1 -&gt; 2 -&gt; 3 1 B ^ 2 C 4 -&gt; 5 3 D ^ 4 E 6 5 F 6 6 G ^ 树的二叉链表（孩子-兄弟链表）12345678typedef struct CSNode &#123; Elem data; struct CSNode // 相当于二叉树的左指针，指向其第一个子结点 *firstchild, // 相当于二叉树的右指针，指向其兄弟结点 *nextsibling;&#125; 如上文的树，可以表示为这样的二叉树： 1234567graph LRA --- |左|BB --- |右|CC --- |左|EC --- |右|DE --- |右|FF --- |左|G data firstchild nextsibling 0 A 1 ^ 1 B ^ 2 2 C 4 3 3 D ^ ^ 4 E ^ 5 5 F 6 ^ 6 G ^ ^ 森林和二叉树设森林：$\\left{ \\begin{align}F &amp;= (T_1, T_2, …, T_n)\\T_1 &amp;= (root, t_{11}, t_{12}, …, t_{1m})\\end{align} \\right.$ 二叉树：$B = (LBT, Node(root), RBT);$ 由森林转化成二叉树 若$F=\\Phi$，则$B=\\Phi$； 否则： 由$ROOT(T_1)$对应的到$Node(root)$（第一棵树的根变成二叉树的根）； 由$(t_{11}, t_{12}, … t_{1m})$对应得到$LBT$（第一棵树的子树森林变成二叉树的左子树）； 由$(T_2, T_3, …, T_N)$对应得到$RBT$（除去第一棵树的森林得到二叉树的右子树）。 如森林： 1234567891011121314151617181920graph TDsubgraph T1 A --- B A --- E A --- K B --- D B --- I E --- J D --- Hendsubgraph T2 C --- F C --- M F --- Lendsubgraph T3 G --- Nend 可以转化为： 1234567891011121314graph TDA --- |L|BB --- |L|DD --- |L|HD --- |R|IB --- |R|EE --- |L|JE --- |R|KA --- |R|CC --- |L|FF --- |L|LF --- |R|MC --- |R|GG --- |L|N 二叉树转化成森林 若$B=\\Phi$，则$F=\\Phi$； 否则： 由$Node(root)$对应的到$ROOT(T_1)$； 由$LBT$对应得到$(t_{11}, t_{12}, … t_{1m})$； 由$RBT$对应得到$(T_2, T_3, …, T_N)$。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sr2k.top/blog/tags/数据结构与算法/"},{"name":"严蔚敏数据结构与算法","slug":"严蔚敏数据结构与算法","permalink":"https://sr2k.top/blog/tags/严蔚敏数据结构与算法/"},{"name":"学习","slug":"学习","permalink":"https://sr2k.top/blog/tags/学习/"}]},{"title":"栈和队列","date":"2019-04-17T08:09:23.000Z","path":"2019/04/17/栈和队列/","text":"3.1 栈的类型定义数据对象$$D = {a_i | a_i \\in \\texttt{ElemSet}, i = 1, 2, …, n, n \\geqslant 0}$$ 数据关系$$R1 = {&lt;a_{i-1}, a_i&gt; | a_{i-1}, a_i \\in D, i = 2, …, n}$$ 约定$a_n$端为栈顶，$a_1$端为栈底。 后进先出：栈中元素依次按$a_1$、$a_@$、…、$a_n$入栈，而退栈的第一个元素应为栈顶元素。 基本操作结构初始化 InitStack(&amp;S) 操作结果：构造一个空栈$S$ 销毁结构 DestroyStack(&amp;S) 初始条件：栈$S$已存在 操作结果：栈$S$被销毁 引用型操作 StackEmpty(S) 初始条件：栈$S$已存在 操作结果：若栈$S$为空栈，则返回TRUE，否则返回FALSE StackLength(S) 初始条件：栈$S$已存在 操作结果：返回$S$的元素个数，即栈的长度 GetTop(S, &amp;e) 初始条件：栈$S$已存在，且非空 操作结果：用e返回$S$的栈顶元素 加工型操作 ClearStack(&amp;S) 初始条件：栈$S$已存在 操作结果：将$S$清为空栈 Push(&amp;S, e)（入栈操作） 初始条件：栈$S$已存在 操作结果：插入元素$e$为新的栈顶元素 Pop(&amp;S, &amp;e) 初始条件：栈$S$已存在且非空 操作结果：删除$S$的栈顶元素，并用e返回其值 3.2 栈的应用举例数值转换基于短除法： $$N = (N \\div d) \\times d + N \\% d$$ 例如：$(1348)_{10} = (2504)_8$，其运算过程如下： $N$ $N \\div 8$ $N\\%8$ 1348 168 4 168 21 0 21 2 5 2 0 2 计算顺序：自上而下；输出顺序：自下而上。刚好符合栈后进先出的特点。 算法： 123456789101112void conversion() &#123; InitStack(S); scanf(\"%d\", N); while (N) &#123; Push(S, N % 8); N = N / 8; &#125; while (!StackEmpty(S)) &#123; Pop(S, e); printf(\"%d\", e); &#125;&#125; 表达式中括号匹配的检验检验的方法用「期待的急迫程度」来描述：每出现一个左括号，就会急切地期待与之配对的右括号出现。 因此大致思路可以描述为： 如果是左括号(、[或{，则入栈 如果是右括号，则先判断是否为空栈 若栈空，则表明右括号多了 若栈不空，则使用GetTop判断是否匹配 匹配：左括号出栈 不匹配：错误 表达式检验结束时： 若栈空，则匹配正确 否则左括号多了 算法： 1234567891011121314151617181920212223bool matching(string &amp;exp) &#123; while (i &lt;= Length(exp)) &#123; switch of exp[i] &#123; case 左括号: Push(S, exp[i]); i++; break; case 右括号: if (!StackEmpty(S) &amp;&amp; Match(GetTop(S), exp[i])) &#123; Pop(S, e); i++; break; &#125; else &#123; return FALSE; &#125; &#125; &#125; if (!StackEmpty(S)) return FALSE; return TRUE;&#125; （我觉着其实这样更好：） 123456def isValid(self, s): while '&#123;&#125;' in s or '()' in s or '[]' in s: s = s.replace('&#123;&#125;', '') s = s.replace('[]', '') s = s.replace('()', '') return s == '' 行编辑程序#为退格符，@为退行符（退格到行首）。 12345678910111213141516while (ch != EOF) &#123; while (ch != EOF &amp;&amp; ch != '\\n') &#123; switch (ch) &#123; case '#': Pop(S, c); break; case '@': ClearStack(S); break; default: Push(S, ch); break; &#125; ch = getchar(); &#125;&#125; 迷宫求解通常使用「穷举求解」的方法： 若当前位置「可通」，则纳入路径，继续前进 若当前位置「不可通」，则后退，换向探索 若四周均「不可通」，则从路径中删除 TODO… 表达式求值TODO… 实现递归TODO… 3.3 栈类型的实现类似于线性表的顺序映像实现，指向表尾的指针可以做为栈顶指针。 12345678#define STACK_INIT_SIZE 100;#define STACK_INCREMENT 10;typde struct &#123; SElemType *base; SElemType *top; int stacksize;&#125; SqStack; 3.4 队列的类型定义数据对象$$D = {a_i | a_i \\in \\texttt{ElemSet}, i = 1, 2, …, n, n \\geqslant 0}$$ 数据关系$$R1 = {&lt;a_{i-1}, a_i&gt; | a_{i-1}, a_i \\in D, i = 2, …, n}$$ 约定$a_1$端为队列头，$a_n$端为队列尾。 后进先出：栈中元素依次按$a_1$、$a_@$、…、$a_n$入栈，而退栈的第一个元素应为栈顶元素。 基本操作结构初始化 InitQueue(&amp;Q) 操作结果：构造一个空队列$Q$ 销毁结构 DestroyQueue(&amp;Q) 初始条件：队列$Q$已存在 操作结果：队列$Q$被销毁 引用型操作 QueueEmpty(Q) 初始条件：队列$Q$已存在 操作结果：若$S$为空队列，则返回TRUE，否则返回FALSE QueueLength(Q) 初始条件：队列$Q$已存在 操作结果：返回$Q$的元素个数，即队列的长度 GetHead(Q, &amp;e) 初始条件：队列$Q$已存在，且非空 操作结果：用e返回$Q$的头部元素 加工型操作 ClearQueue(&amp;Q) 初始条件：队列$Q$已存在 操作结果：将$Q$清为空队列 EnQueue(&amp;Q, e) 初始条件：队列$Q$已存在 操作结果：插入元素$e$为新的队尾元素 DeQueue(&amp;Q, &amp;e) 初始条件：队列$Q$已存在且非空 操作结果：删除$S$的队头元素，并用e返回其值 3.5 队列类型的实现链队列——链式映像123456789typedef struct QNode &#123; QElemType data; struct QNode *next;&#125; QNode, *QueuePtr;typedef struct &#123; QueuePtr front; QueuePtr rear;&#125; LinkQueue; 循环队列——顺序映像12345678910#define MAX_SIZE 100;typedef struct &#123; // 初始化的动态分配存储空间 QElemType *base; // 头指针，若队列不空，指向队列头元素 int front; // 尾指针，若队列不空，指向队列尾元素的下一个位置 int rear;&#125; SqQueue;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sr2k.top/blog/tags/数据结构与算法/"},{"name":"严蔚敏数据结构与算法","slug":"严蔚敏数据结构与算法","permalink":"https://sr2k.top/blog/tags/严蔚敏数据结构与算法/"},{"name":"学习","slug":"学习","permalink":"https://sr2k.top/blog/tags/学习/"}]},{"title":"线性表","date":"2019-04-16T10:14:46.000Z","path":"2019/04/16/线性表/","text":"基本特征： 集合中必存在唯一的一个「第一元素」 集合中必存在唯一的一个「最后元素」 除第一元素外，均有唯一的后继 除第一元素外，均有唯一的前驱 2.1 线性表的类型定义数据对象$$D = {a_i | a_i \\in \\texttt{ElemSet}, i = 1, 2, …, n, n\\geqslant 0}$$ 称$n$为线性表的表长 称$n=0$的线性表为空表 数据关系$$R1={&lt;a_{i-1}, a_i&gt;|a_{i-1}, a_i \\in D, i = 2, …, n}$$ 设线性表为$(a_1, a_2, …, a_i, …, a_n)$，称$i$为$a_i$在线性表中的位序 基本操作结构初始化 InitList(&amp;L) 操作结果：构造一个空的线性表$L$ 销毁结构 DestroyList(&amp;L) 初始条件：线性表$L$已存在 操作结果：销毁线性表$L$ 引用型操作 ListEmpty(L) 初始条件：线性表$L$已存在 操作结果：若$L$为空表，则返回TRUE，否则返回FALSE ListLength(L) 初始条件：线性表$L$已存在 操作结果：返回$L$中数据元素的个数 PriorElem(L, cur_e, &amp;pre_e) 初始条件：线性表$L$已存在 操作结果：若cur_e是$L$的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义 NextElem(L, cur_e, &amp;next_e) 初始条件：线性表$L$已存在 操作结果：若cur_e是$L$的数据元素，且不是最后一个，则用next_e返回它的后驱，否则操作失败，next_e无定义 GetItem(L, i, &amp;e) 初始条件：线性表$L$已存在，$1\\leqslant i\\leqslant \\texttt{ListLength}(L)+1$ 操作结果：用e返回$L$中第i个数据元素的值 LocateElem(L, e, compare()) 初始条件：线性表$L$已存在，compare()是数据元素判定函数 操作结果：返回$L$中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回值为0 ListTraverse(L, visit()) 初始条件：线性表$L$已存在 操作结果：依次对$L$的每个数据元素调用函数visit()。一旦visit()调用失败，则操作失败 加工型操作 ClearList(&amp;L) 初始条件：线性表$L$已存在 操作结果：将$L$重置为空表 PutElem(L, i, &amp;e) 初始条件：线性表$L$已存在，$1\\leqslant i\\leqslant \\texttt{ListLength}(L)+1$ 操作结果：$L$中第i个元素赋值同e的值 ListInsert(&amp;L, i, e) 初始条件：线性表$L$已存在，$1\\leqslant i\\leqslant \\texttt{ListLength}(L)+1$ 操作结果：在$L$中第i个位置之前插入新的数据元素e，$L$的长度加1 ListDelete(&amp;L, i, &amp;e) 初始条件：线性表$L$已存在且非空，$1\\leqslant i\\leqslant \\texttt{ListLength}(L)+1$ 操作结果：删除$L$的第i个元素，并用e返回其值，$L$的长度减1 例题例2.1：union（并集）假设：有两个集合$A$和$B$分别用两个线性表$LA$和$LB$表示（即：线性表中的数据元素即为集合的成员）。 现要求一个新的集合$A = A \\cup B$。 解析 从线性表$LB$中依次取得每个数据元素：GetElem(LB, i) -&gt; e 依次在线性表$LA$中进行查访：LocateElem(LA, e, equal()) 若不存在，则插入之：ListInsert(LA, n+1, e) 算法12345678910void union(List &amp;La, List Lb) &#123; La_len = ListLength(La); Lb_len = ListLength(Lb); for (i = 1; i &lt;= Lb_len; i++) &#123; GetElem(Lb, i, e); if (!LocateElem(La, e, equal)) ListInsert(La, ++La_len, e); &#125;&#125; 算法分析控制结构：for循环 基本操作：LocateElem(La, q, equal()) 时间复杂度： 顺序映像：TODO… 链式映像：TODO… 例2.2：purge（净化）已知一个有序非纯集合$B$，试构造一个纯集合$A$，使$A$中只包含$B$中所有值各不相同的数据元素。 算法12345678910111213void purge(List &amp;La, List Lb) &#123; InitList(La); La_len = ListLength(La); Lb_len = ListLength(Lb); for (i = 1; i &lt;= Lb_len; i++) &#123; GetItem(Lb, i, e); if (ListEmpty(La) || !equal(en, e)) &#123; ListInsert(La, ++La_len, e); en = e; &#125; &#125;&#125; 算法分析控制结构：for循环 基本操作：GetElem(Lb, i, e) 时间复杂度： 顺序映像：TODO… 链式映像：TODO… 例2.3：merge（归并）归并两个「其数据元素按值非递减有序排列」的线性表$LA$和$LB$，求得线性表$LC$也具有同样的特征。 算法123456789101112131415161718192021222324252627282930void MergeOrderedList(List La, List Lb, List &amp;Lc) &#123; InitList(Lc); i = j = 1; k = 0; La_len = ListLength(La); Lb_len = ListLength(Lb); while ((i &lt;= La_len) &amp;&amp; (j &lt;= Lb_len)) &#123; GetItem(La, i, ai); GetItem(Lb, j, bj); if (ai &lt;= bj) &#123; ListInsert(Lc, ++k, ai); ++i; &#125; else &#123; ListInsert(Lc, ++k, bj); ++j; &#125; &#125; while (i &lt;= La_len) &#123; GetItem(La, i++, ai); ListInsert(Lc, ++k, ai); &#125; while (j &lt;= Lb_len) &#123; GetItem(Lb, j++, bj); ListInsert(Lc, ++k, bj); &#125;&#125; 算法分析控制结构：三个并列的while循环 基本操作：ListInsert(Lc, ++k, e) 时间复杂度： 顺序映像：TODO… 链式映像：TODO… 2.2 线性表类型的实现——顺序映像定义用一组地址连续的存储单元依次存放线性表中的数据元素： 123+----+----+-----+------+----+-----+----|| a1 | a2 | ... | ai-1 | ai | ... | an |+----+----+-----+------+----+-----+----| 线性表的起始地址称作线性表的基地址。 以「存储位置相邻」表示有序对$&lt;a_{i-1}, a_i&gt;$即：$\\mathrm{LOC}(a_i) = \\mathrm{LOC}(a_{i-1}) + C$。其中$C$为一个数据元素所占的存储量。 所有数据元素的存储位置均取决于第一个元素的存储位置：$\\mathrm{LOC}(a_i) = \\mathrm{LOC}(a_1) + (i-1)\\times C$ 顺序映像的C语言描述： 12345678910111213// 线性表存储空间的初始分配量#define LIST_INIT_SIZE 80// 线性表存储空间的分配增量#define LIST_INCREMENT 10typedef struct &#123; // 存储空间基址 ElemType *elem; // 当前长度 int length; // 当前分配的存储容量（以sizeof(ElemType)为单位） int listSize;&#125; SqList; 初始化12345678Status InitList_Sq(SqList &amp;L) &#123; L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!L.elem) exit(OVERFLOW); L.length = 0; L.listsize = LIST_INIT_SIZE; return OK;&#125; 操作实现查找时间复杂度：$O(n)$。 线性表操作LocateItem的实现： 1234567891011121314int LocateElem_Sq( SqList L, ElemType e, Status(*compare)(ElemType, ElemType)) &#123; i = 1; p = L.elem; while (i &lt;= L.length &amp;&amp; !(*compare)(*p++, e)) ++i; if (i &lt;= L.length) return i; else return 0;&#125; 插入将$(a_1, …, a_{i-1}, a_i, …, a_n)$变为$(a_1, …, a_{i-1}, e, a_i, …, a_n)$。 时间复杂度：$O(n)$。 考虑平均的情况： 假设在第$i$个元素之前插入的概率为$p_i$，则在长度为n的线性表中插入一个元素所需移动元素次数的期望值为： $$E_{is} = \\sum_{i=1}^{n+1} p_i (n-i+1)$$ 若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为： 线性表操作InsertItem的实现： $$E_{is} = \\frac1{n+1} \\sum_{i=1}^{n+1} (n-i+1) = \\frac n2$$ 123456789101112131415161718192021222324252627282930Status ListInsert_Sq(SqList &amp;L, int i, ElemType e) &#123; if (i &lt; 1 || i &gt; L.length + 1) return Error; // 当前空间已满，重新分配 if (L.length &gt;= L.listsize) &#123; newbase = (ElemType*)realloc( L.elem, (L.listsize + LIST_INCREMENT) * sizeof(ElemType) ); // 存储分配失败 if (!newbase) exit (OVERFLOW); // 新基址 L.elem = newbase; // 增加存储容量 L.listsize += LIST_INCREMENT; &#125; // q为插入位置 q = &amp;(L.elem[i - 1]); // 插入位置及之后的元素右移 for (p = &amp;(L.elem[L.length - 1]); p &gt;= q; --p) *(p + 1) = *p; // 插入e *q = e; // 表长增1 ++L.length; return Ok;&#125; 删除将$(a_1, …, a_{i-1}, a_i, a_{i+1}, …, a_n)$变为$(a_1, …, a_{i-1}, a_{i+1}, …, a_n)$。 时间复杂度：$O(n)$。 考虑平均的情况： 假设删除第$i$个元素的概率为$q_i$，则在长度为$n$的线性表中删除一个元素所需移动元素次数的期望值为： $$E_{dl} = \\sum_{i=1}^n q_i (n-i)$$ 若假定在线性表中任何一个位置上进行删除操作的概率都是相等的，则移动元素的期望值为： $$E_{dl} = \\frac1n\\sum_{i=1}^n(n-i) = \\frac{n-1}2$$ 线性表操作DeleteItem的实现： 1234567891011Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e) &#123; if ((i &lt; 1) || (i &gt; L.length)) return ERROR; p = &amp;(L.elem[i - 1]); e = *p; q = L.elem + L.length - 1; for (++p; p &lt;= q; ++p) *(p - 1) = *p; --L.length; return OK;&#125; 2.3 线性表类型的实现——链式映像定义用一组地址任意的存储单元存放线性表中的数据元素。 元素+指针=结点。以「节点的序列」表示线性表——称作链表。 123456789101112131415161718graph LRsubgraph A1 a1 p1[ ]endsubgraph A2 a2 p2[ ]endsubgraph A3 a3 p3[^]endp1 --&gt; a2p2 --&gt; a3 以线性表中第一个数据元素$a_1$的存储地址作为线性表的地址，称作线性表的头指针。 结点和单链表的C语言描述： 123456typedef struct LNode &#123; // 数据域 ElemType data; // 指针域 struct LNode *next;&#125;LNode, *LinkList; 初始化12345678910void CreateList_L(LinkList &amp;L, int n) &#123; L = (LinkList)malloc(sizeof (LNode)); L -&gt; next = NULL; for (i = n; i &gt; 0; --i) &#123; p = (LinkList)malloc(sizeof(LNode)); scanf(&amp;p -&gt; data); p -&gt; next = L -&gt; next; L -&gt; next = p; &#125;&#125; 操作实现查找基本操作为：使指针p始终只想线性表中的第j个数据元素。 时间复杂度：$O(n)$。 123456789101112Status GetItem_L(LinkList L, int i, ElemType &amp;e) &#123; p = L -&gt; next; j = 1; while (p &amp;&amp; j &lt; i) &#123; p = p -&gt; next; ++k; &#125; if (!p || j &gt; i); return ERROR e = p -&gt; data; return OK;&#125; 插入基本操作为：找到线性表中第i-1个节点，修改其指向后继的指针。 即有序对$&lt;a_{i-1}, a_i&gt;$改变为$&lt;a_{i-1}, e&gt;$和$&lt;e, a_i&gt;$。 时间复杂度：$O(n)$。 123456789101112131415Status ListInsert_L(LinkList &amp;L, int i, ElemType e) &#123; p = L; j = 0; while(p &amp;&amp; j &lt; i - 1) &#123; p = p -&gt; next; ++j; &#125; if (!p || j &gt; i - 1) return ERROR; s = (LinkList)malloc(sizeof(LNode)); s -&gt; data = e; s -&gt; next = p -&gt; next; p -&gt; next = s; return OK;&#125; 删除基本操作为：找到线性表中第i-1个节点，修改其指向后继的指针。 即有序对$&lt;a_{i-1}, a_i&gt;$和$&lt;a_i, a_{i+1}&gt;$改变为$&lt;a_{i-1}, a_{i+1}&gt;$。 时间复杂度：$O(n)$。 123456789101112131415Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e) &#123; p = L; j = 0; while(p -&gt; next &amp;&amp; j &lt; i - 1) &#123; p = p -&gt; next; ++j; &#125; if (!p || j &gt; i - 1) return ERROR; q = p -&gt; next; p -&gt; next = q -&gt; next; e = q -&gt; data; free(q); return OK;&#125; 单链表的问题 表长是一个隐含的值； 在最后位置插入元素时需要遍历整个链表； 「位序」概念淡化，结点的「位置」概念强化。 改进：TODO… 其他形式的链表双向链表12345typedef struct DuLNode &#123; ElemType data; struct DuLNode *prior; struct DuLNode *next;&#125; DuLNode, *DuLinkList; 循环链表最后一个节点的指针域的指针又指回第一个节点的链表。 2.4 一元多项式的表示定义$$P_n(x) = p_0 + p_1x + p_2x^2 + … + p_nx^n$$ 在计算机中可以用一个线性表来表示： $$P = (p_0, p_1, …, p_n)$$ 但是在存储很多系数为0的情况下就不合适了（如$S(x) = 1+3x^{10000}-2x^{999}$）。 一般情况下一元多项式可写成： $$P_n(x) = p_1x^{e_1} + p_2x^{e_2} + … + p_mx^{e_m}$$ 其中，$p_i$是指数为$e_i$的项的非零系数。 因此在计算机中可以表示为： $$((p_1, e_1), (p_2, e_2), …, (p_m, e_m))$$ 如： $$P_{999}(x) = 7x^3 - 2x^{12} - 8x^{999}$$ 可以表示为： $$((7, 3), (-2, 12), (-8, 999))$$ 抽象数据类型12345678910111213141516171819typedef struct &#123; // 系数 float coef; // 指数 int expn;&#125; term, ElemType;typedef LinkList polynomial;void CreatePolyn(polynomial &amp;P, int m);void DestroyPolyn(polynomial &amp;P);void PrintPolyn(polynomial &amp;P);int PolynLength(polynomial &amp;P);void AddPolyn(polynomial &amp;Pa, polynomial &amp;Pb);void SubPolyn(polynomial &amp;Pa, polynomial &amp;Pb);void MultiplyPolyn(polynomial &amp;Pa, polynomial &amp;Pb);// 依a的指数值&lt;（或=）（或&gt;）b的指数值，分别返回-1、0和+1int cmp(term a, term b); 算法实现（部分）create：创建123456789101112131415161718192021222324252627282930313233343536373839void AddPolyn(polynomial &amp;Pa, polynomial &amp;Pb) &#123; ha = GetHead(Pa); hb = GetHead(Pb); qa = NextPos(Pa, ha); qb = NextPos(Pa, hb); while (qa &amp;&amp; qb) &#123; a = GetCurElem(qa); b = GetCurElem(qb); switch (*cmp(a, b)) &#123; case -1: ha = qa; qa = NextPos(Pa, qa); break; case 0: sum = a.coef + b.coef; if (sum != 0.0) &#123; SetCurElem(qa, sum); ha = qa; &#125; else &#123; DelFirst(hb, qb); FreeNode(qa); &#125; DelFirst(hb, qb); FreeNode(qb); qb = NextPos(Pb, hb); qa = NextPos(Pa, ha); break; case 1: DelFirst(hb, qb); InsFirst(ha, qb); qb = NextPos(Pb, hb); ha = NextPos(Pa, ha); break; &#125; &#125; if (!ListEmpty(Pb)) Append(Pa, qb); FreeNode(hb);&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sr2k.top/blog/tags/数据结构与算法/"},{"name":"严蔚敏数据结构与算法","slug":"严蔚敏数据结构与算法","permalink":"https://sr2k.top/blog/tags/严蔚敏数据结构与算法/"},{"name":"学习","slug":"学习","permalink":"https://sr2k.top/blog/tags/学习/"}]},{"title":"Angular自定义表单组件","date":"2019-03-22T05:51:11.000Z","path":"2019/03/22/Angular自定义表单组件/","text":"Angular、Vue、React 等框架为前端引入了「模块化的概念」，我们可以预先定义好不同的组件，然后在各处复用。而表单在各种 WebApp 中都处于十分重要的位置。今天这个简单的小教程就是在 Angular 中实现一个可以复用的自定义表单组建。 这个表单组建功能十分简单：允许用户输入手机号，并选择手机号的国家区号。 新建&amp;配置项目首先我们使用 Angular CLI 来新建一个最最普通的 Angular 应用，并创建一个名叫 PhoneNumInput的组件作为我们的自定义表单组件： 123456# 我更喜欢用 Yarn 所以这里先跳过 NPM 的安装过程了ng new ng-custom-form-control-demo --skip-installcd ng-custom-form-control-demoyarnng g c phone-num-input 由于我们会使用响应式表单，因此需要在 app.module.ts 中的 imports 中导入ReactiveFormsModule： 12345678// src/app/app.module.ts// ...imports: [ // ... ReactiveFormsModule]// ... 输入框接下来，我们需要为自组件添加一个输入框和一个选择框，修改 phone-num-input.component.html： 1234567&lt;!-- src/phone-num-input/phone-num-input.component.html --&gt;&lt;select [ngModel]=\"regionCode\"&gt; &lt;option value=\"+86\"&gt;+86&lt;/option&gt; &lt;option value=\"+1\"&gt;+1&lt;/option&gt;&lt;/select&gt;&lt;input type=\"tel\" placeholder=\"Phone number...\" [ngModel]=\"phoneNum\" /&gt; 然后在 phone-num-input.component.ts 中新增两个属性： 12345678// src/phone-num-input/phone-num-input.component.tsexport class PhoneNumInputComponent implements OnInit, ControlValueAccessor &#123; regionCode = '+86'; phoneNum = ''; // ...&#125; 引入子组件然后，我们需要在 AppComponent 中引入我们的表单组件。 将 app.component.html 中的内容修改为： 12345&lt;!-- src/app/app.component.html --&gt;&lt;form [formGroup]=\"form\"&gt; &lt;app-phone-num-input formControlName=\"phoneNum\"&gt;&lt;/app-phone-num-input&gt;&lt;/form&gt; 然后修改 app.component.ts： 12345678910111213141516171819// src/app/app.component.ts// ...export class AppComponent implements OnInit &#123; // ... // 表单 form: FormGroup; // 注入 FormBuilder 来生成表单 constructor(private fb: FormBuilder) &#123; &#125; ngOnInit() &#123; // 生成表单 this.form = this.fb.group(&#123; phoneNum: [null, [Validators.pattern(/^\\+1/)]] &#125;); &#125;&#125; 注册服务提供商现在，我们需要让 Angular 知道我们的 PhoneNumInputComponent 是一个自定义表单组件，因此需要为其注册服务提供商，在 phone-num-input.component.ts 中 PhoneNumInputComponent的类定义之前假如如下元数据： 1234567// src/phone-num-input/phone-num-input.component.tsexport const APP_PHONE_NUM_INPUT_VALUE_ACCESSOR = &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; PhoneNumInputComponent), multi: true&#125;; 然后在 PhoneNumInputComponent 的 @Component 装饰器中加上一个 providers 数组： 123456// src/phone-num-input/phone-num-input.component.ts@Component(&#123; // ... providers: [APP_PHONE_NUM_INPUT_VALUE_ACCESSOR]&#125;) ControlValueAccessor 接口要使用自定义表单组件，我们必须为组件实现 ControlValueAccessor 接口，以此来告诉 Angualr表单如何与我们的组件交互，此接口的定义如下： 12345678910interface ControlValueAccessor &#123; // 外部向组件内写入数值 writeValue(obj: any): void // 注册数据变化回调 registerOnChange(fn: any): void // 注册脏值回调 registerOnTouched(fn: any): void // 禁用状态配置 setDisabledState(isDisabled: boolean)?: void&#125; 将 PhoneNumInputComponent 类修改如下： 12345678// src/phone-num-input/phone-num-input.component.tsexport class PhoneNumInputComponent implements ControlValueAccessor &#123; registerOnChange(fn: (val: string) =&gt; void) &#123; registerOnTouched(fn: (touched: boolean) =&gt; void) &#123; setDisabledState(isDisabled: boolean): void &#123;&#125; writeValue(val: string): void &#123;&#125;&#125; 看起来很复杂，下边用例子解释这些方法要怎么使用。 禁用组件首先，我们来实现一个最最简单的功能：在父组件禁用我们的表单组件。 修改 app.module.ts，增加表单禁用的属性和方法： 12345678910111213141516// src/app/app.component.tsexport class AppComponent implements OnInit &#123; // ... formDisabled = false; toggleFormDisable() &#123; this.formDisabled = !this.formDisabled; if (this.formDisabled) &#123; this.form.disable(); &#125; else &#123; this.form.enable(); &#125; &#125;&#125; 然后修改 app.component.html，添加禁用表单的按钮： 123456&lt;!-- src/app/app.component.html --&gt;&lt;!-- ... --&gt;&lt;div&gt; &lt;button (click)=\"toggleFormDisable()\"&gt;Toggle Disable&lt;/button&gt;&lt;/div&gt; 接下来我们就要实现 setDisabledState 方法了。这个方法会在父组件请求修改子表单组件的禁用状态时被调用，因此，修改 phone-num-input.component.ts： 1234567891011// src/phone-num-input/phone-num-input.component.tsexport class PhoneNumInputComponent implements OnInit, ControlValueAccessor &#123; disabled = false; // ... setDisabledState(isDisabled: boolean) &#123; this.disabled = isDisabled; &#125;&#125; 然后在 phone-num-input.component.html 中把我们的 input 的 disabled 属性绑定到组件上的 disabled 中： 123&lt;!-- src/phone-num-input/phone-num-input.component.html --&gt;&lt;input type=\"tel\" placeholder=\"Phone number...\" [disabled]=\"disabled\" /&gt; 现在，你在 AppComponent 中点击 Toggle Disable 按钮时，子组件的 input 就会在禁用/启用的状态中切换了。 父组件向表单组件传值现在假设我们的用户已经在别处提供过手机号了，因此我们希望在 AppComponent 被初始化时就给PhoneNumInputComponent 提供一个初始值。这里就可以使用 writeValue 方法了。 首先修改 AppComponent 的 ngOnInit() 钩子方法： 1234567// src/app/app.component.tsngOnInit() &#123; // ... this.form.get('phoneNum').setValue('+86-13912345678');&#125; 然后修改 PhoneNumInputComponent 的 writeValue() 方法： 1234567// src/phone-num-input/phone-num-input.component.tswriteValue(val: string) &#123; const s = val.split('-'); this.regionCode = s[0]; this.phoneNum = s[1];&#125; 现在，每次打开你的 app，页面上都会显示预先定义好的值了。 子组件向父组件传值现在，我们要在用户输入时告诉父组件数据的变化，这里是用的是 registerOnChange() 注册的方法。 在 app-component.html 中加入一行： 12345&lt;!-- src/app/app.component.ts --&gt;&lt;!-- ... --&gt;&lt;p&gt;Your phone number is: &#123;&#123;this.form.get('phoneNum').value&#125;&#125;&lt;/p&gt;&lt;!-- ... --&gt; 现在，让我们注册一下子组件向父组件传值的方法： 1234567891011121314// src/phone-num-input/phone-num-input.component.tsexport class PhoneNumInputComponent implements ControlValueAccessor &#123; // ... onChange: (val: string) =&gt; void; // registerOnChange 会给我们传入一个函数，用来向上传值，我们需要把这个函数保存下来 registerOnChange(fn: (val: string) =&gt; void) &#123; this.onChange = fn; &#125; // ...&#125; 由于我们需要观测 PhoneNumInputComponent 中两个 ngModel 的变化，因此修改phone-num-input.component.html： 1234567891011&lt;!-- src/phone-num-input/phone-num-input.component.html --&gt;&lt;select [ngModel]=\"regionCode\" (ngModelChange)=\"regionCodeChange($event)\"&gt; &lt;option value=\"+86\"&gt;+86&lt;/option&gt; &lt;option value=\"+1\"&gt;+1&lt;/option&gt;&lt;/select&gt;&lt;input type=\"tel\" placeholder=\"Phone number...\" [ngModel]=\"phoneNum\" (ngModelChange)=\"phoneNumChange($event)\" /&gt; 然后在组件中添加对应的变动处理方法： 12345678910111213141516// src/phone-num-input/phone-num-input.component.tsexport class PhoneNumInputComponent implements ControlValueAccessor &#123; // ... regionCodeChange(val: string) &#123; this.regionCode = val; // 调用传值方法，向父组件传值 this.onChange(`$&#123;this.regionCode&#125;-$&#123;this.phoneNum&#125;`); &#125; phoneNumChange(val: string) &#123; this.phoneNum = val; // 调用传值方法，向父组件传值 this.onChange(`$&#123;this.regionCode&#125;-$&#123;this.phoneNum&#125;`); &#125;&#125; 现在，你在输入框里输入数值，首页的 &lt;p&gt; 里的电话号码也会跟着变了～ 更新组件脏值状态如果你足够细心，你会发现我之前给表单添加了一条验证规则：Validators.pattern(/^\\+1/)，这就意味着只有以 +1 开头的手机号才是正确的。 现在我们要给表单增加一个提示，告诉用户你的输入不正确。试想，如果你是用户，你明明还没有修改表单的数据，表单就告诉你输错了，肯定是个不好的体验。更好的设计应该是：用户已经手动修改过数据了，而且输错了，再显示提示。 在 Angular 中我们可以使用 FormControl 的 touched 属性知道值是否被用户动过。 修改你的，添加错误提示语： 1234567&lt;!-- src/app/app.component.ts --&gt;&lt;!-- ... --&gt;&lt;p *ngIf=\"this.form.get('phoneNum').touched &amp;&amp; this.form.get('phoneNum').hasError('pattern')\"&gt; Phone number shall start with +1!&lt;/p&gt;&lt;!-- ... --&gt; 现在，我们需要在子组件 &lt;input&gt; 和 &lt;select&gt; 被修改时通知父组件：这个值被用户动过啦！ 修改 phone-num-input.component.ts： 1234567891011121314151617181920// src/phone-num-input/phone-num-input.component.tsexport class PhoneNumInputComponent implements ControlValueAccessor &#123; // ... onTouched: (touched: boolean) =&gt; void; // 和之前一样，把传进来的函数保存下来 registerOnTouched(fn: (touched: boolean) =&gt; void) &#123; this.onTouched = fn; &#125; regionCodeChange(val: string) &#123; // ... this.onTouched(true); &#125; phoneNumChange(val: string) &#123; // ... this.onTouched(true); &#125;&#125; 最终代码app-module.ts1234567891011121314@NgModule(&#123; declarations: [ AppComponent, PhoneNumInputComponent ], imports: [ BrowserModule, ReactiveFormsModule, FormsModule ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; app-component.html123456789101112&lt;form [formGroup]=\"form\"&gt; &lt;app-phone-num-input formControlName=\"phoneNum\"&gt;&lt;/app-phone-num-input&gt; &lt;p *ngIf=\"this.form.get('phoneNum').touched &amp;&amp; this.form.get('phoneNum').hasError('pattern')\"&gt; Phone number shall start with +1! &lt;/p&gt;&lt;/form&gt;&lt;p&gt;Your phone number is: &#123;&#123;this.form.get('phoneNum').value&#125;&#125;&lt;/p&gt;&lt;div&gt; &lt;button (click)=\"toggleFormDisable()\"&gt;Toggle Disable&lt;/button&gt;&lt;/div&gt; app-component.ts1234567891011121314151617181920212223242526272829@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.sass']&#125;)export class AppComponent implements OnInit &#123; title = 'ng-custom-form-control-demo'; form: FormGroup; formDisabled = false; constructor(private fb: FormBuilder) &#123; &#125; ngOnInit() &#123; this.form = this.fb.group(&#123; phoneNum: [null, [Validators.pattern(/^\\+1/)]] &#125;); this.form.get('phoneNum').setValue('+86-13912345678'); &#125; toggleFormDisable() &#123; this.formDisabled = !this.formDisabled; if (this.formDisabled) &#123; this.form.disable(); &#125; else &#123; this.form.enable(); &#125; &#125;&#125; phone-num-input.component.html123456789&lt;select [ngModel]=\"regionCode\" (ngModelChange)=\"regionCodeChange($event)\"&gt; &lt;option value=\"+86\"&gt;+86&lt;/option&gt; &lt;option value=\"+1\"&gt;+1&lt;/option&gt;&lt;/select&gt;&lt;input type=\"tel\" placeholder=\"Phone number...\" [ngModel]=\"phoneNum\" (ngModelChange)=\"phoneNumChange($event)\" /&gt; phone-num-input.component.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748export const APP_PHONE_NUM_INPUT_VALUE_ACCESSOR = &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; PhoneNumInputComponent), multi: true&#125;;@Component(&#123; selector: 'app-phone-num-input', templateUrl: './phone-num-input.component.html', styleUrls: ['./phone-num-input.component.sass'], providers: [APP_PHONE_NUM_INPUT_VALUE_ACCESSOR]&#125;)export class PhoneNumInputComponent implements ControlValueAccessor &#123; regionCode = '+86'; phoneNum = ''; onChange: (val: string) =&gt; void; onTouched: (touched: boolean) =&gt; void; disabled = false; registerOnChange(fn: (val: string) =&gt; void) &#123; this.onChange = fn; &#125; registerOnTouched(fn: (touched: boolean) =&gt; void) &#123; this.onTouched = fn; &#125; setDisabledState(isDisabled: boolean) &#123; this.disabled = isDisabled; &#125; writeValue(val: string) &#123; const s = val.split('-'); this.regionCode = s[0]; this.phoneNum = s[1]; &#125; regionCodeChange(val: string) &#123; this.regionCode = val; this.onChange(`$&#123;this.regionCode&#125;-$&#123;this.phoneNum&#125;`); this.onTouched(true); &#125; phoneNumChange(val: string) &#123; this.phoneNum = val; this.onChange(`$&#123;this.regionCode&#125;-$&#123;this.phoneNum&#125;`); this.onTouched(true); &#125;&#125;","tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://sr2k.top/blog/tags/TypeScript/"},{"name":"Angular","slug":"Angular","permalink":"https://sr2k.top/blog/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"https://sr2k.top/blog/tags/前端/"}]},{"title":"JavaScript中的面向对象","date":"2018-01-12T11:24:14.000Z","path":"2018/01/12/JavaScript面向对象/","text":"对象简介在JS中创建一个对象十分简单，可以使用Object构造方法，也可以直接使用对象字面量： 123456const person = &#123; name: \"Siyuan\", sayName() &#123; console.log(this.name); &#125;&#125;; 属性类型JS引擎在内部使用的特性，描述了属性的各种特征。 数据类型 [[Configurable]]：能否通过delete删除属性、能否修改属性的特性、或者能否把属性修改为访问器属性。默认值为true； [[Enumerable]]：能否通过for-in循环遍历到此属性。默认值为true； [[Writable]]：能否修改属性的值。默认值为true； [[Value]]：此属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined。 ES5的Object.defineProperty()方法可以修改上述各值。这个方法接收三个参数： 属性所在的对象； 属性的名字； 描述符对象。 其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value，如： 1234567891011const person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, value: \"Siyuan\" &#125;);console.log(person.name); //\"Siyuan\"person.name = \"Not Siyuan\";console.log(person.name); //\"Siyuan\"// 如果是严格模式下会报错 如果把configurable设置为false，就不能再把它变回可配置了。此时，再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误。也就是说，可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。 访问器属性访问器属性包含一对可选的getter和setter函数。他们函数负责决定如何处理数据。访问器属性有如下4个特性： [[Configurable]]； [[Enumerable]]； [[Get]]：在读取属性时调用的函数。默认值为undefined； [[Set]]：在写入属性时调用的函数。默认值为undefined。 访问器属性不能直接定义，必须使用Object.defineProperty()来定义： 12345678910111213141516const sr2k = &#123; _absCount: 6 // 嗯谁不想要腹肌捏 ///w//&#125;;Object.defineProperty(sr2k, \"absCount\", &#123; get() &#123; return this._absCount; &#125;, set(newValue) &#123; // 正常人不会有超过8块的腹肌吧… this._absCount = newValue &gt; 8 ? 8 : newValue; &#125;&#125;);sr2k.absCount = 12;console.log(sr2k.absCount); // 8 定义多个属性ES5又定义了一个Object.defineProperties()方法，可以一次定义多个属性。这个方法接收两个对象参数，如： 123456789101112131415161718192021222324const sr2k = &#123;&#125;;Object.defineProperties(sr2k, &#123; _hadBreakfast: &#123; writable: true, value: false &#125;, hungry: &#123; writable: true, value: true &#125;, hadBreakfast: &#123; get() &#123; return this._hadBreakfast; &#125;, set(newValue) &#123; this._hadBreakfast = newValue; // 吃了早饭就不饿啦 this.hungry = !newValue; &#125; &#125;&#125;); 读取属性的特性使用ES5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符： 如上文吃早饭的例子： 123456789let descriptor = Object.getOwnPropertyDescriptor(book, \"_hadBreakfast\");console.log(descriptor.value); // falseconsole.log(descriptor.configurable); // falseconsole.log(typeof descriptor.get); // \"undefined\"descriptor = Object.getOwnPropertyDescriptor(book, \"hadBreakfast\");console.log(descriptor.value); // undefinedconsole.log(descriptor.enumerable); // falseconsole.log(typeof descriptor.get); // \"function\" 创建对象工厂模式123456function createPerson(name, age) &#123; let obj = new Object(); obj.name = name; obj.age = age; return obj;&#125; 解决了创建多个相似对象的问题； 没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数模式与工厂模式相比，构造函数： 没有显式地创建对象； 直接将属性和方法赋给了this对象； 没有return语句。 12345678910111213function Person(name, age) &#123; // this就指向了这个new出来的新对象 this.name = name; this.age = age; this.sayName = function() &#123; alert(this.name); &#125;; &#125;const sr2k = new Person(\"Siyuan\", 22);console.log(sr2k instanceof Object); // trueconsole.log(sr2k instanceof Person); // trueconsole.log(sr2k.constructor === Person); // true 将构造函数当作函数构造函数也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。 在使用new操作符时，函数内this就指向了这个new出来的新对象；而不使用this时，就依据原来的上下文判断this了： 123456789101112// 当作构造函数使用，this指向new出来的personconst person = new Person(\"Siyuan\", 22);person.sayName(); //\"Nicholas\"// 作为普通函数调用，this指向windowPerson(\"Siyuan\", 22);window.sayName(); //\"Greg\"// 在另一个对象的作用域中调用，this指向这个对象const o = new Object();Person.call(o, \"Siyuan\", 22);o.sayName(); //\"Siyuan\" 构造函数的问题每个方法都要在每个实例上重新创建一遍，无法实现继承。且每个对象都有自己的方法，虽然作用一样，却不是同一个Function对象： 1new Person(\"\", 0).sayName === new Person(\"\", 0).sayName // false 原型模式每个函数都有一个prototype（原型）属性，这个属性指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 123456789101112131415function Person() &#123;&#125;Person.prototype.name = \"Siyuan\";Person.prototype.age = 22;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;const person1 = new Person();person1.sayName(); //\"Siyuan\"const person2 = new Person();person2.sayName(); //\"Siyuan\"console.log(person1.sayName == person2.sayName); // true 理解原型对象只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。 就拿前面的例子来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。 创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ES5中称作针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但大部分浏览器在每个对象上都支持一个属性__proto__。 更加标准地获得[[Prototype]]的方法是使用ES5的Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。 12345678910111213141516171819graph TDsubgraph a func[function] prototypeendsubgraph b obj[object] proto[__proto__]endsubgraph c protoObj[prototypeObject] con[constructor]endprototype --&gt; protoObjconstructor --&gt; funcproto --&gt; protoObj 读取某个对象的某个属性时，查找这个属性的顺序如下： 如果在实例中找到了具有给定名字的属性，则返回该属性的值； 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性；如果在原型对象中找到了这个属性，否则继续查找原型对象的原型对象； 直到查找到Object，还是没有找到这个属性，则返回undefined。 使用hasOwnProperty方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法是从Object继承来的），它只在给定属性存在于对象实例中时，才会返回true。来看下面这个例子。 原型与in操作符有两种方式使用in操作符：单独使用和在for-in循环中使用。 在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。 由于in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty()只在属性存在于实例中时才返回true，因此只要in操作符返回true而hasOwnProperty()返回false，就可以确定属性是原型中的属性。 在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为false属性）的实例属性也会在for-in循环中返回。 要取得对象自身的所有可枚举的实例属性，可以使用ES5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 更简单的原型语法每次都写一个Func.prototype.xxx = xxx;十分繁琐，因此更常见的做法是用一个对象字面量来重写整个原型对象： 123456789function Person() &#123;&#125;;Person.prototype = &#123; name : \"siyuan\", age : 22, sayName : function() &#123; console.log(this.name); &#125;&#125;; 这样做与之前大体相同，不过有一点区别：Person.prototype不再带有指向Person的constructor属性了，因此只能通过instanceof操作符来判断对象的类型。 不过你也可以给prototype手动加上constructor： 123456789101112131415function Person() &#123;&#125;;Person.prototype = &#123; name : \"siyuan\", age : 22, sayName : function() &#123; console.log(this.name); &#125;&#125;;Object.defineProperty(Person.prototype, \"constructor\", &#123; // 要保证constructor是不可枚举的 enumerable: false, value: Person&#125;); 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型。 所有原生的引用类型（Object、Array、String，etc）都是采用这种原型模式创建的。 所有原生引用类型都在其构造函数的原型上定义了方法。例如在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法。 原型对象的问题原型模式省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。 原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，这个问题很大很大： 1234567891011121314151617181920function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name : \"Siyuan\", age : 22, friends : [\"Eddy\", \"Jeffrey\"], sayName : function () &#123; alert(this.name); &#125;&#125;;const person1 = new Person();const person2 = new Person();person1.friends.push(\"Amanda\");console.log(person1.friends); // [\"Eddy\", \"Jeffrey\", \"Amanda\"]console.log(person2.friends); // [\"Eddy\", \"Jeffrey\", \"Amanda\"]console.log(person1.friends === person2.friends); //true 组合继承组合继承就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。 这样每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数。 123456789101112131415161718192021function Person(name, age)&#123; this.name = name; this.age = age; this.friends = [\"Shelby\", \"Court\"];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125;&#125;const person1 = new Person(\"Siyuan\", 22);const person2 = new Person(\"Eddy\", 23);person1.friends.push(\"Van\");alert(person1.friends); // \"Shelby,Count,Van\"alert(person2.friends); // \"Shelby,Count\"alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true 动态原型模式动态原型模式把所有信息都封装在了构造函数中，通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。 123456789101112function Person(name, age) &#123; // 属性 this.name = name; this.age = age; // 方法 if (typeof this.sayName != \"function\") &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125; 寄生构造函数模式在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。假设你想创建一个具有额外方法的特殊数组，但又不能直接修改Array构造函数，因此可以使用这个模式： 1234567891011121314function SpecialArray() &#123; // 创建数组 const values = new Array(); // 添加值 values.push.apply(values, arguments); // 添加方法 values.toPipedString = function()&#123; return this.join(\"|\"); &#125;; // 返回数组 return values;&#125;const colors = new SpecialArray(\"red\", \"blue\", \"green\"); 注意：返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，建议在可以使用其他模式的情况下，不要使用这种模式。 稳妥构造函数模式所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。 稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同： 新创建对象的实例方法不引用this； 不使用new操作符调用构造函数。 按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下： 12345678910111213function Person(name, age) &#123; // 创建要返回的对象 const o = new Object(); // ...定义私有变量和函数 //添加方法 o.sayName = function() &#123; alert(name); &#125;; // 返回对象 return o;&#125; 这样，变量friend中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。 继承原型链让原型对象等于另一个类型的实例，此时原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承了SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); // true 借用构造函数原型中包含引用类型值存在问题，我们可以使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）：在子类型构造函数的内部调用超类型构造函数。 函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数，如： 123456789101112131415function SuperType() &#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType() &#123; // 继承了SuperType SuperType.call(this);&#125;const instance1 = new SubType();instance1.colors.push(\"black\");console.log(instance1.colors); // [\"red\", \"blue\", \"green\", \"black\"]var instance2 = new SubType();console.log(instance2.colors); // [\"red\", \"blue\", \"green\"] 组合继承组合继承（combination inheritance）指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。 其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性： 123456789101112131415161718192021222324252627282930313233function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;;var instance1 = new SubType(\"Nicholas\", 29);instance1.colors.push(\"black\");console.log(instance1.colors); // [\"red\", \"blue\", \"green\", \"black\"]instance1.sayName(); // \"Nicholas\"instance1.sayAge(); // 29var instance2 = new SubType(\"Greg\", 27);console.log(instance2.colors); // [\"red\", \"blue\", \"green\"]instance2.sayName(); // \"Greg\"instance2.sayAge(); // 27 原型式继承ES5新增了Object.create()方法，接收两个参数： 用作新对象原型的对象； （可选的）一个为新对象定义额外属性的对象。 在传入一个参数的情况下，Object.create()与object()方法的行为相同。 Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。 123456789101112const person = &#123; name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"]&#125;;const anotherPerson = Object.create(person, &#123; name: &#123; value: \"Greg\" &#125;&#125;);console.log(anotherPerson.name); // \"Greg\" 寄生式继承寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄生式继承模式。 123456789101112131415161718function createAnother(original) &#123; // 通过调用函数创建一个新对象 const clone = Object(original); // 以某种方式来增强这个对象 clone.sayHi = function() &#123; alert(\"hi\"); &#125;; // 返回这个对象 return clone;&#125;const person = &#123; name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"]&#125;;const anotherPerson = createAnother(person);anotherPerson.sayHi(); // \"hi\" 寄生组合式继承寄生组合式继承是通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。 12345function inheritPrototype(subType, superType)&#123; var prototype = Object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sr2k.top/blog/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://sr2k.top/blog/tags/读书笔记/"},{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"https://sr2k.top/blog/tags/JavaScript高级程序设计/"}]},{"title":"【译】如何在 macOS 上使用 NSTouchBar","date":"2017-10-09T16:01:11.000Z","path":"2017/10/10/译-如何在macOS上使用NSTouchBar/","text":"本文翻译自 raywenderlich.com 的 How to Use NSTouchBar on macOS，已咨询对方网站，可至多翻译 10 篇文章。各位若有英语阅读能力的话，还是先打赏然后去阅读英文原吧😉。综上，此翻译版本仅供参考，谢绝转载。 对了我跟着这个教程敲代码的时候发现文中所有的 @available(OSX 10.12.1, *) 其实应为 @available(OSX 10.12.2, *)，但是出于对原文的尊重没有修改，请各位注意～ 等了好久好久终于等到今天之后，Apple 终于发布了新款的 MacBook Pro，它最惹人瞩目的应该就是那块（小小的）触屏了吧。 新款设备用全新的 Touch Bar 替代了原有的功能键，它们可扩展、支持多点触控，更重要的是，Touch Bar 对开发者们完全开放，这意味着你的 macOS app 可以获得一种全新的交互方式。 如果你是一个 macOS 开发者，你一定很希望自己的 app 能够立刻使用上这项前沿科技。在这个教程中，我会将向你们展示如何使用全新的 NSTouchBar API 来为你的 macOS app 创建一个动态的 Touch Bar。 注意：这个教程需要 Xcode 8.1 或更高版本以及 macOS 10.12.1 (Build 16B2657) 或更高版本，否则的话你将无法运行 Touch Bar 模拟器。你可以在  → 关于本机里点击数字版本号来查看 build 版本。 如果你的版本不够，你可以在 Apple 的网站上 下载。 Touch Bar 是个啥？如上文所述，Touch Bar 是一块安装在键盘上方的细长形的触摸屏，它允许用户使用一种全新的方式来与 app（以及 Mac）进行交互。 在 Touch Bar 上有三个默认的部分： 系统按钮：根据运行的 app，这里将会显示一个系统级的按钮，比如 esc； App 区域：你的 app 可以控制的显示区域，也就是我们的主舞台； 控制条：这里用于显示你熟悉的控制按钮，比如亮度、音量等。 和其它许多 Apple 的新科技一样，Touch Bar 也拥有自己的《人机交互则例（Human Interface Guidelines）》，为了你的 app 和其它 Mac app 拥有统一的用户体验，你应当遵循这份则例。你可以点击这里阅读它。 概括说来，这份则例中比较重要的几点有： App 中的某个功能不应该只能在 Touch Bar 中使用：即使部份用户还未升级到最新的硬件，你的 app 也应该尽量为他们提供一样的功能。如果你决定为 Touch Bar 加入某些功能，请确保这个功能也能在 app 的其他某处也可以访问到。另外 Touch Bar 是可以被用户禁用的，所以也别太指望你的用户能一直看到它； Touch Bar 是键盘的延伸，而不是一个显示屏：诚然，Touch Bar 是一个显示屏，但是它不是显示器的延伸，而是一个与 app 交互的窗口。你不应该在 Touch Bar 上用滚来滚去的内容或 blingbling 的警告打扰用户的视线； 快速响应：用户在键盘上按下一个真实的按键时，按键会立即给予一个反馈（也就是被按下去了）。同理，用户在 Touch Bar 上按下一个虚拟按钮时，你也应该给他们提供即时的反馈。 如何让你的 app 支持 Touch Bar要让你的 app 支持 Touch Bar，你需要使用 Apple 提供的两个类：NSTouchBar 和 NSTouchBarItem（当然还有他们的子类）。 某些 NSTouchBarItem 的子类提供了这些功能： Slider：滑动调节某个值； Popover：把更多功能藏入一个二级菜单中； Color Picker：和名字一样，用来选取颜色的咯🤷‍♀️； Custom：这个子类是你的天下，你可以在它的里面塞入文本、按钮以及其他各种各样的控件。 从文字大小颜色到图片内容，你可以随意自定义你的 item，从而为你的用户提供一个传统键盘无法提供的、更加牛×的交互方式，但是请时刻请谨记《人机交互则例》。现在我们要开始动工啦。 准备开始在开始敲代码之前，请先点击这里下载初始项目的源代码。 我们要编写的 app 是一个简单的旅行记录 app。打开初始项目，如果你的设备不支持 Touch Bar，请点击 Xcode 菜单栏上的 Window → Show Touch Bar，Touch Bar 的模拟器就会出现在屏幕上。 编译并运行你的 app，你将会看到 Touch Bar 上除了 esc 按钮和控制条以外空空如也。 我们要做的第一步是告诉系统我们的 app 需要自定义 Touch Bar。打开 AppDelegate.swift，将这些代码添加到 applicationDidFinishLaunching(_:) 方法中： 12345func applicationDidFinishLaunching(_ aNotification: Notification) &#123; if #available(OSX 10.12.1, *) &#123; NSApplication.shared().isAutomaticCustomizeTouchBarMenuItemEnabled = true &#125;&#125; 这些代码将会帮你搞定启用 Touch Bar 所需要的各种操作，（在写这篇文章的时候）Xcode 还没有 macOS 10.12.1 的配套 SDK，所以你需要在 Touch Bar 相关的代码周边添加 #available(OS X 10.12.1, *)，当然如果你忘了这件事，Xcode 会给你一个温馨的提醒😉。 打开 WindowController.swift，找到 makeTouchBar()，这个方法用于检测 ViewController 是否含有一个可以被返回的 Touch Bar，如果有，它会把这个 Touch Bar 返回给 Window，然后呈现给用户。现在，我们还没有创建 Touch Bar，所以什么也不会发生。 在你开始创建自己的 Touch Bar 和 Touch Bar Item 之前，你需要注意这些类都需要独一无二的 identifier（标识符），打开 TouchBarIdentifiers.swift，你将能看到两个扩展定义了一些标识符：NSTouchBarCustomizationIdentifier 和 NSTouchBarItemIdentifier。 前往 ViewController.swift，并把这些带码添加到文件最后 // MARK: - TouchBar Delegate 注释的后方： 123456789101112131415@available(OSX 10.12.1, *)extension ViewController: NSTouchBarDelegate &#123; override func makeTouchBar() -&gt; NSTouchBar? &#123; // 1 let touchBar = NSTouchBar() touchBar.delegate = self // 2 touchBar.customizationIdentifier = .travelBar // 3 touchBar.defaultItemIdentifiers = [.infoLabelItem] // 4 touchBar.customizationAllowedItemIdentifiers = [.infoLabelItem] return touchBar &#125;&#125; 在此处，通过重写 makeTouchBar() 方法，你给你的 View 或 Window 创建了一个 Touch Bar，在这个方法中： 创建一个新的 TouchBar 并设置它的 delegate； 设置 customizationIdentifier（自定义标识符），每个 TouchBar 和 TouchBarItem 都需要一个独一无二的标识符； 设置 Touch Bar 的默认 item 标识符，这将会告诉 Touch Bar 它将会容纳哪些 item； 这一步是允许用户可以自定义的 item。作为参考，你可以打开 Finder，点击菜单栏上的 显示 → 自定 Multi-Touch Bar看看自定义 Touch Bar 是什么效果。 接下来，我们还需要设置 .infoLabelItem 是什么样子的，在同一个 extension 中添加： 12345678910func touchBar(_ touchBar: NSTouchBar, makeItemForIdentifier identifier: NSTouchBarItemIdentifier) -&gt; NSTouchBarItem? &#123; switch identifier &#123; case NSTouchBarItemIdentifier.infoLabelItem: let customViewItem = NSCustomTouchBarItem(identifier: identifier) customViewItem.view = NSTextField(labelWithString: \"\\u&#123;1F30E&#125; \\u&#123;1F4D3&#125;\") return customViewItem default: return nil &#125;&#125; 通过实现touchBar(_:makeItemForIdentifier:) 方法，你可以自定义你的 Touch Bar Item，在段代码里，你创建了一个 NSCustomTouchBarItem，并把它的 view 设置为了 NSTextField。 编译并运行你的 app，你可以看到 Touch Bar 多了一个 item。 耶✌️！通过一番努力你得到了……两个 emoji…好吧，现在我们来添加一些别的控件。 Text Field 和 Scrubber在 makeTouchBar() 里，把 touchBar.defaultItemIdentifiers = [.infoLabelItem] 修改为： 1touchBar.defaultItemIdentifiers = [.infoLabelItem, .flexibleSpace, .ratingLabel, .ratingScrubber] 这些代码会让 Touch Bar 显示三个 item：一个 label、一个 scrubber 以及一个 .flexibleSpace。这是一个动态的间距，它可以把各种 item 按组进行整洁的分类。此外你还可以使用 .fixedSpaceSmall 和 .fixedSpaceLarge 这两个固定间距。 和之前的那个 label 一样，你也需要自定义这些 item，把这些 cases 添加到 touchBar(_:makeItemForIdentifier:) 里的 switch： 123456789101112131415161718case NSTouchBarItemIdentifier.ratingLabel: // 1 let customViewItem = NSCustomTouchBarItem(identifier: identifier) customViewItem.view = NSTextField(labelWithString: \"Rating\") return customViewItemcase NSTouchBarItemIdentifier.ratingScrubber: // 2 let scrubberItem = NSCustomTouchBarItem(identifier: identifier) let scrubber = NSScrubber() scrubber.scrubberLayout = NSScrubberFlowLayout() scrubber.register(NSScrubberTextItemView.self, forItemIdentifier: \"RatingScrubberItemIdentifier\") scrubber.mode = .fixed scrubber.selectionBackgroundStyle = .roundedBackground scrubber.delegate = self scrubber.dataSource = self scrubberItem.view = scrubber scrubber.bind(\"selectedIndex\", to: self, withKeyPath: #keyPath(rating), options: nil) return scrubberItem 一步一步来看： 为「评分」新建了一个新的 label item； 然后创建一个新的 item 用来展示 NSScrubber。这是一个 Touch Bar 特有的控件，它允许你在若干个项目中进行选择。Scrubber 需要一个代理来处理事件，你需要做的是设置一个 delegate（初始项目的源代码已经在 ViewController 里实现过这个协议了）。 编译并运行你的 app，你将会看到 Touch Bar 里多出了两个新的 item，当你点击某个 scrubber 里的项目后，在 app 的主窗口里能看到数值的调整。 Segmented Control接下来，我们来添加一个 Segmented Control。这个控件没有使用 Delegate 模式，因此这刚好可以让你体验一下怎么设置 Touch Bar 里的 Target-Action（目标动作）。回到 makeTouchBar() 中，把这三个 item 添加到 defaultItemIdentifiers 里： 1touchBar.defaultItemIdentifiers = [.infoLabelItem, .flexibleSpace, .ratingLabel, .ratingScrubber, .flexibleSpace, .visitedLabelItem, .visitedItem, .visitSegmentedItem] 以及把最后的三个 case 添加到 touchBar(_:makeItemForIdentifier:) 中： 12345678910111213141516171819case NSTouchBarItemIdentifier.visitedLabelItem: // 1 let customViewItem = NSCustomTouchBarItem(identifier: identifier) customViewItem.view = NSTextField(labelWithString: \"Times Visited\") return customViewItemcase NSTouchBarItemIdentifier.visitedItem: // 2 let customViewItem = NSCustomTouchBarItem(identifier: identifier) customViewItem.view = NSTextField(labelWithString: \"--\") customViewItem.view.bind(\"value\", to: self, withKeyPath: #keyPath(visited), options: nil) return customViewItemcase NSTouchBarItemIdentifier.visitSegmentedItem: // 3 let customActionItem = NSCustomTouchBarItem(identifier: identifier) let segmentedControl = NSSegmentedControl(images: [NSImage(named: NSImageNameRemoveTemplate)!, NSImage(named: NSImageNameAddTemplate)!], trackingMode: .momentary, target: self, action: #selector(changevisitedAmount(_:))) segmentedControl.setWidth(40, forSegment: 0) segmentedControl.setWidth(40, forSegment: 1) customActionItem.view = segmentedControl return customActionItem 一步一步看： 和之前一样，创建一个简单的 Label； 创建另一个 Label，但这一次使用 bind 来把 Label 要显示的文本绑定到一个属性上； 最后，创建一个 Segmented Control，并设置它的 action。你可以看到，为它设置一个 action 和其他常见控件是完全一样的。 编译并运行，除了 Scrubber，你现在还可以和 Segmented Control 交互了。此外，在 Touch Bar 里修改一个数值，app 的主窗口中也会显示出来，反之亦然。 彩色按钮能让用户使用 Touch Bar 来进行「保存」操作是一个不错的点子，因为这个按钮和别的按钮都不一样，我们可以把它设置成绿色的。你可以使用 NSButton 的 bezelColor 属性来给它设置一个特殊的颜色。 打开 TouchBarIdentifiers.swift，在 NSTouchBarItemIdentifier extension 里，添加这些代码： 1static let saveItem = NSTouchBarItemIdentifier(\"com.razeware.SaveItem\") 这将会从头开始创建一个标识符，以此允许你在 Touch Bar 里添加一个 item。 返回 ViewController.swift，添加一个新的 .flexSpace 和 .saveItem 到 Touch Bar 的 defaultItemIdentifiers 里： 1touchBar.defaultItemIdentifiers = [.infoLabelItem, .flexibleSpace, .ratingLabel, .ratingScrubber, .flexibleSpace, .visitedLabelItem, .visitedItem, .visitSegmentedItem, .flexibleSpace, .saveItem] 基本上完成了，最后一步是对按钮进行一些设置。在 touchBar(_:makeItemForIdentifier:) 中添加最后一个 case： 123456case NSTouchBarItemIdentifier.saveItem: let saveItem = NSCustomTouchBarItem(identifier: identifier) let button = NSButton(title: \"Save\", target: self, action: #selector(save(_:))) button.bezelColor = NSColor(red:0.35, green:0.61, blue:0.35, alpha:1.00) saveItem.view = button return saveItem 通过 bezelColor，你已经把这个按钮成功地修改成了绿色。 编译并运行，你会看到 Touch Bar 上有了一个绿色的按钮，它和窗口中的 Save 按钮拥有一样的功能。 现在该做些啥？你可以点击这里下载最终完成的项目。 这些就是 Touch Bar 的基础了。显然，Apple 希望 Touch Bar 的开发过程越简单越好，因此你可以尽快把这些特性尽快地带给新 MacBook Pro 的用户。 在这个教程中，你学到了： 如何设置你的 app，让它能显示 Touch Bar； 如何在 Touch Bar 里显示静止的 Label； 如何使用 binding（绑定）来添加一个动态的 Label； 如何在 Touch Bar 中添加控件，并处理它们的事件。 请不要在此停下！NSTouchBar 和 NSTouchBarItem 中还有很多值得探索的特性。你可以试着在 Touch Bar 里添加一个 Popover，或者也可以试试在你的 app 里格式化一个文本，你还可以在试着去在 Interface Builder 里创建一个 Touch Bar。 How to Use NSTouchBar on macOS","tags":[{"name":"翻译","slug":"翻译","permalink":"https://sr2k.top/blog/tags/翻译/"},{"name":"Ray Wenderlich","slug":"Ray-Wenderlich","permalink":"https://sr2k.top/blog/tags/Ray-Wenderlich/"},{"name":"macOS","slug":"macOS","permalink":"https://sr2k.top/blog/tags/macOS/"},{"name":"Swift","slug":"Swift","permalink":"https://sr2k.top/blog/tags/Swift/"}]},{"title":"【译】macOS 上的 Core Graphics 入门教程","date":"2017-09-25T09:54:11.000Z","path":"2017/09/25/译-macOS上的CoreGraphics入门教程/","text":"本文翻译自 raywenderlich.com 的 Core Graphics on macOS Tutorial，已咨询对方网站，可至多翻译 10 篇文章。希望各位有英语阅读能力的话，还是先打赏然后去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。综上，此翻译版本仅供参考，谢绝转载。 也欢迎你点击我的头像查看我翻译的其他 macOS 开发教程💋 更新于 2016-9-22：此教程已更新至 Xcode 8 和 Swift 3。 你肯定见过许多拥有漂亮的界面和华丽的自定义视图的 app，它们肯定在你的心里留下了深刻的印象，因为它们是那！么！好！看！ Core Graphics 是 Apple 提供的 2D 绘图引擎，也几乎是 macOS 和 iOS 所有框架中最酷的了。它可以用来绘制你能想到的所有图形，从简单的几何形状到复杂的阴影和渐变等视觉效果。 在这个 macOS Core Graphics 教程中，你将会创造一个叫做 DiskInfo 的自定义视图，它能用一张饼图和一个条状图来显示出你 Mac 上的硬盘可用空间。这个教程将会让你拥有把平淡单调的 UI 变得精彩纷呈的能力： 在这个教程中你将学会： 创建并配置一个自定义视图，这是绘制图形元素的必要条件； 实现实时渲染预览功能，有了它你不需要编译和运行，就能在 Interface Builder 里看到你对图形的各种修改； 用代码绘制路径、填充图形、创建剪切蒙版剪辑和渲染文本； 使用 AppKit 里的 Cocoa Drawing 工具提供的高级类和方法。 在第一部分中，你将会通过 Core Graphics 来实现绘制一个饼图，稍后你将会学习如何用 Cocoa Drawing 实现相同的效果。 所以拿起你的小画刷，我们要开始作画啦～ 准备开始点击这里下载 DiskInfo 的起步工程，编译并运行它： 这个 app 会罗列出你的所有硬盘，点击任何一个即可查看他的详细信息。 在操作之前，我们先来熟悉一下这个项目的结构： ViewController.swift：app 的主要 View Controller； VolumeInfo.swift：实现了用于处理硬盘信息的 VolumeInfo 类，以及用于分析不同文件类型所占空间的 FilesDistribution 结构体； NSColor+DiskInfo.swift 和 NSFont+DiskInfo.swift：扩展了 NSColor，定义了 app 中会用到的颜色和字体； CGFloat+Radians.swift：扩展了 CGFloat，提供了转换角度值和弧度制的 helper 方法； MountedVolumesDataSource.swift 和 MountedVolumesDelegate.swift：实现了显示硬盘信息所必需的各类方法。 注意：这个 app 可以显示你真正的硬盘用量信息，但在这个教程中，它将会生成随机的数据。每次启动 app 时都计算一次硬盘上所有文件的类型会很耗时，也会消磨完你所有的乐趣，没人愿意在这上面浪费时间，对吧😉？ 创建一个自定义视图你要做的第一件事是创建一个名叫 GraphView 的自定义视图。这将会是你绘制饼状图和条形图的地方。这个部分中你需要做两件事： 创建一个 NSView 的子类； 重写 draw(_:) 方法，加入一些用于绘制的代码。 创建 NSView 的子类选中项目导航器的 Views 分组，点击去 Xcode 菜单上的 File → New → File…，然后点击 macOS → Source → Cocoa Class 模版。 点击 Next，把新的类命名为 GraphView，并让它继承自 NSView，把语言选择为 Swift。 点击 Next 和 Create 来保存你的文件。 打开 Main.storyboard，在 View Controller Scene 中，从控件库里拖入一个 Custom View。 选中这个 Custom View，在身份检查器里，把它的类名设置为 GraphView。 你需要一些约束，所以保持 Graph View 的选中状态，点击 Auto Layout 工具栏上的 Pin 按钮，把它的 Top、Bottom、Leading 和 Trailing 约束设置为 0，然后点击 Add 4 Constrains 按钮。 点击 Auto Layout 工具栏上的三角形的 Resolve Auto Layout Issues 按钮，然后在 Selected Views 部分中点击 Update Frames。如果这个选项不可用，你可能需要先点击空白处取消选中 Graph View，然后再次选中它。 重写 draw(_:)打开 GraphView.swift，你能看到 Xcode 自动为我们创建了一个 draw(_:) 的实现。把那行注释替换成以下代码，并确保你别不小心删掉了它调用父类此方法的那一行哦。 12NSColor.white.setFill() NSRectFill(bounds) 第一行代码把填充颜色设置为了白色，然后通过调用 NSRectFill 方法，你把整个视图的背景设成了白色。 编译并运行： 你已经把自定义视图的背景从默认的灰色改成了白色。 哈哈，我们的画布已经就绪！就是这么简单～ 实时渲染预览：@IBDesignable 和 @IBInspectableXcode 6 为我们带来了一个牛×的功能：实时渲染预览。它允许你在 Interface Builder 里查看你自定义的视图的样子，而不用每次都编译和运行。 要启用这个功能，你需要用 @IBDesignable 来修饰你的类；并实现 prepareForInterfaceBuilder() 方法来提供一些示例数据（实现这个方法不是必须的）。 打开 GraphView.swift，在类的定义之前加入： 1@IBDesignable 现在你需要提供一些示例数据，把这些代码添加到 GraphView 类中： 123456789101112131415161718192021var fileDistribution: FilesDistribution? &#123; didSet &#123; needsDisplay = true &#125;&#125;override func prepareForInterfaceBuilder() &#123; let used = Int64(100000000000) let available = used / 3 let filesBytes = used / 5 let distribution: [FileType] = [ .apps(bytes: filesBytes / 2, percent: 0.1), .photos(bytes: filesBytes, percent: 0.2), .movies(bytes: filesBytes * 2, percent: 0.15), .audio(bytes: filesBytes, percent: 0.18), .other(bytes: filesBytes, percent: 0.2) ] fileDistribution = FilesDistribution(capacity: used + available, available: available, distribution: distribution)&#125; 这将会定义一个 fileDistribution 属性用于存储硬盘的信息。当这个属性发生改变，它会设置这个视图的 needsDisplay 属性为 true，从而让视图重绘自己的内容。 然后，它实现了 prepareForInterfaceBuilder() 方法，以此创建了一个各种文件类型的例子，用于给 Xcode 预览这个视图。 注意：你甚至可以在 Interface Builder 里实时修改视觉属性。这要求你用 @IBInspectable 来修饰这个属性。 下一步：用 @IBInspectable 修饰所有的视觉属性，把这些代码添加到 GraphView 的声明中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 1fileprivate struct Constants &#123; static let barHeight: CGFloat = 30.0 static let barMinHeight: CGFloat = 20.0 static let barMaxHeight: CGFloat = 40.0 static let marginSize: CGFloat = 20.0 static let pieChartWidthPercentage: CGFloat = 1.0 / 3.0 static let pieChartBorderWidth: CGFloat = 1.0 static let pieChartMinRadius: CGFloat = 30.0 static let pieChartGradientAngle: CGFloat = 90.0 static let barChartCornerRadius: CGFloat = 4.0 static let barChartLegendSquareSize: CGFloat = 8.0 static let legendTextMargin: CGFloat = 5.0&#125;// 2@IBInspectable var barHeight: CGFloat = Constants.barHeight &#123; didSet &#123; barHeight = max(min(barHeight, Constants.barMaxHeight), Constants.barMinHeight) &#125;&#125;@IBInspectable var pieChartUsedLineColor: NSColor = NSColor.pieChartUsedStrokeColor@IBInspectable var pieChartAvailableLineColor: NSColor = NSColor.pieChartAvailableStrokeColor@IBInspectable var pieChartAvailableFillColor: NSColor = NSColor.pieChartAvailableFillColor@IBInspectable var pieChartGradientStartColor: NSColor = NSColor.pieChartGradientStartColor@IBInspectable var pieChartGradientEndColor: NSColor = NSColor.pieChartGradientEndColor@IBInspectable var barChartAvailableLineColor: NSColor = NSColor.availableStrokeColor@IBInspectable var barChartAvailableFillColor: NSColor = NSColor.availableFillColor@IBInspectable var barChartAppsLineColor: NSColor = NSColor.appsStrokeColor@IBInspectable var barChartAppsFillColor: NSColor = NSColor.appsFillColor@IBInspectable var barChartMoviesLineColor: NSColor = NSColor.moviesStrokeColor@IBInspectable var barChartMoviesFillColor: NSColor = NSColor.moviesFillColor@IBInspectable var barChartPhotosLineColor: NSColor = NSColor.photosStrokeColor@IBInspectable var barChartPhotosFillColor: NSColor = NSColor.photosFillColor@IBInspectable var barChartAudioLineColor: NSColor = NSColor.audioStrokeColor@IBInspectable var barChartAudioFillColor: NSColor = NSColor.audioFillColor@IBInspectable var barChartOthersLineColor: NSColor = NSColor.othersStrokeColor@IBInspectable var barChartOthersFillColor: NSColor = NSColor.othersFillColor// 3func colorsForFileType(fileType: FileType) -&gt; (strokeColor: NSColor, fillColor: NSColor) &#123; switch fileType &#123; case .audio(_, _): return (strokeColor: barChartAudioLineColor, fillColor: barChartAudioFillColor) case .movies(_, _): return (strokeColor: barChartMoviesLineColor, fillColor: barChartMoviesFillColor) case .photos(_, _): return (strokeColor: barChartPhotosLineColor, fillColor: barChartPhotosFillColor) case .apps(_, _): return (strokeColor: barChartAppsLineColor, fillColor: barChartAppsFillColor) case .other(_, _): return (strokeColor: barChartOthersLineColor, fillColor: barChartOthersFillColor) &#125;&#125; 这一大坨代码的作用是： 声明了带有许多常量的结构体 —— 你得在这个 app 的各个地方用到它们； 用 @IBInspectable 修饰所有可配置的属性。并使用 NSColor+DiskInfo.swift 中的值为它们赋值。注意：要使一个属性「inspectable」（可以在 Interface Builder 里直接编辑），你必须声明它的类型，即使大多数情况下 Swift 会帮你做这件事儿； 定义一个 Helper 方法，为不同的文件类型返回它的笔触颜色和填充颜色。你在绘制「什么文件占了多大地儿」的图表的时候会用到它。 打开 Main.stroyboard，你应该能注意到 Graph View 已经从默认的灰色变成了白色，这意味着实时渲染预览已经起作用了。 选中 Graph View，打开属性检查器，你会发现所有的「inspectable」属性已经出现在这里了。 现在开始，要查看调整好的效果，你可以直接编译和运行，也可以直接在 Interface Builder 里查看。 万事俱备，是时候开始真正的绘制啦！ Graphics Context（图形上下文）在使用 Core Graphics 的时候，你并不是直接在视图中绘画，而是使用一个叫 Graphics Context（图形上下文）的东西，它是系统渲染图形与把图形显示在视图中的中间层。 Core Graphics 使用一个叫「Painter’s Model（画家模式）」的模式，你可以想像成自己拿着笔，唰唰地在画布上绘图样子。你需要放置一个路径，然后去填充它，你没办法去改变已经布置好的像素们，但你可以在它们之上继续画图。 这个「上下文」非常重要，因为他决定了你最终得到的效果。 绘制路径要使用 Core Graphics 绘制一个路径，你需要定义一个 Path（路径），也就是 CGPathRef 和可变的 CGMutablePathRef。 路径准备好以后，把它添加到图形上下文里，就可以根据路径和绘制属性渲染出你要的图形了。 为饼图…绘制一个路径条形图的基本元素是圆角矩形，所以我们从这里开始入手。 打开 GraphView.swift，把这个扩展添加在文件底部类定义以外的地方： 123456789101112131415161718192021222324252627282930// MARK: - 用于绘制的 extensionextension GraphView &#123; func drawRoundedRect(rect: CGRect, inContext context: CGContext?, radius: CGFloat, borderColor: CGColor, fillColor: CGColor) &#123; // 1 let path = CGMutablePath() // 2 path.move( to: CGPoint(x: rect.midX, y:rect.minY )) path.addArc( tangent1End: CGPoint(x: rect.maxX, y: rect.minY ), tangent2End: CGPoint(x: rect.maxX, y: rect.maxY), radius: radius) path.addArc( tangent1End: CGPoint(x: rect.maxX, y: rect.maxY ), tangent2End: CGPoint(x: rect.minX, y: rect.maxY), radius: radius) path.addArc( tangent1End: CGPoint(x: rect.minX, y: rect.maxY ), tangent2End: CGPoint(x: rect.minX, y: rect.minY), radius: radius) path.addArc( tangent1End: CGPoint(x: rect.minX, y: rect.minY ), tangent2End: CGPoint(x: rect.maxX, y: rect.minY), radius: radius) path.closeSubpath() // 3 context?.setLineWidth(1.0) context?.setFillColor(fillColor) context?.setStrokeColor(borderColor) // 4 context?.addPath(path) context?.drawPath(using: .fillStroke) &#125;&#125; 太长不看🙄️：以上就是绘制一个圆角矩形的方法，用人类能理解的语言解释一遍就是： 创建一个可以改变的路径； 一步一步勾勒出一个圆角矩形： 移动到矩形底边的中点，这里将是我们的起点； 使用 addArc(tangent1End:tangent2End:radius) 方法绘制右下角的线段，这个方法会绘制出底部的水平线以及右下角的圆角； 添加右边的线段和右上角的圆角； 添加顶部的线段和左上角的圆角； 添加左边的线段和左下角的圆角； 闭合路径，也就是从上一步的重点连接到起点； 设置绘制属性：线宽、填充颜色和边框颜色； 把路径添加到图形上下文，并使用 .fillStroke 参数绘制着个路径，这个参数将会告诉 Core Graphics 这条路径需要填充颜色并绘制边框。 计算位置使用 Core Graphics 进行绘制的过程其实就是计算各个视觉元素在视图中位置的过程。所以我们需要关心的就是把不同的元素放置在哪，以及当视图的大小发生变化时它们该如何应对。 我们准备这样布局我们的视图： 打开 GraphView.swift 并添加这个扩展： 12345678910111213141516171819202122232425262728293031// MARK: - 用于计算的 extensionextension GraphView &#123; // 1 func pieChartRectangle() -&gt; CGRect &#123; let width = bounds.size.width * Constants.pieChartWidthPercentage - 2 * Constants.marginSize let height = bounds.size.height - 2 * Constants.marginSize let diameter = max(min(width, height), Constants.pieChartMinRadius) let rect = CGRect(x: Constants.marginSize, y: bounds.midY - diameter / 2.0, width: diameter, height: diameter) return rect &#125; // 2 func barChartRectangle() -&gt; CGRect &#123; let pieChartRect = pieChartRectangle() let width = bounds.size.width - pieChartRect.maxX - 2 * Constants.marginSize let rect = CGRect(x: pieChartRect.maxX + Constants.marginSize, y: pieChartRect.midY + Constants.marginSize, width: width, height: barHeight) return rect &#125; // 3 func barChartLegendRectangle() -&gt; CGRect &#123; let barchartRect = barChartRectangle() let rect = barchartRect.offsetBy(dx: 0.0, dy: -(barchartRect.size.height + Constants.marginSize)) return rect &#125;&#125; 以上代码做了这些必要的计算： 从计算饼图的位置开始入手，它将会垂直居中，并占据视图 1/3 的宽度； 计算条形图的位置，它将会占据 2/3 的宽度，并处于视图中部偏上的位置； 根据饼图的最小 Y 值和边距来计算图例的位置。 现在我们来把把它绘制到你的视图中去，在 GraphView 的用于绘制的扩展中加入： 1234567func drawBarGraphInContext(context: CGContext?) &#123; let barChartRect = barChartRectangle() drawRoundedRect(rect: barChartRect, inContext: context, radius: Constants.barChartCornerRadius, borderColor: barChartAvailableLineColor.cgColor, fillColor: barChartAvailableFillColor.cgColor)&#125; 你需要一个 Helper 方法来绘制条形图，它会绘制一个圆角矩形，并使用画笔颜色和填充颜色在空白处绘制图形，你可以在 NSColor+DiskInfo 扩展中找到这个些颜色。 把 draw(_:) 方法里的所有代码替换成： 1234super.draw(dirtyRect) let context = NSGraphicsContext.current()?.cgContextdrawBarGraphInContext(context: context) 这段代码会真正地把图形绘制到视图中去。首先，通过调用 NSGraphicsContext.current()，我们获取到了当前视图的图形上下文，然后我们调用刚刚编写的方法绘制出了条形图。 编译并运行，你可以看到条形图已经就位了： 现在，打开 Main.storyboard 并选中 View Controller Scene， 你会看到这个： Interface Builder 为你实时渲染了预览。你可以试着去修改一下颜色，它也会实时响应你的修改，是不是很棒棒呀😄～ 剪切一部分区域（也就是蒙版）现在我们来制作文件分布图，也就是这个家伙： 先暂停一下下，我们来理理思路。显而易见的是，每种文件都有自己的专属颜色，我们的 app 只需要根据这种文件占硬盘空间大小的百分比来计算每个方块的宽度，然后用对应的颜色把它绘制出来。 你需要绘制一个不规则的图形，比如一个!@#¥%%。然而，我们可以通过一个叫 clipping areas（蒙板） 的技术来避免编写重复代码。 👆这一段的第一句实在没看懂，求指正：You could create a special shape, such as a filled rectangle with two lines at bottom and top of the rectangle。 你可以把蒙版想象成「在一张纸上剪了个窟窿」，你只能透过这个窟窿看到部分的图形。这个「窟窿」就叫做「Clipping Mask（剪切蒙版）」，你需要在 Core Graphics 里定义它。 在这个条形图的例子里，你需要为每种文件分类创建一个完整的圆角矩形，然后通过剪切蒙版来使它们只显示正确的部分： 理论说完了，我们来动手吧～ 开支绘制之前，你需要为选中的硬盘设置 fileDistribution。打开 Main.storyboard，我们来创建一个 Outlet 连接。 在项目导航器里按住 Option⌥ 键的同时点击 ViewController.swift，使它显示在右半边的协助编辑器里，然后按住 Control⌃ 键的同时把 Graph View 拖动到 View Controller 的代码里。 在弹出的小气泡里，把这个 Outlet 命名为 graphView，并点击 Connect。 打开 ViewController.swift 并把这行代码添加到 showVolumeInfo(_:) 的末尾： 1graphView.fileDistribution = volume.fileDistribution 这行代码设置了 fileDistribution 的值，从而让 Graph View 能获取各类文件占的百分比。 打开 GraphView.swift，把这些代码添加到 drawBarGraphInContext(context:) 的末尾来绘制条形图： 12345678910111213141516171819202122232425// 1if let fileTypes = fileDistribution?.distribution, let capacity = fileDistribution?.capacity, capacity &gt; 0 &#123; var clipRect = barChartRect // 2 for (index, fileType) in fileTypes.enumerated() &#123; // 3 let fileTypeInfo = fileType.fileTypeInfo let clipWidth = floor(barChartRect.width * CGFloat(fileTypeInfo.percent)) clipRect.size.width = clipWidth // 4 context?.saveGState() context?.clip(to: clipRect) let fileTypeColors = colorsForFileType(fileType: fileType) drawRoundedRect(rect: barChartRect, inContext: context, radius: Constants.barChartCornerRadius, borderColor: fileTypeColors.strokeColor.cgColor, fillColor: fileTypeColors.fillColor.cgColor) context?.restoreGState() // 5 clipRect.origin.x = clipRect.maxX &#125;&#125; 这些代码做了这些事儿： 先确保了 Graph View 拥有一个有效的 fileDistribution； 遍历 fileDistribution 里的每一种文件类型； 根据文件的占比计算蒙版的大小； 存储图形上下文的状态，设置蒙版的大小，用文件类型对应的颜色绘制圆角矩形，并恢复图形上下文的状态； 把剪切蒙版的 x 移动到正确的位置。 你可能会奇怪：为什么要先存储，再恢复图形上下文？还记得「painter’s model」吗？你添加到图形上下文里的所有东西都会被保存在上下文中，就像你画在纸上的画，会一直在那里。 如果你添加了多个剪切蒙版，事实上你是只创建了一个剪切蒙版，并应用到所有矩形上。要避免这种情况，你需要在添加新的剪切蒙版之前存储上下文的状态，等你使用完了这个蒙版，再把它恢复出来，再处理新的蒙版。 此时，Xcode 会弹出一个警告，因为 index 从没被使用过。别担心，它的待会儿就会派上用场。 编译并运行，或者直接打开 Main.storyboard： 哈哈，DiskInfo 功能似乎已经渐渐完善了呢～除了图例，这个条形图已经基本完工了👍。 绘制文本在自定义视图里绘制文本特别简单，你需要为这个文本的各种属性创建一个字典，包含了字体、尺寸、颜色和对齐，把它传入 String 的 draw(in:withAttributes:) 方法。这些属性将会在我们计算矩形大小和位置的时候派上用场。 打开 GraphView.swift，把这个属性添加到类的定义里： 1fileprivate var bytesFormatter = ByteCountFormatter() 这将会创建一个 ByteCountFormatter。它会帮我们完成「把字节转化成人话」这个高深而繁重的工作。 现在，在 drawBarGraphInContext(context:) 方法的 for (index,fileType) in fileTypes.enumerated() 循环里加入这些代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1let legendRectWidth = (barChartRect.size.width / CGFloat(fileTypes.count))let legendOriginX = barChartRect.origin.x + floor(CGFloat(index) * legendRectWidth)let legendOriginY = barChartRect.minY - 2 * Constants.marginSizelet legendSquareRect = CGRect(x: legendOriginX, y: legendOriginY, width: Constants.barChartLegendSquareSize, height: Constants.barChartLegendSquareSize)let legendSquarePath = CGMutablePath()legendSquarePath.addRect( legendSquareRect )context?.addPath(legendSquarePath)context?.setFillColor(fileTypeColors.fillColor.cgColor)context?.setStrokeColor(fileTypeColors.strokeColor.cgColor)context?.drawPath(using: .fillStroke)// 2let paragraphStyle = NSMutableParagraphStyle()paragraphStyle.lineBreakMode = .byTruncatingTailparagraphStyle.alignment = .leftlet nameTextAttributes = [ NSFontAttributeName: NSFont.barChartLegendNameFont, NSParagraphStyleAttributeName: paragraphStyle]// 3let nameTextSize = fileType.name.size(withAttributes: nameTextAttributes)let legendTextOriginX = legendSquareRect.maxX + Constants.legendTextMarginlet legendTextOriginY = legendOriginY - 2 * Constants.pieChartBorderWidthlet legendNameRect = CGRect(x: legendTextOriginX, y: legendTextOriginY, width: legendRectWidth - legendSquareRect.size.width - 2 * Constants.legendTextMargin, height: nameTextSize.height)// 4fileType.name.draw(in: legendNameRect, withAttributes: nameTextAttributes)// 5let bytesText = bytesFormatter.string(fromByteCount: fileTypeInfo.bytes)let bytesTextAttributes = [ NSFontAttributeName: NSFont.barChartLegendSizeTextFont, NSParagraphStyleAttributeName: paragraphStyle, NSForegroundColorAttributeName: NSColor.secondaryLabelColor]let bytesTextSize = bytesText.size(withAttributes: bytesTextAttributes)let bytesTextRect = legendNameRect.offsetBy(dx: 0.0, dy: -bytesTextSize.height)bytesText.draw(in: bytesTextRect, withAttributes: bytesTextAttributes) 看起来这一大堆代码还挺唬人的，其实很简单： 你已经很熟悉这一段代码了：计算图例的彩色方块的位置，为它创建一条路径，并用对应的颜色填充； 创建一个字典，包含了两个属性：字体和 NSMutableParagraphStyle。后者会定义这些文本会怎样在给定的矩形里被绘制出来。在这个例子中，文本会显示为左对齐，且若文本超出了矩形范围，系统会在他的末尾加上省略号； 计算用于绘制文本的矩形的位置和大小； 调用 draw(in:withAttributes:)，绘制文本； 使用 bytesFormatter 获取文本，并设置「文件大小」的文本的属性。这和之前唯一的区别是：这个文本用 NSFontAttributeName 设置了一个不同的颜色。 编译并运行，或者前往 Main.storyboard。 热烈祝贺条形图杀青成功！你现在可以调整一下窗口的大小，看看图例里的文本时如何给自己加上省略号来适应狭小的空间的。 给自己鼓个掌吧👏～ Cocoa DrawingmacOS 还提供了使用 AppKit 的框架来进行绘制的选项。它将会提供更高层的抽象绘图法。它使用各种类来代替 C 语言的函数，它还包含了许多 Helper 方法来更轻松地应对常见绘图任务。在两个框架中，图形上下文是一样的。如果你对 Core Graphics 很熟悉的话，你应该能很轻松地掌握 Cocoa Drawing。 和 Core Graphics 一样，你需要创建并绘制路径，但在 Cocoa Drawing，我们使用 NSBezierPath，它和 CGPathRef 是一样的。 我们要绘制的饼图是这样的： 你需要分三步来绘制它： 创建一条圆形的路径，用于显示总硬盘空间，然后用定义好的颜色绘制它； 为已用空间创建一条路径，并绘制它； 为已用空间的路径绘制一个渐变填充。 打开 GraphView.swift，把这个方法添加到用于绘制的 extension 里： 123456789101112131415161718192021222324252627282930func drawPieChart() &#123; guard let fileDistribution = fileDistribution else &#123; return &#125; // 1 let rect = pieChartRectangle() let circle = NSBezierPath(ovalIn: rect) pieChartAvailableFillColor.setFill() pieChartAvailableLineColor.setStroke() circle.stroke() circle.fill() // 2 let path = NSBezierPath() let center = CGPoint(x: rect.midX, y: rect.midY) let usedPercent = Double(fileDistribution.capacity - fileDistribution.available) / Double(fileDistribution.capacity) let endAngle = CGFloat(360 * usedPercent) let radius = rect.size.width / 2.0 path.move(to: center) path.line(to: CGPoint(x: rect.maxX, y: center.y)) path.appendArc(withCenter: center, radius: radius, startAngle: 0, endAngle: endAngle) path.close() // 3 pieChartUsedLineColor.setStroke() path.stroke()&#125; 我们来分析一下这段代码： 用 init(ovalIn:) 构造方法创建一条圆形的路径，设置它的填充颜色和笔触颜色，然后绘制这条路径； 为已用空间创建一条路径： 根据已用空间计算扇形的角度； 移动到大圆的圆心； 添加一条从圆心到圆的右顶点的线段； 根据之前计算的角度添加一条圆弧； 闭合图形，也就是从圆弧的终点连接到圆心； 调用 stroke() 方法，设置笔触颜色； 你应该能发现这段代码和之前的区别： 代码中没有提到过图形上下文，因为我们调用的方法会自动获取当前的上下文，在这个例子中，就是视图自己的图形上下文； 角是以角度制计算，而不是弧度制。CGFloat+Radians.swift 扩展了 CGFloat 类来进行了自动转换。 现在把这行代码添加到 draw(_:) 方法中来绘制饼图： 1drawPieChart() 编译并运行： 进展不错！ 绘制渐变Cocoa Drawing 使用 NSGradient 来绘制渐变。 你需要在已使用的扇形里绘制渐变，该怎么实现呢……🤔？ 没错，用剪切蒙版啊！ 你已经创建了一条路径来绘制已用空间的扇形，在我们绘制渐变之前，先来把它用作剪切蒙版。 把这些代码添加到 drawPieChart() 方法中： 1234if let gradient = NSGradient(starting: pieChartGradientStartColor, ending: pieChartGradientEndColor) &#123; gradient.draw(in: path, angle: Constants.pieChartGradientAngle)&#125; 第一行代码会试着去创建一个两种颜色构成的渐变。如果创建成功了，就会调用 draw(in:angle:) 方法来绘制它。在大括号里，这个方法会设置蒙版，并在蒙版区域内绘制渐变。是不是特别棒～ 编译并运行： 练习/挑战：绘制饼图的图例现在我们的自定义视图已经越来越完美了，但还有一个待办事项：绘制饼图的图例，也就是其内部的文字说明。 你已经知道该怎么去做了，准备好接受挑战了嘛💪？ 一些小提示： 使用 bytesFormatter 来获取硬盘的可用空间（fileDistribution.available 属性）和总空间（fileDistribution.capacity 属性）； 计算文本的位置，确保你的文本显示在各个扇形的中央； 在计算好的位置用以下属性绘制文本： Font：NSFont.pieChartLegendFont； Used space text color：NSColor.pieChartUsedSpaceTextColor； Available space text color：NSColor.pieChartAvailableSpaceTextColor。 答案：绘制图例把这些代码添加到 drawPieChart() 方法中： 123456789101112131415161718192021222324252627282930// 1let usedMidAngle = endAngle / 2.0let availableMidAngle = (360.0 - endAngle) / 2.0let halfRadius = radius / 2.0// 2let usedSpaceText = bytesFormatter.string(fromByteCount: fileDistribution.capacity)let usedSpaceTextAttributes = [ NSFontAttributeName: NSFont.pieChartLegendFont, NSForegroundColorAttributeName: NSColor.pieChartUsedSpaceTextColor]let usedSpaceTextSize = usedSpaceText.size(withAttributes: usedSpaceTextAttributes)let xPos = rect.midX + CGFloat(cos(usedMidAngle.radians)) * halfRadius - (usedSpaceTextSize.width / 2.0)let yPos = rect.midY + CGFloat(sin(usedMidAngle.radians)) * halfRadius - (usedSpaceTextSize.height / 2.0)usedSpaceText.draw(at: CGPoint(x: xPos, y: yPos), withAttributes: usedSpaceTextAttributes)// 3let availableSpaceText = bytesFormatter.string(fromByteCount: fileDistribution.available)let availableSpaceTextAttributes = [ NSFontAttributeName: NSFont.pieChartLegendFont, NSForegroundColorAttributeName: NSColor.pieChartAvailableSpaceTextColor]let availableSpaceTextSize = availableSpaceText.size(withAttributes: availableSpaceTextAttributes)let availableXPos = rect.midX + cos(-availableMidAngle.radians) * halfRadius - (availableSpaceTextSize.width / 2.0)let availableYPos = rect.midY + sin(-availableMidAngle.radians) * halfRadius - (availableSpaceTextSize.height / 2.0)availableSpaceText.draw(at: CGPoint(x: availableXPos, y: availableYPos), withAttributes: availableSpaceTextAttributes) 代码含义： 计算两个区域的角度； 创建已用空间的文本的属性，并计算其 x 和 y，然后绘制它； 创建总空间的文本的属性，并计算其 x 和 y，然后绘制它； 现在，编译并运行你的 app，好好欣赏一下你的杰出作品： 恭喜你！你使用 Core Graphics 和 Cocoa Drawing 创建了一个美丽的 app！ 接下来该做啥？你可以点击这里下载完整的工程文件。 这个 macOS Core Graphics 教程覆盖了 macOS 中用于绘制自定义视图的不同框架的基本知识： 如何使用 Core Graphics 和 Cocoa Drawing 创建和绘制路径； 如何剪切一个区域； 如何绘制文本串； 如何绘制渐变。 之后的日子里，当你需要创建一些整洁、优美的用户界面的时候，你应该能自信地拿出 Core Graphics 和 Cocoa Drawing 挥洒创意了。 如果你还想继续深入，可以参考这些资源： Apple 的 Introduction to Cocoa Drawing Guide Apple 的 Quartz 2D Programming Guide","tags":[{"name":"翻译","slug":"翻译","permalink":"https://sr2k.top/blog/tags/翻译/"},{"name":"Ray Wenderlich","slug":"Ray-Wenderlich","permalink":"https://sr2k.top/blog/tags/Ray-Wenderlich/"},{"name":"macOS","slug":"macOS","permalink":"https://sr2k.top/blog/tags/macOS/"},{"name":"Swift","slug":"Swift","permalink":"https://sr2k.top/blog/tags/Swift/"}]},{"title":"【译】NSCollectionView 入门教程","date":"2017-09-24T14:34:11.000Z","path":"2017/09/24/译-NSCollectionView入门教程/","text":"本文翻译自 raywenderlich.com 的 NSCollectionView Tutorial，已咨询对方网站，可至多翻译 10 篇文章。希望各位有英语阅读能力的话，还是先打赏然后去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。综上，此翻译版本仅供参考，谢绝转载。 更新信息： 此 NSCollectionView 教程已由 Gabriel Miro 更新至 Xcode 8 和 Swift 3. Collection View 是现实一系列相同类型数据的最佳方式。Mac 中自带的 Finder 和 Photos 就是使用了它：通过一个 Collection View 来展示所有的文件和图片。 NSCollectionView 最早在 OS X 10.5 被推出，它可以非常方便地布局一组具有相同大小的 item，并把它们展示在一个可以滑动的 Scroll View 中。 在 OS X 10.11 El Capitan 中，参照 iOS 上的 UICollectionView，NSCollectionView 被全面进行了升级。 macOS 10.12 Sierra 则给予了它「收起分区」（就像 Finder 里那样）和「固定标题」两项新功能，使得它和 iOS 的差距进一步减小了。 在这个 NSCollectionView 的入门教程中，你将会创造一个叫 SlideMagic 的 app，它是一个只属于你的网格状的图片浏览 app。 这个教程假定你已经基本了解过了 macOS app 的开发，如果你还不曾了解过，raywenderlich.com 上提供了很多很棒的 macOS 开发教程，你可以先去看看那些。 当然还有我自己翻的《零基础 macOS 应用开发教程》系列 准备开始你将会编写的 SlidesMagic app 是一个简单的图片浏览器，它很酷，但是，可别因为它太酷了而一不小心在把玩的时候把自己 Mac 上的照片删了哦😛～ 这个 app 会从获取一个文件夹里的所有图片，然后用一个极其优雅的 Collection View 来把它们显示出来。完成了的 app 长这样： 下载这个项目的起步代码，编译并运行: 此时，这个 app 看起来只是一个空荡荡的窗口，但这些起步代码包含了一些「隐藏功能」，这是后面使它成为一个图片浏览器的基础。 SlidesMagic 启动的时候，会自动加载系统中 Desktop Pictures 目录下的所有图片，在 Xcode 的控制台输出中，我们可以看到这些文件的名字。 控制台中输出的列表表明，起步代码中 Model 的加载逻辑代码已经可以正常工作了，你可以在这个 app 的 File → Open Another Folder… 菜单中打开另一个目录。 起步代码起步代码提供了一些与 Collection Views 无直接关联的代码。 Model ImageFile.swift: 用于描述一个图片文件 ImageDirectoryLoader.swift: 用来把图片从硬盘中加载出来的 Helper 类 Controller这个 app 拥有两个主要的 Controller： WindowController.swift： windowDidLoad()：在左半边的屏幕上设置主窗口的大小； openAnotherFolder(_:)：提供一个标准的「打开」对话框来供用户选择文件夹； ViewController.swift： viewDidLoad() 打开 Desktop Pictures 目录作为默认目录。 Collection View 幕后探秘NSCollectionView 是今天的主角，它将会在几个关键的组成部分的帮助下，显示许多 item。 布局NSCollectionViewLayout：明确了 Collection View 的布局方式，它是一个抽象的类，所有用来表示 CollectionView 布局的实类都继承自它。 NSCollectionViewFlowLayout：提供了一个灵活的网格状的布局。对于绝大多数 app，这种布局方式都适用。 NSCollectionViewGridLayout：为了兼容 OS X 10.11 和以前的版本所保留的布局方式，对于新创建的 app 不推荐使用。 Section 和 IndexPath：前者允许你把 item 分成若干个 section（分区），每个 section 包含了一组有序的 item。每个 item 都和一个索引相关联，这个索引是一个由一对整数（section，item）构成的 IndexPath 实例。默认情况下，当你不需要给 item 分区时，这个 Collection View 仍然会拥有一个 section。 Collection View Item就像其他许多 Cocoa 框架一样，Collection View 中的 item 也遵守着 MVC 设计模式。 Model 和 View：这个 item 的内容来自 Model 的数据对象。每个单独的对象都通过在 Collection View 中创建自己的 View 来把自己显示出来。这些 View 的结构由一个单独的 nib 文件（文件扩展名是 .xib）来定义。 Controller：上面提到的 nib 文件是一个由 NSCollectionViewItem 管理的 NSViewController 的子类。它负责与 Model 对象进行通信并控制 Collection View 的显示。通常情况下，你会编写一个 NSCollectionViewItem 的子类。当你需要不同类型的 item 的时候，你需要为每个分支定义一个不同的子类，并创建一个 nib。 额外的 View要在 Collection View 中显示不同于普通 item 额外的信息，你需要额外的 item。 最直观的例子就是分区的标题和脚注。 Collection View 的数据源和代理（Data Source and Delegates） NSCollectionViewDataSource：用 item 和额外的 item 来填充 Collection View。 NSCollectionViewDelegate：处理拖放相关的事件，以及选中状态和高亮。 NSCollectionViewDelegateFlowLayout：允许你自定义你的网格视图。 注意：填充一个 Collection View 的方法有二：数据源和 Cocoa 绑定。这个教程将会使用数据源。 创建 Collection View打开 Main.storyboard。前往控件库，向 View Controller Scene 中拖动一个 Collection View。 注意：你或许注意到了，Interface Builder 为我们添加了三个 View，而不是一个。这是因为 Collection View 是嵌入在一个 Scroll View 中的，而后者又自带一个 Clip View 子视图。这仨视图各不相同，因此当本教程需要你选择 Collection View 的时候，切记不要错选了 Scroll View 或 Clip View。 调整 Bordered Scroll View 的大小，使它填满它的父视图的所有空间。然后选择 Xcode 菜单栏上的 Editor → Resolve Auto Layout Issues → Add Missing Constraints 来添加 Auto Layout 约束条件。 你需要在 ViewController 中添加一个 Outlet 来访问界面上的 Collection View。打开 ViewController.swift，在 ViewController 类的定义中添加以下代码： 1@IBOutlet weak var collectionView: NSCollectionView! 打开 Main.storyboard，并选择 View Controller Scene 中的 View Controller。 打开连接检查器，在 Outlets 部分中找到 collectionView，拖动它旁边的小圆圈到画布中的 Collection View 上。 调整 Collection View 的布局你现在有两种选择：在 Interface Builder 中设置好主要的布局属性，或者在代码中手动编写。 在 SlidesMagic 这个项目中，我们选择手动编写代码。 打开 ViewController.swift，把这些方法添加到 ViewController 中： 12345678910111213fileprivate func configureCollectionView() &#123; // 1 let flowLayout = NSCollectionViewFlowLayout() flowLayout.itemSize = NSSize(width: 160.0, height: 140.0) flowLayout.sectionInset = EdgeInsets(top: 10.0, left: 20.0, bottom: 10.0, right: 20.0) flowLayout.minimumInteritemSpacing = 20.0 flowLayout.minimumLineSpacing = 20.0 collectionView.collectionViewLayout = flowLayout // 2 view.wantsLayer = true // 3 collectionView.layer?.backgroundColor = NSColor.black.cgColor&#125; 这些代码的作用是： 创建一个 NSCollectionViewFlowLayout，配置它的基本属性，并设置 NSCollectionView 的 collectionViewLayout； 一般情况下，NSCollectionView 是基于层的，所以你需要把它的父视图的 wantsLayer 设置为 true； 把 Collection View 的背景颜色设置为黑色。 你需要在试图加载完成时调用这个方法，所以在 viewDidLoad() 方法的最后插入： 1configureCollectionView() 编译并运行： 此时，你的 Collection View 已经拥有了一个黑色的背景，并配置好了布局。 创建一个 Collection View Item先在你需要创建一个 NSCollectionViewItem 的子类并把 Model 里的数据们显示出来。 点击 Xcode 菜单栏上的 File → New → File…，选择 macOS → Source → Cocoa Class 并点击 Next。 把 Class 填写 CollectionViewItem，Subclass of 填写 NSCollectionViewItem，并勾选 Also create XIB for user interface。 点击 Next，然后在对话框中的 Group 中选择 Controllers，并点击 Create。 打开 CollectionViewItem.swift，把里边的内容全部替换为： 123456789101112131415161718192021222324import Cocoaclass CollectionViewItem: NSCollectionViewItem &#123; // 1 var imageFile: ImageFile? &#123; didSet &#123; guard isViewLoaded else &#123; return &#125; if let imageFile = imageFile &#123; imageView?.image = imageFile.thumbnail textField?.stringValue = imageFile.fileName &#125; else &#123; imageView?.image = nil textField?.stringValue = \"\" &#125; &#125; &#125; // 2 override func viewDidLoad() &#123; super.viewDidLoad() view.wantsLayer = true view.layer?.backgroundColor = NSColor.lightGray.cgColor &#125;&#125; 这些代码的功能是： 定义了 imageFile 属性，用来访问需要展示的 Model 对象。当你为 imageFile 属性赋值时，它的 didSet 属性观察器会设置这个 item 的 Image 和 Label； 改变此 item 的 View 的背景颜色。 向 View 中添加 Control你在 CollectionViewItem.swift 时勾选了「Also create a XIB（同时创建一个 XIB）」，为了更清楚地整理文件，把 CollectionViewItem.xib 拖动到 Main.storyboard 下方的 Resources 分组中。 Nib 文件中的 View 就是每个 item 所显示出来的根视图，你需要添加一个 Image View 来显示图片，以及一个 Label 来显示文件名。 打开 CollectionViewItem.xib，添加一个 NSImageView： 从控件库中拖动一个 Image View 到画布上的 View 中； 在 Auto Layout 工具栏中点击 Pin 按钮来设置它的约束条件； 设置它的 top、leading 和 trailing 约束为 0，bottom 为 30。点击 Update Frames: Items of New Constraints 然后点击 Add 4 Constraints。 再来添加一个 Label： 从控件库中拖动一个 Label 到画布上的 Image View 的下方； 在 Auto Layout 工具栏中点击 Pin 按钮，设置它的 top、bottom、leading 和 trailing 约束都为 0。点击 Update Frames: Items of New Constraints 然后点击 Add 4 Constraints。 选中 Label，在属性检查器中设置如下属性： 设置 Alignment 为 center 设置 Text Color 为 white 设置 Line Break 为 Truncate Tail 向 Nib 中添加 CollectionViewItem 并连接 Outlets尽管 Nib 文件的 File’s Owner 现在是 CollectionViewItem，它还只是一个占位符。当 Nib 文件被实例化时，它还会需要一个「真正的」NSCollectionViewItem 的实例。 从控件库中拖动一个 Collection View Item 到文档大纲中，选中它，在 身份检查器中把它的 Class 设置为 CollectionViewItem。 在 xib 中，你需要把 View 的层次关系连接到 CollectionViewItem 的 Outlet 中，在 CollectionViewItem.xib 中： 选中 Collection View Item 并前往 Connections Inspector； 把 view 的 outlet 拖动到文档大纲中的 View 上； 用同样的方法，把 imageView 和 textField 的 outlet 连接到文档大纲中的 Image View 和 Label 中。 填充 Collection View你需要实现 Collection View 的数据源协议，说人话就是： Collection 中有几个分区？ 每个分区分别有多少个 item？ 某个索引路径（Index Path）对应的是哪个 Item？ 打开 ViewController.swift 并在文件的末尾添加这些扩展代码： 1234567891011121314151617181920212223242526extension ViewController : NSCollectionViewDataSource &#123; // 1 func numberOfSections(in collectionView: NSCollectionView) -&gt; Int &#123; return imageDirectoryLoader.numberOfSections &#125; // 2 func collectionView(_ collectionView: NSCollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return imageDirectoryLoader.numberOfItemsInSection(section) &#125; // 3 func collectionView(_ itemForRepresentedObjectAtcollectionView: NSCollectionView, itemForRepresentedObjectAt indexPath: IndexPath) -&gt; NSCollectionViewItem &#123; // 4 let item = collectionView.makeItem(withIdentifier: \"CollectionViewItem\", for: indexPath) guard let collectionViewItem = item as? CollectionViewItem else &#123;return item&#125; // 5 let imageFile = imageDirectoryLoader.imageFileForIndexPath(indexPath) collectionViewItem.imageFile = imageFile return item &#125; &#125; 如果你的 app 不需要用到分区，那么你可以删除这个方法，因为一个分区就够了； 这是两个 NSCollectionViewDataSource 协议必须实现的方法之一，在这个方法中你需要返回某个分区容纳的 item 的数量； 另一个必须实现的方法，这个方法会针对某个 indexPath 返回一个 item； 这个方法会从 nib 中实例化一个 item，这个 item 的名字是 identifier 参数，它会根据所需要的 item 的类型来试图重复使用一个 item，如果没有 item 可供重复使用，它会新建一个 item； 根据 IndexPath 获取 Model 对象，设置 Image 和 Label 的内容。 注意: Collection View 具有一项能力：循环使用已经生成了的 Item，以此来减轻数据源过大时的内存压力。从界面上移出去的 item 就是被重复使用的 item。 设置数据源接下来我发需要定义数据源： 打开 Main.storyboard，选中 Collection View。 打开连接检查器，在 Outlets 部分中找到 dataSource，拖动它旁边的小圆圈到文档大纲里的 View Controller 上。 编译并运行，你的 Collection View 现在应该能显示 Desktop Pictures 目录中的图片了： 哈哈哈，折腾了半天都是值得的✌️～ 故障排除如果你还看不见任何图片，你可能遗漏了一些小细节： 你在连接检查器中正确地设置了所有的连接吗？ 你设置 dataSource 的 Outlet 了吗？ 你在身份检查器中应用正确的自定义类了吗？ 你添加顶层的 NSCollectionViewItem，并把它的类设置为 CollectionViewItem 了吗？ makeItemWithIdentifier 中的 identifier 参数的值和 nib 的名字一样吗？ Model 发生改变时重新加载 Item 们要显示另一个目录中的图片，你可以在 app 的菜单栏上点击 File → Open Another Folder…，然后选择一个存有 JPG 或 PNG 格式的图片的目录。 但时此时窗口中的东西似乎什么变化都没有，还是显示着 Desktop Pictures 目录中的图片。尽管 Xcode 里的控制台中已经打印出了新目录里的文件名称。 你需要调用 Collection View 的 reloadData() 方法来刷新它的 item。 打开 ViewController.swift 并把这些代码添加到 loadDataForNewFolderWithUrl(_:) 方法中： 1collectionView.reloadData() 编译并运行，现在你应该能看到窗口中已经能显示正确的照片了。 添加分区SlidesMagic app 现在已经可以做一些很神奇的事儿了，但我们要更进一步 —— 为 Collection View 加入分区。 首先，你需要在主视图的最底部加入一个复选框，来允许你切换是否启用分组。 打开 Main.storyboard，然后在文档大纲中选中 Scroll View 的约束条件，在尺寸检查器中吧它的 Constant 修改为 30. 这会把 Collection View 抬高一些些，腾出地方来放置复选框。 现在，从控件库中拖动一个 Check Box Button到画布中 Collection View 下方的空间里，选中它，在属性检查器中把它的 Title 设置为 Show Sections，然后把 State 设置为 Off。 接下来，点击 Pin 按钮更新它的 Auto Layout 约束条件：Top 设置为 8，Leading 设置为 20。然后点击 Update Frames: Items of New Constraints 和 Add 2 Constraints 编译并运行，现在 app 的底部看起来应该是这样的： 当你点击这个复选框的时候，你的 app 需要改变 Collection View 的外观。 打开 ViewController.swift 在 ViewController 类的最后添加这些代码： 123456789@IBAction func showHideSections(sender: NSButton) &#123; let show = sender.state // 1 imageDirectoryLoader.singleSectionMode = (show == NSOffState) // 2 imageDirectoryLoader.setupDataForUrls(nil) // 3 collectionView.reloadData()&#125; 这些代码会： 根据复选框的状态切换单一分组/多个分组； 根据当前选择的模式来调整 Model，此时传递的 nil 参数表示跳过图像加载 —— 毕竟图片还是那些图片，只是布局发生了改变； Model 发生了改变，所以需要刷新数据。 如果你好奇图片是按照是按照什么规则进行分组的，在 ImageDirectoryLoader 中找到 sectionLengthArray，这个数组里的数字设置了各个分组的里最多可以容纳多少个 item。这个数组是随机生成的，只是用来用作演示。 现在，打开 Main.storyboard。在文档大纲中按住 Control⌃ 键的同时把 Show Sections 拖动到 View Controller 上。在弹出的黑色窗口中点击 showHideSections:。你可以在连接检查器里查看你是否连接成功了。 编译并运行，勾选 Show Sections 来查看布局的变化。 为了更好地区分各个分区，打开 ViewController.swift，编辑 configureCollectionView() 方法里的 sectionInset 属性。 把这一行： 1flowLayout.sectionInset = EdgeInsets(top: 10.0, left: 20.0, bottom: 10.0, right: 20.0) 替换成这个： 1flowLayout.sectionInset = EdgeInsets(top: 30.0, left: 20.0, bottom: 30.0, right: 20.0) 编译并运行，勾选 Show Sections，可以看到各个分区之间已经有了分隔。 添加分区标题另一种区分各个分区边界的方法是为每个分区添加一个标题或脚注。 你需要一个自定义的 NSView 类，并实现相应的数据源方法来为 Collection View 添加一个标题 要创建一个标题，在 Xcode 的菜单栏点击 File → New → File…。选择 macOS → User Interface → View，并点击 Next。 文件名输入 HeaderView.xib，Group 选择 Resources。 点击 Create。 打开 HeaderView.xib 并选中 Custom View。在尺寸检查器中把 Width 设置为 500，Height 设置为 40。 从 Object Library 拖动一个 Label 到 Custom View 的左半边。打开属性检查器，设置它的 Title 为 Section Number，设置 Font Size 为 16。 再拖动一个 Label 到 Custom View 的右半边。设置它的 Title 为 Image Count，设置 Alignment 为 Right。 选中 Section Number Label，点击 Pin 按钮，设置它的 Top 约束为 12，Leading 约束为 20。点击 Update Frames: Items of New Constraints 和 Add 2 Constraints。 接下来，设置 Image Count Label 的 Top 约束为 11，Trailing 约束为 20，别忘了点击 Update Frames: Items of New Constraints 和 Add 2 Constraints。 现在我们的标题应该看起来像这样： 现在我们的标题 UI 已经准备好了，我们还需要为它创建一个子类。 在 Xcode 的菜单栏点击 File → New → File…。选择 macOS → Source → Cocoa Class，并点击 Next。把它的类名设置为 HeaderView，并让它继承自 NSView，点击 Next，并在 Group 中选择 Views。点击 Create。 打开 HeaderView.swift 然后把里边的所有内容替换为： 12345678910// 1@IBOutlet weak var sectionTitle: NSTextField!@IBOutlet weak var imageCount: NSTextField!// 2override func draw(_ dirtyRect: NSRect) &#123; super.draw(dirtyRect) NSColor(calibratedWhite: 0.8 , alpha: 0.8).set() NSRectFillUsingOperation(dirtyRect, NSCompositingOperation.sourceOver)&#125; 这里的代码做了这些事儿： 设置你需要用来连接 nib 元素的 outlet； 绘制一个灰色的背景。 要把 outlet 连接至 Label，打开 HeaderView.xib 并选中 Custom View。在 Identity Inspector 中把 Class 设置为 HeaderView。 在文档大纲视图中，按住 Control⌃ 键的同时点击 Header View。在弹出的黑色窗口中，拖动 imageCount 到 Images Count 上来连接 outlet。 对第二个 Label 进行同样的操作，拖动 sectionTitle 到画布中的 Section Number Label 上。 实现数据源和代理方法你的标题已经完全准备好上战场了，你需要实现 collectionView(_:viewForSupplementaryElementOfKind:at:)，把这个标题视图传递给 Collection View： 打开 ViewController.swift 并把这些方法添加到 NSCollectionViewDataSource extension 中： 123456789func collectionView(_ collectionView: NSCollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -&gt; NSView &#123; // 1 let view = collectionView.makeSupplementaryView(ofKind: NSCollectionElementKindSectionHeader, withIdentifier: \"HeaderView\", for: indexPath) as! HeaderView // 2 view.sectionTitle.stringValue = \"Section \\(indexPath.section)\" let numberOfItemsInSection = imageDirectoryLoader.numberOfItemsInSection(indexPath.section) view.imageCount.stringValue = \"\\(numberOfItemsInSection) image files\" return view&#125; Collection View 会在它需要数据源的时候调用这个方法，并为每个分区设置标题。这个方法做了这些： 调用 makeSupplementaryViewOfKind(_:withIdentifier:for:) 来从 nib 文件实例化一个名字是 withIdentifier 的 HeaderView 对象； 设置各个 Label 的值。 在 ViewController.swift 的最后，添加这个 NSCollectionViewDelegateFlowLayout 扩展： 12345extension ViewController : NSCollectionViewDelegateFlowLayout &#123; func collectionView(_ collectionView: NSCollectionView, layout collectionViewLayout: NSCollectionViewLayout, referenceSizeForHeaderInSection section: Int) -&gt; NSSize &#123; return imageDirectoryLoader.singleSectionMode ? NSZeroSize : NSSize(width: 1000, height: 40) &#125;&#125; 上面这个方法其实是不是必须的，但当你需要设置标题的时候就必须写上了，因为 Flow Layout（流式布局）的代理需要你提供各个分区的标题的大小。 如果没有实现这个方法，你将看不到标题，因为它们的尺寸都是 0。此外，它还会忽略你指定的宽度，而是把标题的宽度设置为 Collection View 的宽度。 在这个例子中，当 Collection View 只有一个分区的时候，这个方法返回的标题尺寸是 0，否则他会返回 40. 对于使用了 NSCollectionViewDelegateFlowLayout 的 Collection View，你需要把 ViewController 连接到 NSCollectionView 的 delegate。 打开 Main.storyboard 并选中 Collection View。打开连接检查器，在 Outlets 部分中找到 delegate。拖动他旁边的小圆点到文档大纲中的 View Controller 上。 编译并运行，勾选 Show Sections，可以看到一个个标题把分区区分开来： 固定标题macOS 10.12 中的 NSCollectionViewFlowLayout 新加入了两个属性：sectionHeadersPinToVisibleBounds 和 sectionFootersPinToVisibleBounds。 当 sectionHeadersPinToVisibleBounds 设置为 true，最上端的分区的标题将会固定在顶端，而不会移出界面以外。当你继续向下滚动时，下一个标题会把它顶走。这种效果一般被称为「sticky headers（固定标题）」或「floating headers（浮动标题）」。 把 sectionFootersPinToVisibleBounds 设置为 true 则会把脚注固定在底部。 打开 ViewController.swift，在 configureCollectionView() 方法的底部加入这个方法： 1flowLayout.sectionHeadersPinToVisibleBounds = true 编译并运行，勾选 Show Sections 并向下滚动一些，你可以看到第一个区域已经有一些图片被移出屏幕了，但标题还是固定在顶部： 注意：如果你的 app 需要支持 OS X 10.11 或更老的版本，你需要通过重写 layoutAttributesForElements(in:) 方法来「手动」实现固定标题。你可以查看[Advanced Collection Views in OS X Tutorial]这篇教程（我正在翻译～）。 Collection View 的选择功能为了显示一个 item 的被选中状态，你需要设置一个白色的边框，没有被选中的项目将不会显示这个边框。 首先，你需要让我们的 Collection View 支持选中。打开 Main.storyboard，选中 Collection View 并在属性检查器里，勾选 Selectable。 勾选 Selectable 开启了选择功能，意味着你可以通过点击一个 item 来选中它。如果你点击另一个 item，将会取消选择之前的那个 item 并选中新的 item。 当你选中一个 item： 它的 IndexPath 会被添加到 NSCollectionView 的 selectionIndexPaths 属性； 它的 isSelected 属性会被设置为 true。 打开 CollectionViewItem.swift。在 viewDidLoad() 方法的最后追加： 1234// 1 view.layer?.borderColor = NSColor.white.cgColor // 2 view.layer?.borderWidth = 0.0 这段代码： 设置了一个白色的边框； 把 borderWidth 设置为 0.0 来确保边框不可见 —— 也就是没被选中。 要在每次 isSelected 被设置时改变 borderWidth，我们需要把这些代码添加到 CollectionViewItem 类中： 12345override var isSelected: Bool &#123; didSet &#123; view.layer?.borderWidth = isSelected ? 5.0 : 0.0 &#125; &#125; 每次 isSelected 发生了改变，didSet 将会根据新的值来设置边框的宽度。 编译并运行。点击一个项目来选中它，你将会看见它周围出现了边框。哈哈哈，神奇✨！ 下一步该做些啥？点击这里下载最终完成了的 SlideMagic。 在这个 NSCollectionView 入门教程中，你了解了如何创建你的第一个 Collection View，了解了错综复杂的数据源 API 和如何处理分区。至此你已经学到了很多，但其实这仅仅是个开始，Collection View 还有很多功能等待你去发掘。这里有很多值得去探索的东西： 通过 Cocoa 的数据绑定构建「免数据源」的 Collection View 不同类型的 Item 追加和移除 Item 自定义布局 拖放手势（Drag and drop） 动画 修改 NSCollectionViewFlowLayout 收起某个分区（macOS 10.12 Sierra 的新功能） 你可以在我们的《NSCollectionView 进阶教程》中了解更多。","tags":[{"name":"翻译","slug":"翻译","permalink":"https://sr2k.top/blog/tags/翻译/"},{"name":"Ray Wenderlich","slug":"Ray-Wenderlich","permalink":"https://sr2k.top/blog/tags/Ray-Wenderlich/"},{"name":"macOS","slug":"macOS","permalink":"https://sr2k.top/blog/tags/macOS/"},{"name":"Swift","slug":"Swift","permalink":"https://sr2k.top/blog/tags/Swift/"}]},{"title":"【译】 零基础 macOS 应用开发（三）","date":"2017-09-22T19:54:25.000Z","path":"2017/09/23/译-零基础macOS应用开发3/","text":"本文翻译自 raywenderlich.com 的 macOS 开发经典入门教程 ，已咨询对方网站，可至多翻译 10 篇文章。希望各位有英语阅读能力的话，还是先打赏然后去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。综上，此翻译版本仅供参考，谢绝转载。 欢迎回到我们的零基础 macOS 应用开发教程的最后一部分（共三部分）！ 在第一部分中，你已经学会了如何安装 Xcode 和如何创建一个示例 app；在第二部分中你为一个更加复杂的 app 创建了 UI，但因为你还没有编写任何代码，所以它还不能工作。在这个部分中，你将会编写所有 Swift 代码并让你的 app 真正活起来！ 开始如果你还没有完成第二部分，或你希望从一个更加纯净的情况继续学习，你可以下载第二部分中已经完成了 UI 布局的工程文件。打开你下载的或你跟着第二部分完成的工程文件，并运行一下它，确认一下是否所有的 UI 都能正确显示，打开偏好设置窗口看看它是否能正常显示。 沙盒机制在你开始编写代码之前，请花一些时间来了解一下 macOS 的沙盒机制。如果你是一个 iOS 开发者，你已经了解了这个概念，如果你不曾了解过，继续往下阅读。 一个沙盒化了的 app 拥有自己独立的存储空间，沙盒会禁止你的 app 访问另一个 app 创建的文件以及其他的许可和限制。对于 iOS app，使用沙盒是必须的，而对于 macOS app，这只是一个可选项；但如果你希望通过 Mac App Store 进行分发和销售，你的 app 必须沙盒化，由于沙盒带来的诸多限制，你的 app 可能会出现一些问题。 要为你的 app 启用沙盒，在 Project Navigator（项目导航器）中选择项目文件，也就是文件列表里最顶上的蓝色图标。在 Targets 列表中选择 EggTimer(其实 Targets 列表里也只有一个项目可以选择)，然后在上方的标签中点击 Capabilities（功能）标签，点击 App Sandbox（应用沙盒）那一栏的开关，这个视图将会展开并显示你的 app 可以申请的许多权限。这个例子中的 app 不需要任何特殊的权限，因此它们都不需要打开。 管理你的文件看一眼你的 Project Navigator（项目导航器），所有的文件都堆在一起，缺乏组织，这个 app 不会有很多文件，但把文件整理的井井有条始终都会是个好习惯，也能帮助我们更快速地定位到你需要的文件，这一点对于大型项目尤其有用。 按住 Shift 的同时分别点击两个 View Controller 文件，把他们同时选中，右键点击并选择 New Group from selection（用所选项目创建新的分组），给新建的分组起名为 View Controllers。 这个项目将会包含一些 Model 文件，所以右键点击 EggTimer 分组，选择 New Group（新建分组），把这个分组命名为 Model**。 最后，选中 Info.plist 和 EggTimer.entitlements，把它们扔掉一个叫 Supporting Files 的文件夹里。 拖动分组和文件调整他们的顺序，直到你的项目看起来像这样： MVC这个 app 将会应用 MVC 模式：Model View Controller（模型 - 视图 - 控制器）。 译者注：请参见 MVC 设计模式的维基百科词条，以及这篇简书文章。以及下文会经常出现的名词，下文就不再翻译啦～Model：模型View：视图Controller：控制器Delegate and Protocol：代理与协议 我们要给 app 创建的第一个 Model 对象名叫 EggTimer。这个类将会拥有一些关于计时器的开始时间、倒计时的时长和以及过去的时间的属性。还有一个叫做 Timer 的对象，每过一秒它都会被激活，并更新自己的状态，并用自己的方法来开始、暂停、恢复或把 EggTimer 归零。 EggTimer Model 类还会保存数据并执行动作，但它不能用来显示数据。Controller（在这个项目中就是 ViewController）则能与 EggTimer（也就是 Model）通信，它拥有一个 View 并用它来显示数据。 为了能和 ViewController 通信，EggTimer 使用一个代理协议（Delegate Protocol），每当某些数据发生改变时，EggTimer 向它的 delegate 发送一条消息，ViewController 则让自己去担任 EggTimer 的这个所谓的 delegate，所以它能接收到这条消息，并把新的数据显示在界面上。 编写 EggTimer 类在项目导航器中选中 Model 分组，并点击 Xcode 菜单栏上的 File → New → File…，选择 macOS → Swift File，并点击 Next，给这个文件起名为 EggTimer.swift 并点击 Create 来创建它。 在这个文件中加入以下代码： 123456class EggTimer &#123; var timer: Timer? = nil var startTime: Date? var duration: TimeInterval = 360 // 默认的计时时间是 6 分钟 var elapsedTime: TimeInterval = 0 &#125; 这样 EggTimer 类和它的属性们就设置好了。TimeInterval 其实就是 Double 类型，但一般我们在表示秒数时都会使用它而不是 Double。 第二件事是在类中添加两个计算属性（Computed Properties），这两个属性是用来决定 EggTimer 属性的捷径。将以下代码写在刚刚添加的属性之后： 1234567var isStopped: Bool &#123; return timer == nil &amp;&amp; elapsedTime == 0 &#125;var isPaused: Bool &#123; return timer == nil &amp;&amp; elapsedTime &gt; 0 &#125; 在 EggTimer.swift 文件 EggTimer 类以外的地方添加代理协议的定义 —— 我更喜欢把代理协议写在文件顶部 import 部分的后边。 1234protocol EggTimerProtocol &#123; func timeRemainingOnTimer(_ timer: EggTimer, timeRemaining: TimeInterval) func timerHasFinished(_ timer: EggTimer) &#125; 你可以理解为：这个协议制定了一份合同，任何宣布遵守 EggTimerProtocol 协议（也就是签订了这份合同）的对象都需要实现这两个方法。 现在你定义了一个协议，EggTimer 可以通过定义一个 delegate（代理）属性来履行这份协议，这个属性的类型可以是任何类型（Any）。EggTimer 并不知道也不关心代理的类型是什么，因为很明显既然这个代理源自 EggTimerProtocol 协议，它拥有这两个方法。 将这些代码属性添加到 EggTimer 类： 1var delegate: EggTimerProtocol? 让 EggTimer 的 timer 对象开始运行会导致一个方法每秒钟被调用一次，继续添加以下代码来定义这个方法，dynamic 关键字是让 Timer 能发现它的关键。 1234567891011121314151617181920dynamic func timerAction() &#123; // 1 guard let startTime = startTime else &#123; return &#125; // 2 elapsedTime = -startTime.timeIntervalSinceNow // 3 let secondsRemaining = (duration - elapsedTime).rounded() // 4 if secondsRemaining &lt;= 0 &#123; resetTimer() delegate?.timerHasFinished(self) &#125; else &#123; delegate?.timeRemainingOnTimer(self, timeRemaining: secondsRemaining) &#125;&#125; …所以这些代码到底是在做些什么？ startTime 是个可选的 Date，当它是 nil 时，timer 将无法运行，所以这时什么都不会发生； 重新计算 elapsedTime 属性，startTime 比当前的时间还要早，所以 timeIntervalSinceNow 会产生一个负值，这个负值会使得 elapsedTime 成为一个正值； 计算 timer 的剩余时间，并进行取整； 如果 timer 已经结束，就把它重设，并告知 delegate 计时结束了；否则，告诉 delegate 计时器还剩多少秒。另外，由于 delegate 是一个可选值，所以需要用 ? 来进行解包，也就是说，如果 delegate 还没有被赋值，除了那些方法不会被调用，没有别的坏事会发生。 你会看到 Xcode 提示我们出现了一些错误，不过当我们完成了 EggTimer 类的代码之后，它们就会消失了，这是因为我们还没有添加用于开始计时、暂停计时、恢复计时和重启计时器的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041// 1 func startTimer() &#123; startTime = Date() elapsedTime = 0 timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(timerAction), userInfo: nil, repeats: true) timerAction() &#125; // 2 func resumeTimer() &#123; startTime = Date(timeIntervalSinceNow: -elapsedTime) timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(timerAction), userInfo: nil, repeats: true) timerAction() &#125; // 3 func stopTimer() &#123; // really just pauses the timer timer?.invalidate() timer = nil timerAction() &#125; // 4 func resetTimer() &#123; // 停止计时器 &amp; 重设所有属性 timer?.invalidate() timer = nil startTime = nil duration = 360 elapsedTime = 0 timerAction() &#125; 这些代码是做什么的？ 通过调用 Date() 方法 startTimer 设置开始时间为当前时间，然后它会设置一个一直重复运行的 Timer； resumeTimer 是计时器已经暂停并需要继续时会被调用的方法，它还会根据已经过去的时间重新设置开始时间； stopTimer 会停止重复运行的 timer； resetTimer 会停止 timer，并把相关属性恢复原始设置。 以上的这些方法都会调用 timerAction，所以一旦它们被调用，界面上显示的内容都会被更新。 ViewController现在 EggTimer 对象已经业已正常运转了，我们该回到 ViewController.swift 中让数据的变化能及时反映到界面上了。 ViewController 已经拥有了 @IBOutlet 属性，但现在你需要让它拥有一个类型为 EggTimer 的属性： 1var eggTimer = EggTimer() 将 viewDidLoad 方法中的注释行替换成这一行： 1eggTimer.delegate = self 写完上面的代码以后会出现一个错误，因为 ViewController 还没有遵从 EggTimerProtocol 协议。当我们要让一个类遵从某个协议时，如果我们单独创建一个 Extension（扩展）来盛放协议需要的方法，你的代码将会看起来整洁许多。在 ViewController 类以外的地方输入以下代码： 12345678910extension ViewController: EggTimerProtocol &#123; func timeRemainingOnTimer(_ timer: EggTimer, timeRemaining: TimeInterval) &#123; updateDisplay(for: timeRemaining) &#125; func timerHasFinished(_ timer: EggTimer) &#123; updateDisplay(for: 0) &#125;&#125; 因此我们还需要为 ViewController 添加另一个 Extension，用来盛放关于屏幕显示的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748extension ViewController &#123; // MARK: - 显示 func updateDisplay(for timeRemaining: TimeInterval) &#123; timeLeftField.stringValue = textToDisplay(for: timeRemaining) eggImageView.image = imageToDisplay(for: timeRemaining) &#125; private func textToDisplay(for timeRemaining: TimeInterval) -&gt; String &#123; if timeRemaining == 0 &#123; return \"Done!\" &#125; let minutesRemaining = floor(timeRemaining / 60) let secondsRemaining = timeRemaining - (minutesRemaining * 60) let secondsDisplay = String(format: \"%02d\", Int(secondsRemaining)) let timeRemainingDisplay = \"\\(Int(minutesRemaining)):\\(secondsDisplay)\" return timeRemainingDisplay&#125;private func imageToDisplay(for timeRemaining: TimeInterval) -&gt; NSImage? &#123; let percentageComplete = 100 - (timeRemaining / 360 * 100) if eggTimer.isStopped &#123; let stoppedImageName = (timeRemaining == 0) ? \"100\" : \"stopped\" return NSImage(named: stoppedImageName) &#125; let imageName: String switch percentageComplete &#123; case 0 ..&lt; 25: imageName = \"0\" case 25 ..&lt; 50: imageName = \"25\" case 50 ..&lt; 75: imageName = \"50\" case 75 ..&lt; 100: imageName = \"75\" default: imageName = \"100\" &#125; return NSImage(named: imageName) &#125;&#125; updateDisplay 使用一个 Private 方法来根据剩余的时间来获取文本和图像，并将它们显示在界面上的 Text Field 和 Image View 中。 textToDisplay 把剩余的时间格式化成「分：秒」的格式。imageToDisplay 计算出鸡蛋有多熟的百分比，然后选择合适的图片来显示在界面上。 所以 ViewController 用一个 EggTimer 对象的方法来接收 EggTimer 传来的数据并显示在屏幕上，但是界面上的按钮还没有任何实质性的代码。在第二部分中，你已经为按钮设置了 @IBAction。 这里是这些 IBAction 的方法，你可以用它们来替代之前的 IBAction。 1234567891011121314151617@IBAction func startButtonClicked(_ sender: Any) &#123; if eggTimer.isPaused &#123; eggTimer.resumeTimer() &#125; else &#123; eggTimer.duration = 360 eggTimer.startTimer() &#125;&#125;@IBAction func stopButtonClicked(_ sender: Any) &#123; eggTimer.stopTimer()&#125;@IBAction func resetButtonClicked(_ sender: Any) &#123; eggTimer.resetTimer() updateDisplay(for: 360)&#125; 这里的三个 IBAction 将会调用你之前添加的 EggTimer 方法。 现在编译并运行你的 app，并点击 Start 按钮。你还可以用 Timer 菜单来控制这个 app，试着去用键盘快捷键来操作你的 app。 现在我们还需要完善一些功能：Stop 和 Reset 按钮始终是被禁用的，而且你只可以定 6 分钟的时。 如果你有足够的耐心，你将会看到鸡蛋的颜色随着时间渐渐改变，并在完成时显示一个「DONE！」。 按钮和菜单界面上的按钮以及菜单里的菜单项应该随着 timer 的状态自动启用或禁用。 把这个方法添加到 ViewController 中盛放用于显示相关方法的 Extension 扩展中： 123456789101112131415161718192021222324252627func configureButtonsAndMenus() &#123; let enableStart: Bool let enableStop: Bool let enableReset: Bool if eggTimer.isStopped &#123; enableStart = true enableStop = false enableReset = false &#125; else if eggTimer.isPaused &#123; enableStart = true enableStop = false enableReset = true &#125; else &#123; enableStart = false enableStop = true enableReset = false &#125; startButton.isEnabled = enableStart stopButton.isEnabled = enableStop resetButton.isEnabled = enableReset if let appDel = NSApplication.shared().delegate as? AppDelegate &#123; appDel.enableMenus(start: enableStart, stop: enableStop, reset: enableReset) &#125;&#125; 这个方法使用 EggTimer 的状态（还记得你添加到 EggTimer 里的计算属性吗）来计算出哪个按钮应该启用。 在第二部分中，你创立了一个 Timer menu item 作为 AppDelegate 的属性，所以我们应该在 AppDelegate 中来编辑这些代码。 切换到 AppDelegate.swift，在其中添加这个方法： 12345func enableMenus(start: Bool, stop: Bool, reset: Bool) &#123; startTimerMenuItem.isEnabled = start stopTimerMenuItem.isEnabled = stop resetTimerMenuItem.isEnabled = reset&#125; 为了让你的你的 app 能在初次启动时自动配置按钮的启用状态，在 applicationDidFinishLaunching 方法中添加这些代码： 1enableMenus(start: true, stop: false, reset: false) 每当用户按下了任何一个按钮或菜单项的时候，EggTimer 的状态会发生改变，按钮或菜单项的状态也需要随之更新。返回到 ViewController.swift 中并把这一行添加到三个按钮的 IBAction 方法中： 1configureButtonsAndMenus() 再次编译并运行你的 app，你可以看到按钮们如预期地启用和禁用了。点击菜单里的菜单项试试，它们应该拥有和按钮一样的功能。 偏好设置窗口这个 app 还有一个很重要的问题：如果你希望煮鸡蛋的时间不是 6 分钟呢？ 在第二部分中，你已经设计好了一个偏好设置窗口来允许用户来选择需要的倒计时时间，这个窗口是由 PrefsViewController 控制的，但它还需要一个 Model 对象来处理和查询数据。 用户的设置可以通过一个叫 UserDefaults 的东西来存储，它会在你 app 的沙盒容器中的 Preferences 文件夹中用键值对来存储零碎的小数据。 在 Project Navigator（项目导航器） 中，右键点击 Model 分组，并选择 Xcode 菜单上的 New File…，选择 macOS → Swift File，然后点击 Next，把文件起名为 Preferences.swift 并点击 Create。把这些代码添加到 Preferences.swift 文件中： 1234567891011121314151617181920struct Preferences &#123; // 1 var selectedTime: TimeInterval &#123; get &#123; // 2 let savedTime = UserDefaults.standard.double(forKey: \"selectedTime\") if savedTime &gt; 0 &#123; return savedTime &#125; // 3 return 360 &#125; set &#123; // 4 UserDefaults.standard.set(newValue, forKey: \"selectedTime\") &#125; &#125;&#125; 所以这些代码又干了些啥？ 定义了一个名叫 selectedTime 的 TimeInterval 计算属性； 当别的代码请求访问这个变量的值的时候时，UserDefaults 的单例将会去查找键「selectedTime」对应的 Double 值；如果这个值从没被定义过，UserDefaults 将会返回 0；但如果存在这个值，且它大于 0，就将这个值返回，并设置为 selectedTime； 如果 selectedTime 还没有被定义过，就使用默认值 360（6 分钟）； 只要 selectedTime 的值发生了改变，把新的值用键「selectedTime」存入 UserDefaults。 通过使用 getter 和 setter，UserDefaults 的数据存储将能够自动进行。 现在切换回 PrefsViewController.swift，我们需要把用户修改的设置内容在界面上显示出来。 第一步，在 IBOutlet 之下添加这些代码： 1var prefs = Preferences() 这一步中你创建了一个 Preferences 的实例，所以你现在可以自由访问 selectedTime 计算变量了。 接下来，添加这些方法： 12345678910111213141516171819202122232425262728func showExistingPrefs() &#123; // 1 let selectedTimeInMinutes = Int(prefs.selectedTime) / 60 // 2 presetsPopup.selectItem(withTitle: \"Custom\") customSlider.isEnabled = true // 3 for item in presetsPopup.itemArray &#123; if item.tag == selectedTimeInMinutes &#123; presetsPopup.select(item) customSlider.isEnabled = false break &#125; &#125; // 4 customSlider.integerValue = selectedTimeInMinutes showSliderValueAsText()&#125;// 5func showSliderValueAsText() &#123; let newTimerDuration = customSlider.integerValue let minutesDescription = (newTimerDuration == 1) ? \"minute\" : \"minutes\" customTextField.stringValue = \"\\(newTimerDuration) \\(minutesDescription)\"&#125; 好像是很大一坨代码🙄️…所以我们一点一点来看： 访问 prefs 对象的 selectedTime 属性，并把它转化成整数的分钟数； 把默认的计时时间设置为「Custom」，以防止没有找到人寰预设的数据； 遍历 presetsPopup 里的菜单项并检查他们的 tag，还记得在第二部分中你把每个项目的 tag 都设置成了各自选项的分钟数了吗？如果找到了用户选择的菜单项，就把这个菜单项启用，并跳出这个循环； 设置滑动条的数值，并调用 showSliderValueAsText 方法； showSliderValueAsText 把数字加上「minute」或「minutes」并将它显示在界面上的 Text Field 中。 现在，把这行代码添加到 viewDidLoad 中： 1showExistingPrefs() 在 View 加载的时候，会调用这个方法，把用户的设置加载到界面上，在 MVC 模式中，Preferences Model 完全不知道它伫立的数据会怎样被显示出来 —— 界面显示是 PrefsViewController 的事儿。 所以，尽管现在你的 app 已经可以显示用户设置的时间了，然而偏好设置里的下拉框还是不能工作，你需要为它编写一个方法来让它能存储新的的设置，并告诉所有相关对象数据发生了改变。 在 EggTimer 对象中，你使用了 delegate 模式来把数据传递到需要它的地方，这一次，你需要通过发送一个 Notification（通知）来告诉大家数据改变了（其实用 delegate 还是可以的，这里只是为了演示 Notification 的用法）。任何对象在表明自己对这个通知感兴趣之后，都可以接收到这个通知，并在接收时采取行动。 在 PrefsViewController 中添加以下方法： 12345func saveNewPrefs() &#123; prefs.selectedTime = customSlider.doubleValue * 60 NotificationCenter.default.post(name: Notification.Name(rawValue: \"PrefsChanged\"), object: nil)&#125; 这个方法将会获取 customSlider 滑动条的数值，并转化成分钟数，赋值予 selectedTime，因为我们之前编写的 setter，它会自动使用 UserDefaults 来存储新的数据。然后 NotificationCenter（通知中心）会将一个名叫「PrefsChanged」通知发送出去。 接下来，我们来让 ViewController 能够接收到这个 Notification，并采取行动： 在 PrefsViewController 中要编写的最后一部分代码是为第二部分中你添加的 @IBAction 们添加真正的代码： 12345678910111213141516171819202122232425262728// 1@IBAction func popupValueChanged(_ sender: NSPopUpButton) &#123; if sender.selectedItem?.title == \"Custom\" &#123; customSlider.isEnabled = true return &#125; let newTimerDuration = sender.selectedTag() customSlider.integerValue = newTimerDuration showSliderValueAsText() customSlider.isEnabled = false&#125;// 2@IBAction func sliderValueChanged(_ sender: NSSlider) &#123; showSliderValueAsText()&#125;// 3@IBAction func cancelButtonClicked(_ sender: Any) &#123; view.window?.close()&#125;// 4@IBAction func okButtonClicked(_ sender: Any) &#123; saveNewPrefs() view.window?.close()&#125; 当用户在下拉框中选择了一个新的菜单项，这段代码会检测这个项是不是 Custom： 如果是的，就启用滑动条，并直接终止这个方法； 如果不是，就通过这个项的 tag 来获取用户选择的计时时间； 每当滑动条的数据更新时，更新界面上的文本； 点击 Cancel 按钮会把窗口关闭，且不会存储数据； 点击 OK 按钮会先调用 saveNewPrefs，然后关闭这个窗口。 编译并运行你的 app，前往 Preferences，试着在下拉框中选择不同的选项，观察一下滑动条和文本有没有根据你的选择而正确显示。选择 Custom 选项，然后自己选择一个时间，点击 OK，然后再次前往 Preferences，看看你刚刚选择的时间是不是还能正常显示。 现在试着退出你的 app 并重新打开它，返回 Preferences，看看你的 app 是否保存了你的设置。 让用户的设置生效现在偏好设置窗口看起来还不错了 —— 它可以存储并读取用户的设置，但当你回到主窗口，你看到的时间会还是 6 分钟！ ☹️ 所以你需要编辑 ViewController.swift，让它能使用存储了的数据，并侦听关于数据变化了的通知，从而及时更新或重设 Timer。 把这个 Extension 添加到 ViewController.swift 中类定义以外的部分 —— 这样一来我们的代码会被分成若干个承担不同职能的部分，看起来会更整洁。 1234567891011121314151617181920extension ViewController &#123; // MARK: - 设置 func setupPrefs() &#123; updateDisplay(for: prefs.selectedTime) let notificationName = Notification.Name(rawValue: \"PrefsChanged\") NotificationCenter.default.addObserver(forName: notificationName, object: nil, queue: nil) &#123; (notification) in self.updateFromPrefs() &#125; &#125; func updateFromPrefs() &#123; self.eggTimer.duration = self.prefs.selectedTime self.resetButtonClicked(self) &#125;&#125; 这些代码会报错，因为 ViewController 内部还没有一个叫做 prefs 的对象。在 ViewController 类的定义中（也就是你定义 eggTimer 的地方），添加这行代码： 1var prefs = Preferences() 现在 PrefsViewController 和 ViewController 内部都有了一个 prefs 属性 —— 这是个问题吗？不！原因如下： Preferences 是一个 struct（结构体），所以它是一个数据型的对象而非一个关系型的对象。每一个 View Controller 都可以拥有一份它的副本； Preferences 结构体是使用了 UserDefaults 的单例，所以这俩副本其实是在调用同一个 UserDefaults，因此拿到的数据也是完全一样的。 在 ViewController 最后的 viewDidLoad 方法中，添加这一行代码，它会设置好自己和 Preferences 的连接： 1setupPrefs() 现在还有最后的一系列步骤需要做。之前我们把默认的时间，也就是 360 秒，直接写进了代码里（也就是硬编码，hard-coded），现在因为 ViewController 已经可以访问 Preferences 了，你需要修改一下这种写法。 在 ViewController.swift 中找到「360」（你应该能找到 3 个 360），并把它们修改成 prefs.selectedTime。 编译并运行你的 app，如果你之前修改过设置里的计时时间，你选择的时间现在应该能正常显示在界面上了。前往 Preferences，选择另一时间，点击 OK —— 因为 ViewController 接收到了通知，你新选择的时间应该马上就能显示出来了。 启动计时器，然后前往 Preferences，在主窗口中，倒计时还在继续，修改一个时间然后点击 OK，计时器应用了新的时间，但是也停止并重设了倒计时。我觉得这没什么问题，但是如果能添加一个提示，询问用户是否真的希望停止计时，这样会不会更好呢？ 在 ViewController 中负责处理设置的 Extension 中，添加这些代码： 12345678910111213141516171819202122func checkForResetAfterPrefsChange() &#123; if eggTimer.isStopped || eggTimer.isPaused &#123; // 1 updateFromPrefs() &#125; else &#123; // 2 let alert = NSAlert() alert.messageText = \"Reset timer with the new settings?\" alert.informativeText = \"This will stop your current timer!\" alert.alertStyle = .warning // 3 alert.addButton(withTitle: \"Reset\") alert.addButton(withTitle: \"Cancel\") // 4 let response = alert.runModal() if response == NSAlertFirstButtonReturn &#123; self.updateFromPrefs() &#125; &#125;&#125; 所以这些代码是干啥的？ 如果计时器已经停止或暂停了，不做任何操作直接修改时间； 创建一个 NSAlert，它是一个用来显示一个对话框的类，并设置它的文字和样子； 添加两个按钮：Reset 和 Cancel，它们将会根据你添加的顺序从右往左显示在对话框中，且右边的将会是默认选项； 把警告以一个模态的窗口显示出来，并等待用户的选择，如果用户点击了第一个按钮（Reset），就重设计时器。 在 setupPrefs 方法中，把 self.updateFromPrefs() 这一行改成： 1self.checkForResetAfterPrefsChange() 编译并运行你的 app，开始计时，前往 Preferences，修改一下时间，然后点击 OK，你将会看见一个对话框询问你是否要重设时间。 音效现在这个 app 中唯一未完成的功能就是音效了。如果没有「叮～～」的一声的话，煮蛋计时器还能叫做煮蛋计时器吗？ 在第二部分中，你已经下载了一个包含了所有资产的文件夹，其中的内容绝大多数都是图片，你也已经用过它们了，但是其实这里面还有一个音效文件：ding.mp3。如果你找不到这个文件了，你可以单独下载这个音效文件。 把 ding.mp3 拖动到 Project Navigator（项目导航器）中的 EggTimer 分组下方 —— 看起来就放在 Main.storyboard 下边是一个不错的想法。勾选 Copy items if needed（如果需要的话把文件拷贝到项目中），在 Add to targets（添加到目标中） 中勾选 EggTimer，然后点击 Finish。 你需要一个叫 AVFoundation 的库来播放声音。当代理告诉 ViewController 计时器结束了的时候，ViewController 就会负责播放这个音效，所以我们切换到 ViewController.swift 中，在最顶部你会看到这个文件引用了 Cocoa 库（import Cocoa）。 在那一行引用的下方，添加： 1import AVFoundation ViewController 需用一个 AVAudioPlayer 来播放声音，所以我们为它添加一个属性： 1var soundPlayer: AVAudioPlayer? 我们应该为 ViewController 新建一个单独的 Extension 来处理和声音相关的方法，所以在 ViewController.swift 类定义以外的地方添加： 12345678910111213141516171819202122extension ViewController &#123; // MARK: - 声音 func prepareSound() &#123; guard let audioFileUrl = Bundle.main.url(forResource: \"ding\", withExtension: \"mp3\") else &#123; return &#125; do &#123; soundPlayer = try AVAudioPlayer(contentsOf: audioFileUrl) soundPlayer?.prepareToPlay() &#125; catch &#123; print(\"Sound player not available: \\(error)\") &#125; &#125; func playSound() &#123; soundPlayer?.play() &#125;&#125; prepareSound 方法会负责处理绝大多数的事情 —— 它会先检查 ding.mp3 是否存在于 app 的包中，如果这个文件存在，它就会试图去用这个文件的 URL 来实例化一个 AVAudioPlayer，并准备好它以备播放。这将会预先加载这个音频文件，所以一旦需要，就可以立即播放。 如果 soundPlayer 存在，playSound 会调用它的 play() 方法；但如果 prepareSound 运行失败了，soundPlayer 将会为空（nil），因此它什么也不会做。 声音文件只在 Start 按钮被点击时需要被准备，所以把这行代码插入到 startButtonClicked 方法的最后： 1prepareSound() 在 EggTimerProtocol Extension 的 timerHasFinished 方法中，追加这行代码： 1playSound() 编译并运行之，选择一个短一点的时间并开始计时，一声清脆的「叮🔔」会在计时结束的时候响起。 现在该做些什么？你可以下载这个项目的源代码。 在这个 macOS 开发教程中，你已经掌握了开发 macOS app 的基本技能，但真正要学习的还有很多！ Apple 编写了许多很棒的文档，他们覆盖了 macOS 开发的方方面面。 我同时强烈建议你去看看我们（原作者）的网站 raywenderlich.com 上的其他 macOS 教程。 如果你还有任何问题，欢迎在原文下方参与讨论！","tags":[{"name":"翻译","slug":"翻译","permalink":"https://sr2k.top/blog/tags/翻译/"},{"name":"Ray Wenderlich","slug":"Ray-Wenderlich","permalink":"https://sr2k.top/blog/tags/Ray-Wenderlich/"},{"name":"macOS","slug":"macOS","permalink":"https://sr2k.top/blog/tags/macOS/"},{"name":"Swift","slug":"Swift","permalink":"https://sr2k.top/blog/tags/Swift/"}]},{"title":"【译】 零基础 macOS 应用开发（二）","date":"2017-09-21T20:39:26.000Z","path":"2017/09/22/译-零基础macOS应用开发2/","text":"本文翻译自 raywenderlich.com 的 macOS 开发经典入门教程 ，已咨询对方网站，可至多翻译 10 篇文章。还是先打赏然后去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。综上，此翻译版本仅供参考，谢绝转载。 欢迎回到我们的零基础 macOS 应用开发教程的第二部分（共三部分）！ 在第一部分（原文 / 译文），你了解了如何安装 Xcode、如何创建一个新的 app、添加 UI、连接代码与 UI、运行 app、调试 app，以及寻求帮助。如果你对上述内容还有任何不确定之处，再回去浏览一遍第一部分吧。 在这一部分，你将会创建一个界面更加复杂的 app。你将会学到如何应对可调整大小的窗口，以及设计第二个页面——偏好设置页面，并让你的 app 能跳转到这个新创建的页面。 准备开始和第一部分一样，打开 Xcode 并在欢迎页面点击 Create a new Xcode project，或选择 File 菜单中的 New Project…。接下来在 macOS 下的 Application 标签页中选择 Cocoa Application，并点击 Next，把你的 app 命名为 EggTimer，确保 Language 选项为 Swift 以及 Use Storyboards 被选中。点击 Next 然后找一个合适的地方存储这个项目。 编译并运行你的 app 来确保一切正常。 EggTimer App你将会开发的 app 叫做 EggTimer，它能帮助用户倒计时，并显示剩余的时间。App 的界面上会有一个鸡蛋的图标，随着时间的临近，鸡蛋会被慢慢煮熟；当你的鸡蛋煮熟时，还会有一个提示音。App 内还有一个页面会显示此 app 的偏好设置。 在 Project Navigator（项目导航器）中打开 Main.storyboard，正如第一部分所说的，你已经拥有了三个场景： Application Scene（应用场景）包含了只要 app 运行着就会显示的菜单栏。 Window Controller（窗口控制器）是定义了 app 窗口有怎样行为（怎么调整大小、窗口怎么出现、app 是否会记住上次调整的大小和位置等等）的部分；其实一个 Window Controller 可以管理多个窗口，但如果它们的属性不同，你就需要多个 Windows Controller 了。 View Controller 则显示了窗口中的用户界面——也就是你对 UI 进行布局的地方。 你注意到了吗？有一个箭头指向了 Window Controller，这表明它是 app 启动时的 initial display（初始页面）。你可以在 Document Outline（文档大纲）中选择 Window Controller，然后在 Attributes Inspector（属性检查器）中查看这个设置。取消勾选 Is Initial Controller（用作首要控制器）后，箭头就消失了。因为你需要它来作为首要的控制器，请把这个选项勾选上。 Window Controller（窗口控制器）在你开始着手 UI 前，请确保你已经在 Project Navigator（项目导航器）中选择了 Main.storyboard。点击来选择其中的 window（窗口）。在可视化编辑器中，Window Controller显示了「View Controller」这行字，因为它包含着一个 View Controller（视图控制器）。在这个 app 中，我们不希望用户将窗口调整到 346 × 471 像素以下，这两个数值也将会是 app 启动时窗口的默认大小。 在 Utilities（工具集）面板中前往 Size Inspector（尺寸检查器），设置 Content Size Width（内容宽度）和 Content Size Height（内容高度）分别为 346；勾选 Minimum Content Size（最小内容尺寸）的复选框，并确保其数值与内容尺寸相同。现在，在可视化编辑器里的 Window Controller 的尺寸应该已经发生了变化，因此可能会盖住其他元素，你可能需要重新排列一下它们。 虽然不是必须的，但当你把 View Controller 和承放它的 Window Controller 调整到一样的大小后，后续操作会直观很多。点击并选中 View Controller，在 Size Inspector（尺寸检查器）中设置 Width 和 Height 分别为 346 和 471。如果需要的话，重新排列一下界面上的各个元素防止它们重叠。现在可视化编辑器里的 Window Controller 和 View Controller 都有着一样的尺寸了。 选中 WindowController 里的 Window，在 Attributes Inspector（属性检查器）中把它的名字更改为 Egg Timer，设置 Autosave name 为 EggTimerMainWindow，这样用户上次调整的窗口的尺寸和大小在 app 下次启动时就都会被记住了。 如果你是一个 iOS 开发者，你应该已经处理过不同设备、屏幕尺寸、屏幕旋转方向下的适配问题了。在 macOS 开发过程中，你必须处理无限多种窗口尺寸和长宽比，因此我在这里把窗口的默认尺寸调整成了这么一个奇怪的数字。不过好消息是，Auto Layout 帮助你解决了这个问题。 布局 UI（一）基本的 UI 包含了两个 Stack View（堆叠视图）：第一部分包含显示剩余时间的 Label 和鸡蛋的图标。第二个则在底部包含三个按钮，我们先来制作按钮： 在 Object Library（控件库）中搜索「Button」 向 View Controller 中拖动一个 Gradient button 使用 Attributes Inspector（属性检查器）删除它的图像，并把它 Title 设置为 Start 把字体改成 System 24 把按钮拖大一些让文字能显示完全 选中 Start 按钮，按下 Command⌘ + D 两次来复制两份 把新复制的按钮向右拖动一些，并把他们的 Title 改成 Stop 和 Reset 同时选中三个按钮，然后点击菜单栏上的 Editor → Embed In → Stack View 为了让按钮填满整个 Stack View，选择新创建的 Stack View，然后在 Attributes Inspector（属性检查器）里做出如下更改： Distribution（分配）: Fill Equally（均分填满） Spacing（间距）: 0 在可视化编辑器的底部点击 Add New Constraints（添加新的约束条件），设置左边、右边、底部和高度如上图所示。将 Update Frames 设置为 Items of New Constraints，然后点击 Apply 4 Constraints（应用四条约束）。 Stack View 现在已经放置好了，但这些按钮似乎比 Stack View 矮了一些，在 Document Outline（文档大纲） 中，按住 Control⌃ 键的同时拖动 Start 按钮到 Stack View 上，并选择 Equal Heights（高度等同）。对另外两个按钮进行同样的操作。 现在，包含了按钮的 Stack View 已经完全是我们想要的样子了。 编译并运行你的 app，尝试着改变窗口的大小，这些按钮会紧紧地贴在窗口的底部，并自动填满整个窗口的宽度。 最后一步，在 Attributes Inspector（属性检查器）中取消选中 Enabled 来禁用 Stop 按钮和 Reset 按钮，在计时开始前，这两个按钮不应该被启用。 布局 UI（二）第二个 Stack View 包含剩余的时间以及鸡蛋的图片。向 View Controller 拖入一个 Label，把它的 Title（标题）设置为 6:00 并把 Alignment（对齐）设置为 center（居中）。默认的字体（San Francisco）会自动调整字符的间距——这意味着：随着倒计时的时间的变化，数字会来回跳跃——这会很烦人。 把字体改成 Helvetica Neue 来避免这样，然后把 Size（字体大小）设置为 100。这会使文字超出 Label 的范围，所以调整 Label 的大小直到你可以看到完整的文字。 现在我们需要添加一张图片，在 Object Library（控件库）的搜索框中输入「image」，这会过滤出很多长得很像的控件，你需要的是 Image View，将它拖动到 View Controller 中剩余时间 Label 的下方。 下载这个工程需要的资源文件（一些图片和一个声音文件），解压碎并打开 Egg Images 文件夹。回到 Xcode，在 Project Navigator（项目导航器）中点击 Assets.xcassets。 把这六个图片拖动到 Assets Library（资产库）中，然后它们就可以在你的 app 中使用了。因为图片的文件名中带有「@2x」，它们会被自动分配到各个图像资产的 @2x 区域。 译注：关于 @2x 请自行搜索 Mac/iOS 的 HiDPI适应 前往 Main.storyboard，选中你刚刚添加的 Image View，在 Attributes Inspector（属性检查器）中点击 Image（图像）下拉框，在这个下拉框中你可以看到很多内置的图片以及你刚刚添加的图片，选中 stopped。 现在我们来制作第二个 Stack View：选中显示剩余时间的 Label 和刚刚调整好的 Image View，在菜单栏上点击 Editor → Embed In → Stack View。然后我们来调整一下这个 Stack View，使它填满剩余的空间。点击可视化编辑器底部的 Add New Constrains（添加新的约束），然后添加下图所示的约束条件： 正我们所需要的，Stack View 填满了剩下的空间，但这个 Image View 太小了，选中它，将它左右两您的约束按照下图设置为 User Standard Value（使用标准值）： 在 Attributes Inspector（属性检查器）中，设置 Scaling（缩放） 为 Proportionally Up or Down（等比放大或缩小）。 编译并运行 app，调整窗口的大小，看看 UI 元素是否如预期地自动地适应了窗口尺寸。 连接 UI 和代码在第一部分（原文 / 译文）中，你已经知道了你需要使用 @IBOutlets 和 @IBActions 来连接你的 UI 和代码。在这个例子中，你需要为以下元素设置 @IBOutlets： 剩余时间的 Label 显示鸡蛋的 Image View 三个按钮 此外，这三个按钮还需要 @IBAction 来响应用户的点击操作。在 Project Navigator（项目导航器）中，先选中 Main.storyboard，再按住 Option⌥，点击 ViewController.swift，这样就可以在 Assistant Editor（辅助编辑器，即左右分栏）中打开它了。如果你的屏幕空间不足，点击右上角的按钮来隐藏 Utilities（工具集） 和 Navigator（导航器） 面板。 和第一部分一样，选中剩余时间的 Label，按住 Control⌃ 键的同时拖动它到 ViewController 类中，将名称设置为 timeLeftField，对鸡蛋的 Image View 进行一样的操作，它的名字设置为 eggImageView。然后是三个按钮，他们的名字分别设置成 startButton、stopButton 和 resetButton。 这三个按钮还需要 @IBAction，按住 Control⌃ 并拖动 Start 按钮到代码中，但这次在弹出窗口中将 Connection 设置为 Action，并把它的名字设置为 startButtonClicked，对另外两个按钮重复以上动作，为它们添加名为 stopButtonClicked 和 resetButtonClicked 的 @IBAction。 如果你和我一样也经常忘了把 Connection 修改为 Action 的话，你会得到 @IBOutlets 而不是 @IBAction，如果你要删除这些多余的 @IBOutlet，先把这一行代码删除，再转到 Utilities（工具集）里的 Connections Inspector（连接检查器），你会看到 Referencing Outlets 部分里有两个项目，点击错误连接旁的 × 来删除它，然后重新连接你的 @IBAction（这一次别忘了修改 Action 哦😛）。 ViewController 里的代码现在看起来应该像这样： 在第三部分中，你将会给这些动作添加代码，现在我们关闭 Assistant Editor（辅助编辑器），如果你刚刚隐藏了 Navigator（导航器） 和 Utilities（工具集），重新打开它们。 菜单在 Main.storyboard，在 Application Scene（应用场景） 中点击 menu bar（菜单栏），Xcode 提供的模版已经内置了一些默认的按钮，但是在这个 app 中，很多按钮都派不上用场，最简单的办法来浏览菜单里的项目是使用 Document Outline（文档大纲），点击左侧的小三角来显示 View 菜单和里边的内容。 菜单栏的结构是由一些 Menus（菜单）和 Menu Items（菜单项目）组成的，切换到 Utilities（工具集）里的 Identity Inspector（身份检查器），这样你就能看到，当你点击各个菜单项目的时候，真正触发的东西是什么了。Main Menu 是 NSMenu 的实例，它包含了 NSMenuItem 组成的数组：View 菜单就是这个数组的一个成员。 View 菜单包含一个子菜单（NSMenu），里面包含了它自己的 NSMenuItems，值得注意的是，Separator（分割线）是 NSMenuItem 的特殊形式。 我们要做的第一件事是删除这个 app 里不需要的菜单项，在 Document Outline（文档大纲）中选中 File 菜单，按下键盘上的 Delete⌫ 键把它删掉。如果你是在 Visual Editor（可视化编辑器）中选中它并删除的话，你会把 File 菜单里的菜单项都删掉，然后只剩下一个空空如也的菜单，如果你不小心这样做了，选中那个空白然后再次按下 Delete⌫ 来移除它。 这段话的后半段没有看太明白，望各位指正，原文是： If you select it in the Visual Editor and delete, you will only have deleted the menu inside the File menu item, so you will be left with a space in the menu bar. If this happens, select the space and press Delete again to remove it. 继续删除其他的 Menu，直到你只剩下了 EggTimer、Window 和 Help 菜单。 现在你需要添加一个新的菜单来模拟三个按钮的操作，在 Object Library（控件库） 中搜索 「menu」，请注意，菜单栏中的每一个项目（如 File、Help ）都是 Menu Item，点击它之后打开的才是 Menu，拖动一个 Menu Item 到菜单栏中 Egg Timer 和 Window 之间的地方，它会显示成一个蓝色的方框，这是因为它内部还没有一个带有标题的 Menu。 现在想那个蓝色的方框拖入一个 Menu，如果你觉得那个方框太小拖不准的话，你也可以拖到 Document Outline（文档大纲）里我们刚刚创建的 Item 的下方。新的 Menu 还没有标题，但他已经有了三个菜单项。 选中 Menu（不是 item），切换到 Attributes Inspector（属性检查器）并把 Title（标题）设置为 Timer，选中 Item 1，双击它（或在属性检查器里）把他的标题改为 Start。 在 Attributes Inspector（属性检查器）中点击 Key Equivalent（快捷键），然后按下 Command⌘ + S 来设置快捷键。通常情况下 Command⌘ + S 是保存的快捷键，但是你已经删除了 File 菜单，这样的设置并不会有冲突，但在一般情况下我们还是不要复用常见快捷键的比较好。 用同样的方法把第二、三个 item 的标题分别设置为设置为 Stop 和 Reset，快捷键分别为 Command⌘ + X 和 Command⌘ + R。 在可视化编辑器中 Menu Bar 的上方，你能看到三个按钮，切换到 Identity Inspector（身份检查器），然后依次点击这三个按钮，你可以看到，他们分别连接着 Application、First Responder、和 AppDelegate。First Responder 通常就是当前处于最前端的 View Controller，它可以从 Menu Item 那里接收动作。 按住 Option⌥ 的同时点击 ViewController.swift，然后在你刚刚为按钮们添加的 @IBAction 的下方添加以下代码： 12345678910111213// MARK: - IBActions - menus@IBAction func startTimerMenuItemSelected(_ sender: Any) &#123;_startButtonClicked(sender)&#125;@IBAction func stopTimerMenuItemSelected(_ sender: Any) &#123;stopButtonClicked(sender)&#125;@IBAction func resetTimerMenuItemSelected(_ sender: Any) &#123;resetButtonClicked(sender)&#125;` 这些方法会在菜单项被点击时被调用，然后它们会去调用界面上那三个按钮的 IBAction 方法。其实，你可以让 Menu Item 直接调用按钮的方法（即把 Menu Item 的 IBAction 也拖到之前定义的按钮的 IBAction 上），但在这里我选择这种方式，因为这样的话，调试时这一系列事件会更加清晰明了。现在保存文件并退出 Assistant Editor（协助编辑器）。 按住 Control⌃ 键的同时，把 Start 菜单项拖动到象征着 First Responder 的橙色立方体上，一个包含了很多选项的窗口会弹出来，在键盘上输入「sta」来快速滚动到我们所需要的 startTimerMenuItemSelected 并选择它。 用同样的方法把 Stop 菜单项和 Reset 菜单项分别连接至 stopTimerMenuItemSelected 和 resetTimerMenuItemSelected。现在当 EggTimer 窗口处于最前端时，点击菜单上的按钮将会调用这些方法。 但是还有一个问题：这三个按钮在同一时刻并非同时都是可用的，而且菜单栏上的按钮需要体现出他们是否可用。这个功能无法在 ViewController 里实现，因为它不会一直处于 First Responder 的状态，所以我们需要转战 AppDelegate。 打开 Main.storyboard 并确保这几个 Menu 都处于可见状态，在 Project Navigator（项目导航器）中按住 Option⌥ 键的同时点击 AppDelegate.swift，按住 Control⌃ 键的同时把 Start 菜单项拖动到 AppDelegate 中，创建一个名为 startTimerMenuItem 的 IBOutlet。 用同样的方法为另外两个菜单项创建名为 stopTimerMenuItem 的 resetTimerMenuItem IBOutlet。 在第三部分中你将了解到如何用代码来根据需要启用和禁用这些菜单项，但是现在你需要做的是关闭自动启用与禁用，因为在一般情况下，app 会检测当前的 First Responder 是否包含了 menu item 所连接的 action（一般就是 IBAction），如果没有，就会将他们禁用。在这个 app 中，我们希望自己来控制这件事情，所以选中 Timer 菜单项，在 Attributes Inspector（属性检查器） 中取消选中 Auto Enables Item（自动启用项目）。 偏好设置窗口 现在 EggTimer app 的主界面已经看起来很好了，但他还需要一个偏好设置窗口来让用户选择他们想把鸡蛋煮多熟。 偏好设置界面将会显示在一个单独的窗口中，且拥有它自己的 Window Controller。这是因为尽管在一个 Window Controller 中显示多个 View Controller 是完全可行的，但它们会共享这个 Window Controller 的所有属性，而偏好设置窗口的默认大小与主窗口不一样，而且不可以调整大小。 打开 Main.storyboard，如果 Assistant Editor（辅助编辑器）还处于打开状态，把它关闭。在 Objects Library（控件库）中搜索「window」，向 Visual Editor（可视化编辑器）中拖入一个 Window Controller，Xcode 会自动为你创建一个 View Controller 来盛放需要现实的内容。重新排列一下窗口中的内容以便你能更清楚地看清所有内容，并让你新创建的 Window Controller 更靠近菜单栏。 打开菜单栏上的 EggTimer 菜单，按住 Control⌃ 键的同时拖动 Preferences… 菜单项到我们新创建的 Window Controller 上，这将会创建一个 Segue（转场），也就是说用户点击 Preferences… 时，这个 Window Controller 就会把我们新创建的 View Controller 给显示出来。 偏好设置面板需要显示一个新的 View Controller，所以你需要为它创建一个新的 View Controller 类。在 Project Navigator（项目导航器）中，选中已经存在了的 ViewController.swift 文件，这会确保新建的文件存储在与之相同的组中（Xcode 用 Group 来管理文件），然后在 Xcode 的菜单上点击 File → New → File…。 选择 macOS → Cocoa Class 然后点击 Next，设置类名为 PrefsViewController，父类为 NSViewController，语言选择 Swift，不要勾选 Also create XIB file for user interface（同时为 UI 创建 XIB 文件），然后点击 Next 和 Create 来保存文件。 回到 Main.storyboard，选中我们新创建的 View Controller，请确保你选择的是 View Controller 而不是它的 View，在 Document Outline（文档大纲）里选择会更容易些。在 Identity Inspector（身份检查器）中，把它的 Class 设置为 PrefsViewController。 选择偏好设置窗口里的 Window Controller，前往 Attributes Inspector（属性检查器）把它的标题设置为 Preferences。Autosave Name 保持留空，这样每次窗口出现的时候都会出现在桌面的中央。取消选中 Minimize 和 Resize 复选框，这样窗口的大小就是固定的了。 前往 Size Inspector（属性检查器），把 Content Size 设置为宽 416 高 214。在 Initial Position（默认位置） 下方的两个下拉框中分别选择 Center Horizontally 和 Center Vertically。 选中 View 中的 PrefsViewController，在 Size Inspector（尺寸检查器）中把它的宽和高分别设置为 416 和 214。 PrefsViewController 需要显示一个用来选择时间的下拉框和一个用来选择时间的滑块，它们都包含各自的 Label 用于显示标题，还有两个按钮：Cancel 和 OK，以及一个用于显示当前选择时间的 Label。 拖动以下控件到 View Controller 中并按下表设置它们的属性： Label 设置 title 为「Preset Egg Timings:」 Pop Up Button Label 设置 title 为「Custom Egg Timing:」 Label 设置 title 为 「6 minutes」 Horizontal Slider Push Button 设置 title 为 「Cancel」 Push Button 设置 title 为「OK」 因为这个窗口不能调整大小，控件们会按照你的布局进行显示，所以我们不需要给它设置 Auto-layout 约束条件。把界面上的元素排列好，Xcode 自动会用蓝色的参考线来帮助你进行对齐。将显示「6 minutes」的 Label 的右边拖动到几乎与边界持平，因为它可能需要显示更多内容。双击 Pop Up Button，你会看到三个子项，把他们的标题分别设置为： For runny soft-boiled eggs (barely set whites): 3 minutes For slightly runny soft-boiled eggs: 4 minutes For custardy yet firm soft-boiled eggs: 6 minutes 再从 Objects Library（控件库）中拖动两个 Menu Item、一个 Separator Menu Item 和另一个 Menu Item 到下拉框中，如果你觉得直接拖动它们到界面上有点难度的话，也可以拖动到 Document Outline（文档大纲）的相应位置。 给刚刚拖入的三个子项分别设置标题： For firm yet still creamy hard-boiled eggs: 10 minutes For very firm hard-boiled eggs: 15 minutes Custom 我其实一点都不知道怎么煮鸡蛋，所以我从 The Kitchn 找到了以上的时间和描述。 选中下拉框本体（而不是那几个子项），把它的 Selected Item（已选中项目）设置为那个「6 minute」的选项。 现在你需要让你的 app 知道用户在下拉框中到底选择了哪个子项，依次选中下拉菜单中的每一个自子项，在 Attributes Inspector（属性检查器）中设置它们的 Tag 分别为对应的分钟数：3、4、6、10、15（Custom 子项设置为 0）。 现在选择 Slider，在 Attributes Inspector（属性检查器）中将 Tick marks（刻度数） 设置为 25，Minimum Valve 设置为 1，Maximum Valve 设置为 25，并勾选 Only stop on tick marks（只能选择刻度），你需要将滑块向下移动一些来适应新出现的刻度。因为只有当用户在下拉框种选择了 Custom 的时候才会启用，所以我们还需要取消选择 Enabled。 连接偏好设置里的元素和代码在 Project Navigator（项目导航器）中按住 Option⌥ 键的同时点击 PrefsViewController，如果你需要更多空间的话隐藏掉侧边面板。你需要为下拉框、滑动条和显示“6 minutes”的 Label 添加 @IBOutlet。把它们依次拖动到 PrefsViewController.swift 中，并给这些 IBOutlet 分别起名： Popup: presetsPopup Slider: customSlider Label: customTextField 接下来，按住 Control⌃ 键的同时拖动以下项目来创建 @IBAction（别忘了把 Connection 改成 Action 哦～）： Popup: popupValueChanged Slider: sliderValueChanged Cancel button: cancelButtonClicked OK button: okButtonClicked 现在你的代码看起来应该像这样： 至此，偏好设置面板窗口的布局就已经完成了，编译并运行你的 app 并在 EggTimer 菜单中选择 Preferences 菜单，检查一下打开的偏好设置窗口，然后点击红色的关闭按钮来关闭这个窗口。 App 图标UI 部分还剩一步：为你的 app 添加图标。你之前已经下载了一个包含了这个 app 所需要的所有文件的资产文件夹，而且已经添加了一些图片到 Assets.xcassets 中，现在我们需要打开这个文件夹并找到 egg-icon.png 文件。 在 Project Navigator（项目导航器）中选择 Assests.xcassets，点击 AppIcon 并拖动 egg-icon.png 到 Mac 256pt 1x 的方框中。正如第一部分所说的，在真正的产品中你需要提供所有尺寸的图标，但在这个 app 中，一个图标就足够了。 编译并运行你的 app，看看新的图标有没有出现在 Dock 中，如果没有，你可能需要在 Xcode 的 Product 菜单中点击 Clean，然后再试一次。","tags":[{"name":"翻译","slug":"翻译","permalink":"https://sr2k.top/blog/tags/翻译/"},{"name":"Ray Wenderlich","slug":"Ray-Wenderlich","permalink":"https://sr2k.top/blog/tags/Ray-Wenderlich/"},{"name":"macOS","slug":"macOS","permalink":"https://sr2k.top/blog/tags/macOS/"},{"name":"Swift","slug":"Swift","permalink":"https://sr2k.top/blog/tags/Swift/"}]},{"title":"【译】 零基础 macOS 应用开发（一）","date":"2017-09-17T10:51:26.000Z","path":"2017/09/17/译-零基础macOS应用开发1/","text":"本文翻译自 raywenderlich.com 的 macOS 开发经典入门教程，已咨询对方网站，可至多翻译 10 篇文章。希望各位有英语阅读能力的话，还是先打赏然后去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。 你想要学习开发你自己的 macOS app 吗？ 有一个好消息要告诉你！在这个教程中你将会发现，Apple 让开发 macOS app 这件事变得无比简单。你将会学习到如何去创建你的第一个 macOS app——即使你是一个完全的小白。 在第一部分中，你将学会如何获取 macOS 开发所需要的工具们。然后，通过创建一个简单的「Hello, World!」app，你将会粗略地认识 Xcode——如何运行一个 app、编辑代码、设计 UI 以及调试你的代码。 在第二、三部分中，你将会创建一个复杂的多的「Egg Timer」app，并了解一个 macOS app 的各个组成部分——从一个 app 是如何启动的，到 UI 是如何被构建的，一直到处理交互。 所以你还在等什么呢？桌面级 app 的世界正在等着你！ 注意：关于如何开始学习这个系列，这里有一些提示： 如果你从未学习过 Swift，这个系列涉及了一些 Swift 知识，所以请先看看我们的 Swift 教程。 如果你已经有过 iOS 的开发经验，第一部分的内容则可以看作一个复习。保险起见，请快速地浏览一下这些内容，然后直接跳转到下一个部分。 这个课程是为完全的小白而准备的——你不需要拥有任何 iOS 或 macOS 开发经验！ 开始要成为一个 macOS 开发者，你需要两个东西： 一台运行着 macOS Sierra 的 Mac：macOS 操作系统只能在苹果电脑上运行，因此无论是开发还是运行 macOS app，你都需要一台 Mac。 Xcode：这是创建 macOS app 的 IDE（集成开发环境）。稍后你将学会如何在 Mac 上安装它。 当你完成 app 的开发，希望将它上传至 App Store 进行销售时，你需要一个 Apple 的开发者账户。但直到你已经准备好让你的 app 飞向整片世界的蓝天，这都不是一个硬性要求。甚至你已经决定发布你的 app，也只有在你准备通过 Mac App Store 进行销售时才会需要一个开发者账户。如果你已经是一个 iOS 开发者，那你已经搞定了一切——Apple 已经将各种开发者账户融合为一个，因此你只需要一个账户就可以为各种 Apple 设备分发 app。 不同于有些其他平台，为 macOS 开发 app 只需要一个工具：Xcode。Xcode 这个 IDE 包含了创建 macOS、iOS、watchOS 和 tvOS app 时所需要的一切。 如果你还没有安装好 Xcode，点击你 Mac 左上角的 Apple 图标，并选择 App Store 来打开 App Store。即便 Xcode 是免费的，你仍需要一个 App Store 的账户来下载 Xcode。 现在请搜索 Xcode，然后点击获取按钮来开始下载。当它下载并安装好（这可能得花点时间，它不是个小软件）之后，你可以在 应用程序文件夹中打开它。 Hello World!遵循长久以来学习一门新编程语言或平台的传统，你将会学习如何为 macOS 开发一个「Hello World!」app。 如果 Xcode 现在还没打开，请打开它。你会看到一个「Welcome to Xcode」的窗口。如果你没有看到这个窗口。点击 Window 菜单中的 Welcome to Xcode。 点击 Create a new Xcode project 并在接下来的对话框中，在顶部的标签中选择 macOS，然后在 Application 部分中选择 Cocoa Application，并点击 Next。 给你的 app你取个名字——Hello World，并确保 Language 设置为 Swift，以及 Use Storyboards 被勾选。其他选项全部取消勾选。 点击 Next 和 Create 来保存你的新项目。 运行你的 appXcode 已经为你的 app 应用了一个基础的模版，并添加了其运行所需要的所有文件。因此，什么都不用做而直接运行它其实还挺有趣的。 点击工具栏上的 播放按钮️ 或使用键盘快捷键 ⌘R 来运行你的 app。Xcode 现在会将所有的代码编译成机器语言，将 app 运行所需要的所有资源文件打包，然后运行它。 注意：当你第一次在 Xcode 中运行一个 app 的时候，你可能会被询问是否要 Enable Developer Mode on this Mac（在这台 Mac 上启用开发者模式），请放心地点击 Enable，这可能会要求你输入 Mac 的开机密码。开发者模式允许 Xcode 附加调试器到你的 app 的进程——这对于开发一个 app 来说极其有用！ 你现在应该能看到一个空白的窗口了，但请不要灰心——你现在已经能做到这些了： 这个窗口可以调整大小、最小化和全屏； 这个 app 拥有已经拥有了一套完整的菜单选项，这其中有很多都已经可以正常使用而不用你做任何事情。 Dock 栏上的 app 图标也拥有了常见的菜单。 但是现在是时候来把这个空空的屏幕变得更有趣了，所以请退出这个 app 并返回到 Xcode。 Xcode 的界面Xcode 将许多功能融合在同一个窗口中，因此许多东西并不能同时显示出来。要想成为一个 Xcode 高手，你需要知道你需要的功能在哪里，以及如何打开它们。 当你在 Xcode 里打开一个新的工程，你已经拥有了一个带有工具栏和三个主要面板的窗口。 左边的窗口是 Navigator（导航器），在这个面板的顶部有八个标签将它分成了八个部分。你所最常用到的是第一个——Project（项目）——它列出了项目中所有的文件，你可以点击这些文件来编辑它们。 中间的面板是 Editor（编辑器），这里会显示你在 Project Navigator（项目导航器）里选择的文件。 右侧的面板是 Utilities（工具集）面板，这里显示的内容会会随着你在 Editor 里进行的操作而变化。 添加 UI你可以使用 Storyboard 来设计 app 的 UI（用户交互界面）。你的 app 已经有了一个 storyboard，所以在 Project Navigator（工程导航器） 中点击 Main.stroyboard 来将之显示在编辑器中。 你的屏幕自动切换了，是不是很神奇！在编辑器中，你现在可以看到文档的线框图，以及可视化的 UI 编辑器。 看一看你可视化编辑器中的东西。这儿有三个主要的区域，每一个都有着一个文本占位符： Application Scene：顶部的菜单栏； Window Controller Scene：配置窗口会有怎样的表现； View Controller Scene：放置 UI 控件的地方。 在 Utilities 面板里，你将会看见上半部分有八个标签页，而下半部分有四个标签页下半部分的区域呈现了你可以插入到你的项目里的东西。现在你需要插入 UI 控件，所以点击第三个图标 Object Library。 在底部的过滤器（输入框）中，输入「text」，然后找到并拖动一个 Text Field 到你的 View Controller Scene。 现在搜索「button」并拖动一个 Push Button 到 View Controller Scene 中。最后，再添加一个 Label。 现在，点击播放按钮️或按下 ⌘R 来编译并运行你的 app，你就能看到这三个 UI 元素了。试着在输入框中打些字——它现在已经支持所有标准的键盘快捷键了：复制、粘贴、剪切、撤销、重做…但是界面上的按钮还是什么都做不了，文本也只显示了一个「Label」，所以现在我们该把它们连接起来。 配置 UI返回 Main.storyboard 并点击界面上的 Button，在右侧的 Utilities 面板中，点击第四个标签页 Attributes Inspector。 把按钮的标题改为「Say Hello」，此时的按钮可能不够宽，所以请点击菜单栏上的 Editor，然后点击 Size to Fit Content。（如果 Size to Fit Content 选项不可用，先点击空白处取消选中这个按钮，再重新选择它，然后再试一次）。 现在点击并选中 Text Field。在这个 app 中，用户将在这里输入他们的名字，当他们点击按钮时，app 会显示「Hello」+他们的名字。为了提示用户，我们在 Attributes Inspector 中为输入框中添加一个占位符。 把输入框稍微拖大一些，以便能放下一些较长的名字，然后把按钮拖动到它的右边。当你在 View Controller Scene 中拖动元素时，会出现一些蓝色的虚线来帮助你根据 Apple’s Human Interface Guidelines（Apple 人机交互指南）对齐并放置元素。 把 Label 放置在输入框的下方。因为这个 Label 十分重要，我们把它的字体改大一些，选中这个 Label，在 Attributes Inspector 中把 Font 更改为 System Regular 30。 不如来些更刺激的吧！把文字的颜色改成红色。 你不知道用户的名字会有多长，所以我们需要重新调整输入框的大小，以适应字体的高度，并把宽度调整为和窗口的宽度差不多。 编译并运行你的 app 来检查一下你的 UI 设置是否生效了。一旦你觉得 Label 中的文字效果令你满意，把 Label 的 Title 删除，这样一来就清空了 Label 里的文字。 连接 UI 与代码你的 app 现在无法按照你预期的那样工作，你仍需要添加代码来让你的代码能与 UI 通讯。为了建立这种联系，你需要使用 Xcode 的 Assistant Editor，先在导航器中选中 Main.storyboard，按住 Option⌥ 键的同时点击 ViewController.swift，这个操作将会在不关闭之前打开的文件的情况下，为 ViewController.swift 打开第二个编辑器面板。 现在屏幕上的东西可能看起来有些拥挤（当然这也取决于你的显示器尺寸），所以点击工具栏最右上方的按钮来隐藏 Utilities 面板。如果你的显示器空间还是不够，把 Navigator 面板也一并隐藏了。 选中输入框，按住 Control⌃ 键的同时把文本框拖动到 class ViewController : NSViewController { 和 override func viewDidLoad() { 之间的那一行，松开鼠标时会弹出一个小窗口，在「name」中输入 nameField，然后点击 Connect。 对 Label 做同样的事情，并把它命名为 helloLabel。看一看 Xcode 自动生成的代码，你将会看见它们都以 @IBOutlet 开头，这是「Interface Builder Outlet」的缩写，也就是告诉 Storyboard 编辑器这些对象的名称是如何与视觉元素关联起来的。 对于那个按钮，代码中不需要给它起名字，但它需要知道用户何时点击了这个按钮。与 @IBOutlet 不同，这种连接叫做 @IBAction。 和先前一样，选中按钮，按住 Control⌃ 键的同时把文本框拖动到 ViewController.swift 中。这一次把 Connection 选项设置为 Action，并把 name 设置为 sayButtonClicked。这将会创建一个按钮被电击时会调用的一个方法。 现在万事俱备，只差代码了！点击右侧编辑器面板右上角的「×」关闭 Assistant Editor，回到 ViewController.swift。如果你隐藏了 Navigator，点击右上角的按钮或按下 ⌘1 来直接跳转到 Project Navigator。 把如下代码输入到 sayButtonClicked 方法中： 123456var name = nameField.stringValueif name.isEmpty &#123; name = \"World\"&#125;let greeting = \"Hello \\(name)!\"helloLabel.stringValue = greeting 在删除了顶部自动生成的版权信息后，完成了的 ViewController.swift 中的代码看起来应该像下边截图中的一样。行号左边的小气泡表明这是一个 UI 与代码的连接点。 现在编译并运行你的 app。 什么也要不输入，并点击 Say Hello 按钮，你将会看到「Hello World!」；而输入了你的名字之后再点击，就能看到你专属的问候语了。 调试有时，我们开发者会犯错——相信我，真的会的。当我们犯了错，就需要调试我们的代码。Xcode 允许我们在代码的任意一处暂停，然后一行一行地运行代码，让你检查每一行运行后各个变量的值，以此来找到错误。 在 ViewController.swift 中找到 sayButtonClicked，点击 var name = 左边的行号，一个蓝色的小旗子将会出现，这是一个激活了的断点，当你点击你 app 界面上的按钮时，调试器会让程序在这里暂停。再次点击它，它会变成浅浅的蓝色，这是一个未激活的断点，它将不会暂停代码，也不会启动调试器。要彻底移除一个断点，把它从行号那一条中拖出去即可。 再次添加一个断点并运行你的 app，点击 Say Hello 按钮，Xcode 会移动到最顶层，并把有断点的那一行高亮显示。在 Editor 面板的最底部，将会有两个部分：Variables（变量）和 Console（控制台）。Variables 部分展示了此函数中用到的所有变量以及 self（也就是 View Controller）和 sender（也就是按钮）。 在 Variables 部分的上方有几个控制调试器的按钮。请把鼠标挨个放在这些按钮上，根据弹出的工具提示看看他们是做什么的。点击 Step Over 按钮来运行下一行代码。 在 Variables 部分中，你可以看到 name 是一个空的字符串，所以再连续点击 Step Over 按钮两次，调试器会移动到 if语句中，并把 name 变量设置为「World」。 在 Variables 部分中选中 Name 变量，点击下方的 Quick Look 按钮来查看具体的内容，电击 Print Description 按可以把它的信息输出到 Console 部分中。如果「World」没有被正确地设置，你应该能在这里看到，并想出对应的对策。 当你检查完所有的变量内容后，点击 Continue program execution 按钮来停止调试，并让程序继续运行。你可以使用界面右上角的按钮来隐藏调试器。 图像除了代码和 UI，你的 app 还需要一些图像。根据屏幕的不同（Apple 设备上分为 Retina 显示屏和非 Retina 显示屏），你经常需要为一套「资产」提供多个版本。为了简化这个流程，Xcode 使用 Asset Libraries 来存储和管理这些 app 需要的资产。 在 Project Navigator 中点击 Assets.xcassets，到目前为止里边只有一个 AppIcon，它包含了不同分辨率下的 app 的图标。点击 AppIcon，你会看到它需要 10 个不同的图片来覆盖所有的情况，但如果你只提供了一个，那么 Xcode 会尽量让它发挥最大功效，但这并不是一个正确的做法——你需要尽力为你的 app 提供所有尺寸的图标，但在这个简单的上手教程中，一个图标就够了，当你真正开始制作自己的 app 时，这些图标最好一个都别少。 下载 512×512 像素的示例图标，把它拖动到 Mac 512pt 1x 的方框中。 编译并运行你的 app，查看 Dock 栏中的图标，如果你看到的还是默认图标，请在 Product 菜单中选择 Clean，然后再次运行。 获得帮助除了一个编辑器，Xcode 还包含了你编写 macOS app 所需要的所有文档。 在 Help 菜单中选择 Documentation and API Reference。搜索 NSButton，请确保当前选中的语言是 Swift，只需点击顶部的搜索结果，就可以找到所有关于按钮的信息了。 还有一种方法，可以在你的代码中直接查看相关的文档，返回 ViewController.swift，找到 sayButtonClicked 所在的行，按住 Option⌥ 键的同时点击 stringValue，一个快速的查询面板将会弹出，在底部还有一个 Property Reference 的链接，点击它就可以在文档中查看更多信息。 Option⌥ +鼠标点击是一个特别好的学习方式，你甚至可以为你自己编写的函数添加自己编写的文档，以便今后快速查阅。 Help 菜单中还包括了 Xcode Help，在这里你可以了解到更多的 Xcode 信息。","tags":[{"name":"翻译","slug":"翻译","permalink":"https://sr2k.top/blog/tags/翻译/"},{"name":"Ray Wenderlich","slug":"Ray-Wenderlich","permalink":"https://sr2k.top/blog/tags/Ray-Wenderlich/"},{"name":"macOS","slug":"macOS","permalink":"https://sr2k.top/blog/tags/macOS/"},{"name":"Swift","slug":"Swift","permalink":"https://sr2k.top/blog/tags/Swift/"}]},{"title":"微信小程序之PHP发送模板消息","date":"2017-04-01T04:04:42.000Z","path":"2017/04/01/微信小程序之PHP发送模板消息/","text":"小程序开放个人申请已经有个几天了，踩了无数的坑…折腾了半个多小时终于搞定了模板消息的推送，在这儿 share 一下咯 名词解释首先，发送模板消息需要准备几样东西，先解释一下他们都是啥： formId 或 prepay_id 用户必须得提交了表格或进行了支付才能推送模板消息，表格提交后能得到 formId，支付完成能得到 prepay_id，而且一个 formId 或 prepay_id 只能推送一条消息。 支付当用户在小程序内完成过支付行为，可允许开发者向用户在 7 天内推送有限条数的模板消息（1 次支付可下发 1 条，多次支付下发条数独立，互相不影响）提交表单当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响） openID “推送给谁”的用户标识符 template_id 模板消息的模板编号，可在微信小程序的后台申请 access_token access_token 是全局唯一接口调用凭据，开发者调用各接口时都需使用 access_token，请妥善保存。access_token 的存储至少要保留 512 个字符空间。access_token 的有效期目前为 2个小时，需定时刷新，重复获取将导致上次获取的 access_token 失效。 获取 formID首先，个人小程序是无法进行支付的，所以只好用提交 form 的办法了： 123456&lt;!-- submit.wxml --&gt;&lt;form bindsubmit=\"submit\" report-submit=\"true\"&gt; &lt;!-- 这里是表单的各种 &lt;input&gt; --&gt; &lt;button formType=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt; 然后，在 JS 里接收 form 的 formID 1234567// submit.jssubmit: function (e) &#123; var formID = e.detail.formId; // 这里用 wx.request 把数据提交给后端&#125; 发送模板消息获取 access_tokenaccess_token 需要用到自己小程序的 appId 和 appsecret，并调用微信的 API，PHP 脚本如下： 注：我自己是把关于小程序的方法都封装在了一个 Utility 类里，这里就当作单独的函数列出了。 12345678910// getAccessToken.phpfunction getAccessToken ($appid, $appsecret) &#123; $url='https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid='.$appid.'&amp;secret='.$appsecret; $html = file_get_contents($url); $output = json_decode($html, true); $access_token = $output['access_token']; return $access_token;&#125; 发送模板消息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// sendNotice.phprequire_once('getAccessToken.php');// 根据你的模板对应的关键字建立数组// color 属性是可选项目，用来改变对应字段的颜色$data_arr = array( 'keyword1' =&gt; array( \"value\" =&gt; $value, \"color\" =&gt; $color ) );$post_data = array ( // 用户的 openID，可用过 wx.getUserInfo 获取 \"touser\" =&gt; $openid, // 小程序后台申请到的模板编号 \"template_id\" =&gt; $templateid, // 点击模板消息后跳转到的页面，可以传递参数 \"page\" =&gt; \"/pages/check/result?orderID=\".$orderID, // 第一步里获取到的 formID \"form_id\" =&gt; $formid, // 数据 \"data\" =&gt; $data_arr, // 需要强调的关键字，会加大居中显示 \"emphasis_keyword\" =&gt; \"keyword2.DATA\"); // 发送 POST 请求的函数// 你也可以用 cUrl 或者其他网络库，简单的请求这个函数就够用了 function send_post( $url, $post_data ) &#123; $options = array( 'http' =&gt; array( 'method' =&gt; 'POST', // header 需要设置为 JSON 'header' =&gt; 'Content-type:application/json', 'content' =&gt; $post_data, // 超时时间 'timeout' =&gt; 60 ) ); $context = stream_context_create( $options ); $result = file_get_contents( $url, false, $context ); return $result;&#125;// 这里替换为你的 appID 和 appSecret$url = \"https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=\" . getAccessToken ($appid, $appsecret); // 将数组编码为 JSON$data = json_encode($post_data, true); // 这里的返回值是一个 JSON，可通过 json_decode() 解码成数组$return = send_post( $url, $data);var_dump($return); 返回值（直接复制疼训爸爸的原话咯） 返回码 说明 0 一切正常，推送成功 40037 template_id 不正确 41028 form_id 不正确，或者过期 41029 form_id 已被使用 41030 page不正确 45009 接口调用超过限额（目前默认每个帐号日调用限额为100万） 最终推送出来的效果如下：","tags":[{"name":"小程序","slug":"小程序","permalink":"https://sr2k.top/blog/tags/小程序/"},{"name":"PHP","slug":"PHP","permalink":"https://sr2k.top/blog/tags/PHP/"}]}]