<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="React 是一个用来制作 UI 的 JavaScript 库，其核心是跟踪组件状态的变化，并将其更新在屏幕上的机制机制，在 React 中，这一过程被称为协调。每当我们调用 setState 时，React 都会检测 state 和 props 是否发生了变化，并在 UI 中重新渲染组件。 React 的文档很好地提供了这个机制的大致简介：整个过程中 React 元素的担当角色、生命周期方法和">
<meta name="keywords" content="JavaScript,翻译,React">
<meta property="og:type" content="article">
<meta property="og:title" content="【译】Fiber：深入了解 React 的全新调度算法">
<meta property="og:url" content="https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/index.html">
<meta property="og:site_name" content="SR2k">
<meta property="og:description" content="React 是一个用来制作 UI 的 JavaScript 库，其核心是跟踪组件状态的变化，并将其更新在屏幕上的机制机制，在 React 中，这一过程被称为协调。每当我们调用 setState 时，React 都会检测 state 和 props 是否发生了变化，并在 UI 中重新渲染组件。 React 的文档很好地提供了这个机制的大致简介：整个过程中 React 元素的担当角色、生命周期方法和">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/demo.gif">
<meta property="og:image" content="https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/fiber-tree.png">
<meta property="og:image" content="https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/effect-link-in-tree.png">
<meta property="og:image" content="https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/effect-link.png">
<meta property="og:image" content="https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/algo.gif">
<meta property="og:updated_time" content="2019-07-22T03:17:57.952Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【译】Fiber：深入了解 React 的全新调度算法">
<meta name="twitter:description" content="React 是一个用来制作 UI 的 JavaScript 库，其核心是跟踪组件状态的变化，并将其更新在屏幕上的机制机制，在 React 中，这一过程被称为协调。每当我们调用 setState 时，React 都会检测 state 和 props 是否发生了变化，并在 UI 中重新渲染组件。 React 的文档很好地提供了这个机制的大致简介：整个过程中 React 元素的担当角色、生命周期方法和">
<meta name="twitter:image" content="https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/demo.gif">
    
    
        
          
              <link rel="shortcut icon" href="/blog/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/blog/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>【译】Fiber：深入了解 React 的全新调度算法</title>
    <!-- styles -->
    <link rel="stylesheet" href="/blog/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/blog/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/blog/">首页</a></li>
         
          <li><a href="/blog/archives/">归档</a></li>
         
          <li><a href="https://sr2k.top">简历</a></li>
         
          <li><a href="http://github.com/SR2k">项目</a></li>
         
          <li><a href="/blog/tags/">tags</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/blog/2019/08/22/备战秋招/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/blog/2019/07/19/arrow-functions/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&text=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&is_video=false&description=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【译】Fiber：深入了解 React 的全新调度算法&body=Check out this article: https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&name=【译】Fiber：深入了解 React 的全新调度算法&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从-React-元素到-Fiber-节点"><span class="toc-number">2.</span> <span class="toc-text">从 React 元素到 Fiber 节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#React-元素"><span class="toc-number">2.1.</span> <span class="toc-text">React 元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber-节点"><span class="toc-number">2.2.</span> <span class="toc-text">Fiber 节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Current-树和-workInProgress-树"><span class="toc-number">2.3.</span> <span class="toc-text">Current 树和 workInProgress 树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#副作用"><span class="toc-number">2.4.</span> <span class="toc-text">副作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#副作用链表"><span class="toc-number">2.5.</span> <span class="toc-text">副作用链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber-树的根"><span class="toc-number">2.6.</span> <span class="toc-text">Fiber 树的根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber-节点的结构"><span class="toc-number">2.7.</span> <span class="toc-text">Fiber 节点的结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算法概况"><span class="toc-number">3.</span> <span class="toc-text">算法概况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Render-阶段"><span class="toc-number">4.</span> <span class="toc-text">Render 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事务循环的主要流程"><span class="toc-number">4.1.</span> <span class="toc-text">事务循环的主要流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Commit-阶段"><span class="toc-number">5.</span> <span class="toc-text">Commit 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#挂载前生命周期方法"><span class="toc-number">5.1.</span> <span class="toc-text">挂载前生命周期方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-更新"><span class="toc-number">5.2.</span> <span class="toc-text">DOM 更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#挂载后生命周期方法"><span class="toc-number">5.3.</span> <span class="toc-text">挂载后生命周期方法</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        【译】Fiber：深入了解 React 的全新调度算法
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">SR2k</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-07-22T03:08:26.000Z" itemprop="datePublished">2019-07-22</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/blog/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/blog/tags/React/">React</a>, <a class="tag-link" href="/blog/tags/翻译/">翻译</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>React 是一个用来制作 UI 的 JavaScript 库，其核心是跟踪组件状态的变化，并将其更新在屏幕上的机制<a href="https://medium.freecodecamp.org/what-every-front-end-developer-should-know-about-change-detection-in-angular-and-react-508f83f58c6a" target="_blank" rel="noopener">机制</a>，在 React 中，这一过程被称为<strong>协调</strong>。每当我们调用 <code>setState</code> 时，React 都会检测 state 和 props 是否发生了变化，并在 UI 中重新渲染组件。</p>
<p>React 的文档很好地提供了这个机制的<a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">大致简介</a>：整个过程中 React 元素的担当角色、生命周期方法和 <code>render</code> 方法，以及对各个子组件实施的 diff 算法。<code>render</code> 方法返回的这些不可变的 React 元素树通常被我们称为「virtual DOM」。在以前，这个术语帮助我们理解了 React 的工作模式，但也带来了许多困惑，所以现在 React 的文档已经不再使用它了，所以本文将会将他们称作「React 元素树」。</p>
<p>为了维护状态，除了 React 元素树，React 同时也维护着一些内部实例（如组件、DOM 节点等）构成的树。自 v16 开始，React 推出了一种全新的维护内部实例树的算法实现，并取代号为「<strong>Fiber</strong>」。要想了解 Fiber 架构带来的种种好处，你可以看这篇文章：<a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">《React 在 Fiber 中使用链表的原因和方法》</a>。</p>
<blockquote>
<p>如果没有 <a href="https://medium.com/u/a3a8af6addc1" target="_blank" rel="noopener">Dan Abramov</a> 的帮助，这篇文章得花多得多的时间才能完成，而且全面性也会大打折扣！<em>👍</em></p>
</blockquote>
<p>这是 React 内部架构系列教程的第一篇。在这篇文章中，我会深入介绍与核心算法有关的重要概念和数据结构。当我们了解地足够多的时候，我们会开始探索取得和操作 Fiber 树的算法和主要函数。这个系列的下一篇文章将会演示 React 是如何使用这个算法来实施初次渲染，并处理 state 和 props 的。从那开始我们将移步调度器的种种细节，以及实现副作用列表的机制。</p>
<p><a href="https://twitter.com/maxkoretskyi" target="_blank" rel="noopener"><strong>关注我获得最新消息！</strong></a></p>
<p>本文会介绍许多进阶知识 🧙‍。我鼓励你阅读本文，并理解 React 工作时的各种黑魔法。如果你打算为 React 作出贡献，这一系列文章也会是一个很好的指南。我是<a href="https://blog.angularindepth.com/level-up-your-reverse-engineering-skills-8f910ae10630" target="_blank" rel="noopener">逆向工程的重视拥趸</a>，所以这儿会有许多指向 React 16.6.0 源码的链接。</p>
<p>要学的东西很多，所以如果你感觉有压力，或者对有些东西现在还不太理解，请多花点时间，因为这很值得。<strong>需要注意的是你不需要这里的任何知识来使用 React，这篇文章只关乎 React 的内部实现原理。</strong></p>
<blockquote>
<p>我在 <a href="https://react-grid.ag-grid.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=reactcustom" target="_blank" rel="noopener"><strong>ag-Grid</strong></a> 担任技术推广工程师。 If you’re curious to learn about data grids or looking for the ultimate React data grid solution, get in touch or give it a try with the guide “<a href="https://blog.ag-grid.com/react-get-started-with-react-grid-in-5-minutes/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=getstartedangular" target="_blank" rel="noopener"><strong>Get started with React grid in 5 minutes</strong></a>”. I’m happy to answer any questions you may have.</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本文的示例是这样一个应用——界面上有一个按钮，点击它以后数字会增加，并在屏幕上渲染出来：</p>
<p><img src="./demo.gif" alt></p>
<p>以及它的代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Update counter&lt;<span class="regexp">/button&gt;,</span></span><br><span class="line"><span class="regexp">      &lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在<a href="https://stackblitz.com/edit/react-t4rdmh" target="_blank" rel="noopener">这里</a>把玩一下这个例子，它就是一个简单的组件，在其 <code>render</code> 方法中返回 <code>button</code> 和 <code>span</code> 两个元素。当你点击按钮时，事件处理器会更新组件的 state，然后作为结果，<code>span</code> 元素中的文字会被更新。</p>
<p>React 在<strong>协调</strong>的过程中会做很多事情，比如在我们的示例 app 中，React 会在初次渲染完成后以及 state 被更新后做的事情大致包括：</p>
<ul>
<li>在 <code>ClickCounter</code> 中更新 <code>count</code> 属性；</li>
<li>找到 <code>ClickCounter</code> 和其 props，并进行比较；</li>
<li>更新 <code>span</code> 元素的 props。</li>
</ul>
<p><strong>协调</strong>的过程中还会发生其他事情，如调用<a href="https://reactjs.org/docs/react-component.html#updating" target="_blank" rel="noopener">生命周期方法</a>和更新<a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">引用（refs）</a>。<strong>在 Fiber 架构中，这些事情都统一地被称为「事务」。</strong>事务的种类通常取决于 React 元素的种类，例如对于一个类组件，React 需要创建一个实例，但是函数组件就不需要。你肯定知道，React 中有很多种元素，如类和函数组件、宿主组件（也就是 DOM 节点）、Portal 等。<a href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react/src/ReactElement.js#L171" target="_blank" rel="noopener"><code>createElement</code></a> 方法的第一个参数决定了 React 元素的种类，这个方法一般用于在 <code>render</code> 方法中创建 React 元素。</p>
<p>在开始探索 Fiber 算法和事物之前，我们现来熟悉一下 React 内部使用的数据结构。</p>
<h1 id="从-React-元素到-Fiber-节点"><a href="#从-React-元素到-Fiber-节点" class="headerlink" title="从 React 元素到 Fiber 节点"></a>从 React 元素到 Fiber 节点</h1><p>React 中每个元素都具有一个 UI 上的表现，我们可以称作「视图」或者「模板」。例如我们示例中 <code>ClickCounter</code> 组件的模板就是：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.onClick&#125;&gt;Update counter&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure>
<h2 id="React-元素"><a href="#React-元素" class="headerlink" title="React 元素"></a>React 元素</h2><p>模板经过 JSX 编译器后，你就得到了一系列 React 元素，这些元素才是你真正在 React 组件中 <code>render</code> 方法返回的东西，而不是看起来的 HTML。由于 JSX 并不是非用不可的，<code>ClickCounter</code> 组件的 <code>render</code> 方法其实也可以重写成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  render() &#123;</span><br><span class="line">  	<span class="keyword">return</span> [</span><br><span class="line">      React.createElement(</span><br><span class="line">        <span class="string">'button'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          key: <span class="string">'1'</span>,</span><br><span class="line">          onClick: <span class="keyword">this</span>.onClick</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'Update counter'</span></span><br><span class="line">      ),</span><br><span class="line">      React.createElement(</span><br><span class="line">        <span class="string">'span'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          key: <span class="string">'2'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">this</span>.state.count</span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>render</code> 方法中调用的  <code>React.createElement</code> 函数将会创建一个这样的数据结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">    type: <span class="string">'button'</span>,</span><br><span class="line">    key: <span class="string">"1"</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: <span class="string">'Update counter'</span>,</span><br><span class="line">      onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">    type: <span class="string">'span'</span>,</span><br><span class="line">    key: <span class="string">"2"</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: <span class="number">0</span></span><br><span class="line">  	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可以看到，React 给这些对象加上了 <code>$$typeof</code> 属性来将其标记为 React 元素。接下来是用来描述一个元素 <code>type</code>、<code>key</code> 和 <code>props</code> 属性，它们的值取决于你传递给 <code>React.createElement</code> 方法的参数。请注意一下这里 React 会将字符串也作为 <code>span</code> 和 <code>button</code> 节点的子节点，而点击事件处理器则会被放置在 <code>button</code> 的 props 中。React 元素还会有一些字段如 <code>ref</code>，但是他们与这篇文章讨论的范畴无关。</p>
<p><code>ClickCounter</code> 对应的 React 元素没有任何 props 或 key：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">  key: <span class="literal">null</span>,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  ref: <span class="literal">null</span>,</span><br><span class="line">  type: ClickCounter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Fiber-节点"><a href="#Fiber-节点" class="headerlink" title="Fiber 节点"></a>Fiber 节点</h2><p>在<strong>协调</strong>的过程中，每个 React 元素的 <code>render</code> 方法返回的数据会被合并至 Fiber 节点树，每个 React 元素都有一个与之对应的 Fiber 节点。与 React 元素不同的是，Fiber 并不是每次渲染都会重新生成，它们是保存着组件状态和 DOM 的可变数据结构。</p>
<p>前边我们说到过，React 元素类型的不同会导致 React 需要进行不同的操作。在我们的示例中，类组件 <code>ClickCounter</code> 会被调用生命周期方法和 <code>render</code> 方法；然而对于 <code>span</code> 这种宿主节点（DOM 节点），React 则会进行 DOM 的更新。所以每个 React 元素都会被转化成<a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js" target="_blank" rel="noopener">对应类型</a>的 Fiber 节点，后者会描述需要进行的事务。</p>
<p><strong>你可以认为 Fiber 节点就是一种代表需要进行的事务的数据结构，换言之也就是事务的最小单位。Fiber 架构同时还使得跟踪、安排、暂停和终止事务变得简单。</strong></p>
<p>当一个 React 元素第一次被转换成一个 Fiber 节点的时候，React 会通过 <a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L414" target="_blank" rel="noopener"><code>createFiberFromTypeAndProps</code></a> 函数来使用元素的信息来生成 Fiber 节点。在同步更新中，React 会重复使用 Fiber 节点，并根据与之相关的 React 元素上的数据来更新必要的属性。根据 <code>key</code> 属性，React 还可能会改变节点的层级。如果一个元素不再被 <code>render</code> 方法返回，React 会删除它。</p>
<blockquote>
<p>请参阅 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactChildFiber.js#L239" target="_blank" rel="noopener"><code>ChildReconciler</code></a> 函数，它会列出所有的操作类型，以及对应的 React 会对 Fiber 节点进行的操作。</p>
</blockquote>
<p>由于 React 会为每个 React 元素都创建 Fiber 节点，且这些元素构成一棵树，我们会得到一棵树状结构的 Fiber 节点。譬如在我们的示例中，这棵树会像这样：</p>
<p><img src="./fiber-tree.png" alt></p>
<p>通过 <code>child</code>、<code>sibling</code> 和 <code>return</code> 属性，所有 Fiber 节点会通过一个链表连接在一起。请参阅我的文章<a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">《React 在 Fiber 中使用链表的原因和方法》</a>来了解为什么要这么设计。</p>
<h2 id="Current-树和-workInProgress-树"><a href="#Current-树和-workInProgress-树" class="headerlink" title="Current 树和 workInProgress 树"></a>Current 树和 workInProgress 树</h2><p>初次渲染完成后，React 会得到一棵代表当前 app 状态的树，并据此渲染 UI。我们通常把这棵树称作「<strong>current</strong>」。当 React 开始更新的时候，它会创建一棵名叫「<strong>workInProgress</strong>」的树，这棵树反映了用来刷新 UI 的新状态。</p>
<p>所有对 Fiber 进行的操作都来自于 <code>workInProgress</code> 树。当 React 遍历  <code>current</code> 树的时候，对于每个 Fiber 节点，React 会创建一个新的节点（alternate），由这些 alternate 形成 <code>workInProgress</code> 树。新的节点使用 React 元素 <code>render</code> 方法返回的数据创建。在更新完成，所有的事务都结束后，React 会得到一棵 alternate 树，并可以刷新 UI。当 <code>workInProgress</code> 被渲染到屏幕，它就会取代先前的树，成为新的 <code>current</code> 树。</p>
<p>React 的核心原则之一是连贯性。React 总是会一次性地更新 DOM，而不会仅渲染部分结果。<code>workInProgress</code> 树充当的就是一个不会对用户展示的「草稿」，所以 React 可以先处理所有的节点，再把所有的变更刷新到屏幕。</p>
<p>在源码中，你可以找多从 <code>current</code> 和 <code>workInProgress</code> 树获取 Fiber 节点的函数，比如其中一个的函数签名如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>每个 Fiber 节点都在 <strong>alternate</strong> 字段中保存着另一棵树中它的副本： <code>current</code> 树中的指向 <code>workInProgress</code> 树中的，反之亦然。</p>
<h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>我们可以把 React 组件都想象成函数，他们接收 state 和 props，并计算出对应的 UI 的描述。由此，任何其他的操作，如操作 DOM 或调用生命周期方法都可以看作副作用，简称作用。<a href="https://reactjs.org/docs/hooks-overview.html#effect-hook" target="_blank" rel="noopener">副作用</a>在文档中是这么描述的：</p>
<blockquote>
<p>你之前可能已经在 React 组件中执行过数据获取、订阅或者手动<strong>修改过 DOM</strong>。我们统一把这些操作称为“副作用”，或者简称为“作用”。</p>
</blockquote>
<p>由此可以看出大多数 state 和 props 的更新都会导致副作用的产生。由于实施副作用也是一种事务，Fiber 是追踪除了更新以外的副作用的一种很有力机制。每个 Fiber 节点都可以和副作用相关联，存储在 <code>effectTag</code> 字段中。</p>
<p>所以，Fiber 中的副作用定义了更新完成后示例们需要进行的<strong><a href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js" target="_blank" rel="noopener">事务</a></strong>。对于宿主节点（DOM 元素），事务包括添加、更新和删除元素。对于类组件，React 可能需要更新 refs 并调用 <code>componentDidMount</code> 以及 <code>componentDidUpdate</code> 等生命周期方法。其他的 Fiber 节点也都有它们对应的副作用。</p>
<h2 id="副作用链表"><a href="#副作用链表" class="headerlink" title="副作用链表"></a>副作用链表</h2><p>React 处理更新的速度极快，为了达到这样的性能，它采用了许多很有趣的技术。<strong>其中之一便是构造一个带有副作用的 Fiber 节点组成的线形表，以此加快遍历速度。</strong>遍历一个线形表要比遍历一棵树快多了，而且这样（只有带副作用的 Fiber 节点才在链表中）可以避免在没有副作用的节点上浪费时间。</p>
<p>这个链表的目的是标记所有需要更新 DOM 或其他副作用的节点。它是 <code>finishedWork</code> 树的子集，它使用 <code>current</code> 和 <code>workInProgress</code> 树节点中的 <code>nextEffect</code> 属性而不是 <code>child</code> 属性来做为指针。</p>
<p><a href="https://medium.com/u/a3a8af6addc1" target="_blank" rel="noopener">Dan Abramov</a> 给出了一个副作用链表的比喻，他喜欢把它比作一棵圣诞树，树上挂小灯的电线把所有有副作用的节点都连在了一起。为了可视化这一过程，我们想象一下以下这棵 Fiber 节点树，其中桔红色的节点是有事务的。比如，我们的更新使得 <code>c2</code> 需要插入至 DOM，<code>d2</code> 和 <code>c1</code> 需要更新属性，<code>b2</code> 需要调用生命周期方法。副作用链表会将它们连在一起，因此 React 稍后可以跳过其他节点。</p>
<p><img src="./effect-link-in-tree.png" alt></p>
<p>你现在知道带有副作用的节点是如何构成链表的了，当遍历节点的时候，React 会通过 <code>firstEffect</code> 指针来找出链表的第一个元素。因此上图可以像下图一样表示成一个线形表：</p>
<p><img src="./effect-link.png" alt></p>
<p>你可以看到，React 会依照先子节点再夫节点的顺序实施副作用。</p>
<h2 id="Fiber-树的根"><a href="#Fiber-树的根" class="headerlink" title="Fiber 树的根"></a>Fiber 树的根</h2><p>每一个 React 都有一个或多个 DOM 元素作为容器。我们的示例中它是一个带有 <code>container</code> ID 的  <code>div</code> 元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> domContainer = <span class="built_in">document</span>.querySelector(<span class="string">'#container'</span>);</span><br><span class="line">ReactDOM.render(React.createElement(ClickCounter), domContainer);</span><br></pre></td></tr></table></figure>
<p>React 会为每个容器创建一个 <a href="https://github.com/facebook/react/blob/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74/packages/react-reconciler/src/ReactFiberRoot.js#L31" target="_blank" rel="noopener"><code>fiberRoot</code></a> 元素，你可以通过对 DOM 元素的引用来访问它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fiberRoot = query(<span class="string">'#container'</span>)._reactRootContainer._internalRoot</span><br></pre></td></tr></table></figure>
<p>这个 Fiber Root 就是 React 保存对 Fiber 树的引用的地方。它保存在 Fiber Root 的 <code>current</code> 属性中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hostRootFiberNode = fiberRoot.current</span><br></pre></td></tr></table></figure>
<p>Fiber 树的根是一个具有<a href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/shared/ReactWorkTags.js#L34" target="_blank" rel="noopener">特殊类型</a> <code>HostRoot</code> 的 Fiber 节点，React 会在内部创建它，并把它作为你最顶层组件的父节点。可以通过 <code>stateNode</code> 属性从 <code>HostRoot</code> 节点回到 <code>FiberRoot</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiberRoot.current.stateNode === fiberRoot; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>你可以从访问最顶层的 <code>HostRoot</code> 开始探索整棵 Fiber 树，或者你也可以像从一个组件实例获取一个单独的节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compInstance._reactInternalFiber</span><br></pre></td></tr></table></figure>
<h2 id="Fiber-节点的结构"><a href="#Fiber-节点的结构" class="headerlink" title="Fiber 节点的结构"></a>Fiber 节点的结构</h2><p>现在，我们来看看 <code>ClickCounter</code> 组件产出的 Fiber 节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  stateNode: <span class="keyword">new</span> ClickCounter,</span><br><span class="line">  type: ClickCounter,</span><br><span class="line">  alternate: <span class="literal">null</span>,</span><br><span class="line">  key: <span class="literal">null</span>,</span><br><span class="line">  updateQueue: <span class="literal">null</span>,</span><br><span class="line">  memoizedState: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  pendingProps: &#123;&#125;,</span><br><span class="line">  memoizedProps: &#123;&#125;,</span><br><span class="line">  tag: <span class="number">1</span>,</span><br><span class="line">  effectTag: <span class="number">0</span>,</span><br><span class="line">  nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及 DOM 元素 <code>span</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">  type: <span class="string">"span"</span>,</span><br><span class="line">  alternate: <span class="literal">null</span>,</span><br><span class="line">  key: <span class="string">"2"</span>,</span><br><span class="line">  updateQueue: <span class="literal">null</span>,</span><br><span class="line">  memoizedState: <span class="literal">null</span>,</span><br><span class="line">  pendingProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  memoizedProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  tag: <span class="number">5</span>,</span><br><span class="line">  effectTag: <span class="number">0</span>,</span><br><span class="line">  nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fiber节点中有许许多多的字段，前边我已经解释过 <code>alternate</code>、<code>effectTag</code> 和 <code>nextEffect</code> 的作用了。我们来看看其他的：</p>
<ul>
<li><code>stateNode</code> 保存着对 Fiber 节点对应的组件实例、DOM 节点或其他 React 元素的引用。通常我们认为这个属性保存了 Fiber 对应的本地状态；</li>
<li><code>type</code>定义了 Fiber 对应的函数或类。对于类组件，它指向构造函数；对于 DOM 元素，它是 HTML 标签。我经常用这个字段来确定一个 Fiber 节点对应的元素。</li>
<li><code>tag</code> 定义了 <a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js" target="_blank" rel="noopener">Fiber 的类型</a>。在协调算法中，它被用于确定需要完成的事务是什么。上面说到过，不同的 React 元素会对应不同的事务。<a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L414" target="_blank" rel="noopener"><code>createFiberFromTypeAndProps</code></a> 函数会把一个 React 元素映射成对应的 Fiber 节点。在我们的示例 app 中，<code>ClickCounter</code> 的 <code>tag</code> 属性的值是 <code>1</code>，代表 <code>ClassComponent</code>；而 <code>span</code>元素则是 <code>5</code>，代表 <code>HostComponent</code>。</li>
<li><code>updateQueue</code> 是一个状态更新、回调函数和 DOM 更新组成的队列；</li>
<li><code>memoizedState</code> 是 Fiber 上一次渲染中用来创建输出的 state，当触发更新时，它代表着当前 UI 显示着的 state；</li>
<li><code>memoizedProps</code> 则是 Fiber 上一次渲染中用来创建输出的 props；</li>
<li><code>pendingProps</code> 是 React 元素已经完成更新后新的数据产生的 props，它会被应用于子组件或 DOM 元素；</li>
<li><code>key</code> 是一个唯一的标识符，用于让 React 分辨哪些元素发生了变化（从列表中增加或删除）。它与 React 的列表渲染有关，请参阅<a href="https://reactjs.org/docs/lists-and-keys.html#keys" target="_blank" rel="noopener">这里</a>。</li>
</ul>
<p>你可以在<a href="https://github.com/facebook/react/blob/6e4f7c788603dac7fccd227a4852c110b072fe16/packages/react-reconciler/src/ReactFiber.js#L78" target="_blank" rel="noopener">这里</a>找到完整的 Fiber 节点的结构。我删掉了许多前文已经提到过的字段，跳过了<a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">上一篇文章中说过的</a>用于组成树状结构的 <code>child</code>, <code>sibling</code> 和 <code>return</code> 字段，一些 <code>Scheduler</code> 专用的字段如 <code>expirationTime</code>、<code>childExpirationTime</code> 和 <code>mode</code> 也没有被提及。</p>
<h1 id="算法概况"><a href="#算法概况" class="headerlink" title="算法概况"></a>算法概况</h1><p>React 的事务执行过程分为两个部分：<strong>渲染（render）</strong>和<strong>提交（commit）</strong>。</p>
<p>在第一个阶段 <code>render</code> 中，React 会把更新应用于通过 <code>setState</code> 或 <code>React.render</code> 排好期的组件，并分析出 UI 中需要更新的部分。如果是初次渲染，React 会为 <code>render</code> 方法返回的每个元素都创建一个新的 Fiber 节点。在接下来的更新中，已经存在的 React 元素的 Fiber 将会被复用并更新。<strong>这一阶段的结果是由标记了副作用的 Fiber 节点构成的一棵树。</strong>这些副作用描述了在接下来的 <code>commit</code> 阶段需要进行的事务。在这一阶段中，React 会把接收标有副作用的 Fiber 树，并把它应用到实例上。React 会遍历副作用链表，并把 DOM 更新等操作呈现给用户。</p>
<p><strong>有一件事很重要：在第一阶段过程 <code>render</code> 中的事务是可以异步执行的。</strong>React 可以根据可用时间的多少，在处理一个完或多个 Fiber 节点后停下来，暂存已经完成的事务，并发送一些事件，然后再从刚刚停下的地方继续。虽然有的时候它还是需要舍弃之前的结果然后从头再来。这种暂停得以实现的原因是，实施这些事务并没有产生类似于 DOM 更新之类的任何用户可见的更改。<strong>相反地，下一个阶段 <code>commit</code> 永远是同步执行的</strong>。这是因为这一阶段产生的结果对用户是可见的，比如更新 DOM，所以 React 需要将其一次性做完。</p>
<p>调用生命周期方法是 React 需要执行的事务之一。有些方式是在  <code>render</code> 阶段执行的，而有些则是在 <code>commit</code>阶段。在第一阶段 <code>render</code> 中会被调用的方法有：</p>
<ul>
<li><code>[UNSAFE_]componentWillMount</code> (已废弃)</li>
<li><code>[UNSAFE_]componentWillReceiveProps</code> (已废弃)</li>
<li><code>getDerivedStateFromProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>[UNSAFE_]componentWillUpdate</code> (已废弃)</li>
<li><code>render</code></li>
</ul>
<p>如你所见，自 v16.3 开始，有些历史遗留的 <code>render</code> 阶段生命周期方法被标记了 <code>UNSAFE</code>，在文档中它们被称作历史遗留生命周期方法。他们会在将来的某个 16.x 发布中被废弃，而它们没有 <code>UNSAFE</code> 的副本也将在 17.0 中被移除。你可以在<a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">这里</a>了解到这些变更以及推荐的迁移路径。</p>
<p>你对这种变更的原因感到困惑吗？</p>
<p>好吧，我们刚刚说到 <code>render</code> 阶段并不产生如更新 DOM 的副作用，因此 React 可以异步地处理组件的更新（甚至在多个线程中完成）。然而，标记为  <code>UNSAFE</code> 的生命周期方法常常被误解和轻微地误用。开发者们倾向于把带有副作用的代码放置于这些方法中，这会导致全新的异步渲染实现产生问题。尽管只是没有 <code>UNSAFE</code> 的副本会被移除，这些方法仍可能在即将退出的的并发模式中导致问题（不过你可以选择不用这种模式）。</p>
<p>以下列表为会在 <code>commit</code> 阶段被调用的方法：</p>
<ul>
<li><code>getSnapshotBeforeUpdate</code></li>
<li><code>componentDidMount</code></li>
<li><code>componentDidUpdate</code></li>
<li><code>componentWillUnmount</code></li>
</ul>
<p>因为这些方法会在同步的 <code>commit</code> 阶段被调用，它们可以包含副作用，以及操作 DOM。</p>
<p>好的，现在我们已经了解完了背景，并看完了遍历树和实施事务的算法的基本概况，是时候继续深究了。</p>
<h1 id="Render-阶段"><a href="#Render-阶段" class="headerlink" title="Render 阶段"></a>Render 阶段</h1><p>协调算法始终会通过调用 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1132" target="_blank" rel="noopener">renderRoot</a> 函数，从最顶层的 <code>HostRoot</code> Fiber 节点开始。然而，React 会跳过已经处理过的 Fiber 节点，直到它找到了还有尚未完成事务的节点。例如，如果你在组件树的较深位置调用了 <code>setState</code>，React 将还是从顶开始，不过会快速地跳过各个父组件，直到它找到了 <code>setState</code> 被调用的那个组件。</p>
<h2 id="事务循环的主要流程"><a href="#事务循环的主要流程" class="headerlink" title="事务循环的主要流程"></a>事务循环的主要流程</h2><p>所有节点都在<a href="https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js#L1136" target="_blank" rel="noopener">事务循环中</a>被处理，以下是同步版的事务循环的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">isYieldy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上的代码中，<code>nextUnitOfWork</code> 引用着 <code>workInProgress</code> 树中带有事务的 Fiber 节点。React 取回 Fiber 树时，它会使用这个变量来检查是否还有其他带有未完成事务的 Fiber 节点。这个过程结束后，这个变量要不然是下一个 Fiber 节点，要不然就是 <code>null</code>，若是后者，React 就会退出事务循环，并可以提交这些改动了。</p>
<p>React 中主要有 4 个函数用来取回整棵树和完成事务：</p>
<ul>
<li><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1056" target="_blank" rel="noopener"><code>performUnitOfWork</code></a></li>
<li><a href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L1489" target="_blank" rel="noopener"><code>beginWork</code></a></li>
<li><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L879" target="_blank" rel="noopener"><code>completeUnitOfWork</code></a></li>
<li><a href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js#L532" target="_blank" rel="noopener"><code>completeWork</code></a></li>
</ul>
<p>为了演示它们的工作方法，请看一下下边这个动图，它描述了取回 Fiber 树的过程。出于演示的目的，我在这儿使用的是这些函数的简化版本实现，每个函数接收并处理一个 Fiber 节点。React 向下处理的过程中，你可以看到活动的 Fiber 节点也发生了变化。在动图中可以很清楚地看这个算法是如何从一棵子树跳到另一棵的：它会先完成事务，再返回父节点。</p>
<p><img src="./algo.gif" alt></p>
<blockquote>
<p>备注：竖直方向的连线代表的是兄弟节点，而拐弯的连线代表父子。例如 <code>b1</code> 没有子节点，而 <code>b2</code> 有一个子节点 <code>c1</code>。</p>
</blockquote>
<p>上面的动图<a href="https://vimeo.com/302222454" target="_blank" rel="noopener">在这儿有一个视频版本</a>，以便你暂停和回放，并观察当前节点和函数的状态。理论上，你可以把 <code>beginWork</code> 想象成「进入」一个组件，而 <code>completeWork</code> 就是「退出」了。你可以<a href="https://stackblitz.com/edit/js-ntqfil?file=index.js" target="_blank" rel="noopener">在这里玩一玩示例实现</a>。</p>
<p>让我们从前两个函数 <code>performUnitOfWork</code> 和 <code>beginWork</code> 开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = beginWork(workInProgress);</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'work performed for '</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>performUnitOfWork</code> 是 Fiber 中所有操作开始的地方，它接收一个 <code>workInProgress</code> 树中的 Fiber 节点，并通过调用 <code>beginWork</code> 函数来开始事务。为了演示，我们此处就简单地把 Fiber 的名字 log 出来，然后标记这个节点为事务已完成。<strong><code>beginWork</code> 函数始终会返回循环中下一个待处理的节点或 <code>null</code></strong>。</p>
<p>如果下一个子节点存在，它会在 <code>workLoop</code> 函数中被赋值给 <code>nextUnitOfWork</code> 变量。然而，如果没有子节点，React 就知道它已经到达了子树的底端，因此可以完成对这个节点的操作。<strong>在这个节点完成后，React 会操作它的兄弟节点，并返回其父节点。</strong>这些工作是在 <code>completeUnitOfWork</code> 函数中完成的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> returnFiber = workInProgress.return;</span><br><span class="line">    <span class="keyword">let</span> siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">    nextUnitOfWork = completeWork(workInProgress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果存在兄弟节点，会将它返回以对它进行操作</span></span><br><span class="line">      <span class="keyword">return</span> siblingFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果 `returnFiber` 中没有更多事务了，会返回循环并完成父节点</span></span><br><span class="line">      workInProgress = returnFiber;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 到顶了！</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'work completed for '</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个函数的主旨就是一个大大的 <code>while</code> 循环。<code>workInProgress</code> 中的节点没有子节点的时候，React 就会进入这个函数。</p>
<p>在当前 Fiber 的事务结束后，React 会检查它是否有兄弟节点，如果有，React 会退出函数，并把兄弟节点返回。这个兄弟节点会被赋值给 <code>nextUnitOfWork</code> 变量，React 会从这个兄弟节点开始实施事务。有一点很重要：此时此刻 React 仅仅完成了先前兄弟节点的事务，它还没有对父节点实施事务。<strong>只有从子节点开始的当所有分支都结束了，它才会开始完成父节点的事务，并原路返回。</strong></p>
<p>从实现中可以发现，<code>performUnitOfWork</code> 和 <code>completeUnitOfWork</code> 主要是用来进行迭代的，而真正的操作发生在 <code>beginWork</code> 和 <code>completeWork</code> 函数中。本系列的下一篇文章中我们将会了解 React 进入  <code>beginWork</code> 和 <code>completeWork</code> 函数的时候，<code>ClickCounter</code> 组件和 <code>span</code> 节点会发生什么。</p>
<h1 id="Commit-阶段"><a href="#Commit-阶段" class="headerlink" title="Commit 阶段"></a>Commit 阶段</h1><p>这一阶段从 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L2306" target="_blank" rel="noopener"><code>completeRoot</code></a>函数开始。这也是 React 更新 DOM，并调用挂载前后的生命周期方法的地方。</p>
<p>进入这一阶段时，React 会保存着两棵树和副作用链表。第一棵树代表着当前 UI 中的 state；第二棵则是 <code>render</code> 阶段中产生的 alternate 树，源码中叫做 <code>finishedWork</code> 或 <code>workInProgress</code> 树，代表着 UI 中需要渲染的 state。和 current 树一样，这棵 alternate 树也是由 <code>child</code> 和 <code>sibling</code> 指针连起来的。</p>
<p>接下来是副作用链表——通过 <code>nextEffect</code> 指针连起来的 <code>finishedWork</code> 树。请记住副作用链表是运行 <code>render</code> 阶段的<em>结果</em>，该链表的目的描述需要插入、更新或删除的节点，以及需要调用生命周期方法的组件。<strong>而这个链表中的节点就是 coomit 阶段中会被迭代的。</strong></p>
<blockquote>
<p>出于 debug 的目的，<code>current</code> 树可以从 <code>FiberRoot</code> 节点的 <code>current</code> 属性中访问到，<code>finishedWork</code> 树可以从 <code>HostFiber</code> 节点的 <code>alternate</code> 属性访问到。</p>
</blockquote>
<p>Commit 阶段的核心函数是 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L523" target="_blank" rel="noopener"><code>commitRoot</code></a>，它做的事情基本上是：</p>
<ul>
<li>在被标记了 <code>SnapShot</code> 副作用的节点上调用  <code>getSnapshotBeforeUpdate</code> 生命周期方法；</li>
<li>在被标记了 <code>Deletion</code> 副作用的节点上调用 <code>componentWillUnmount</code> 生命周期方法；</li>
<li>进行 DOM 的增删改；</li>
<li>把 <code>finishedWork</code> 树设置为新的 current 树；</li>
<li>在被标记了 <code>Placement</code> 副作用的节点上调用 <code>componentDidMount</code> 生命周期方法；</li>
<li>在被标记了 <code>Update</code> 副作用的节点上调用 <code>componentDidUpdate</code> 生命周期方法。</li>
</ul>
<p>在调用了挂载前生命周期函数 <code>getSnapshotBeforeUpdate</code> 后，React 会提交树中所有的副作用，这一步有两个阶段。第一阶段会执行所有的 DOM（宿主元素）的插入、更新、删除以及 ref 的卸载。然后 React 会把 <code>finishedWork</code> 树分配给 <code>FiberRoot</code>，并把 <code>workInProgress</code> 树标记为 <code>current</code> 树。这一过程是在第一次 commit 阶段完成后以及第二次 commit 完成前进行的，所以前一棵树还在进行 <code>componentWillUnmount</code>，而 <code>finishedWork</code> 树正在执行 <code>componentDidMount/Update</code>；第二阶段 React 会调用其他所有的生命周期方法，和 ref 回调。这些方法会分成好几轮，以确保所有的替换、更新和删除都顺利执行了。</p>
<p>下边是一个实现了上述过程主旨的函数实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root, finishedWork</span>) </span>&#123;</span><br><span class="line">  commitBeforeMutationLifecycles()</span><br><span class="line">  commitAllHostEffects();</span><br><span class="line">  root.current = finishedWork;</span><br><span class="line">  commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的每一个子函数都实现了一个循环，从而迭代副作用链表，并检测副作用的类型。当它找到与本函数有关的副作用的时候就会执行。</p>
<h2 id="挂载前生命周期方法"><a href="#挂载前生命周期方法" class="headerlink" title="挂载前生命周期方法"></a>挂载前生命周期方法</h2><p>下边是一个例子，其中的代码会对副作用树进行迭代并检测节点是否带有 <code>Spapshot</code> 副作用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifecycles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Snapshot) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitBeforeMutationLifeCycles(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个类组件，这个副作用意味着调用 <code>getSnapshotBeforeUpdate</code>。</p>
<h2 id="DOM-更新"><a href="#DOM-更新" class="headerlink" title="DOM 更新"></a>DOM 更新</h2><p><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376" target="_blank" rel="noopener"><code>commitAllHostEffects</code></a> 函数是 React 更新 DOM 的地方。这个函数基本上就是定义了需要进行的操作的种类，并执行之：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">    <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">      commitPlacement(nextEffect);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">      commitPlacement(nextEffect);</span><br><span class="line">      commitWork(current, nextEffect);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Update: &#123;</span><br><span class="line">      commitWork(current, nextEffect);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">      commitDeletion(nextEffect);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 会在 <code>commitDeletion</code> 函数中调用 <code>componentWillUnmount</code> 方法，这还怪好玩的。</p>
<h2 id="挂载后生命周期方法"><a href="#挂载后生命周期方法" class="headerlink" title="挂载后生命周期方法"></a>挂载后生命周期方法</h2><p><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L465" target="_blank" rel="noopener"><code>commitAllLifecycles</code></a> 是 React 调用所有剩余的生命周期函数的地方，如 <code>componentDidUpdate</code> 和 <code>componentDidMount</code>。</p>
<hr>
<p>终于结束了！如果你对这篇文章有任何问题，请在评论中写出。<strong>你也可以看看本系列的下一篇<a href="https://medium.com/react-in-depth/in-depth-explanation-of-state-and-props-update-in-react-51ab94563311" target="_blank" rel="noopener">《深入探索 React 的 state 和 props 更新机制》</a>。</strong>我还有许多关于调度器、子协调过程和副作用列表构建过程的文章正在写作中，我还有创作一个以这篇文章为基础的 debug 心得分享的视频。</p>
<p><strong>血都要获得更多信息，请在 <a href="https://twitter.com/maxkoretskyi" target="_blank" rel="noopener">Twitter</a> 和 <a href="https://medium.com/@maxim.koretskyi" target="_blank" rel="noopener">Medium</a> 关注我。感谢你的阅读！如果你喜欢这篇文章，请给我点个鼓掌 👏。这对我大有帮助，而且可以让更多的人看到这篇文章。</strong></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/blog/">首页</a></li>
         
          <li><a href="/blog/archives/">归档</a></li>
         
          <li><a href="https://sr2k.top">简历</a></li>
         
          <li><a href="http://github.com/SR2k">项目</a></li>
         
          <li><a href="/blog/tags/">tags</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从-React-元素到-Fiber-节点"><span class="toc-number">2.</span> <span class="toc-text">从 React 元素到 Fiber 节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#React-元素"><span class="toc-number">2.1.</span> <span class="toc-text">React 元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber-节点"><span class="toc-number">2.2.</span> <span class="toc-text">Fiber 节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Current-树和-workInProgress-树"><span class="toc-number">2.3.</span> <span class="toc-text">Current 树和 workInProgress 树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#副作用"><span class="toc-number">2.4.</span> <span class="toc-text">副作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#副作用链表"><span class="toc-number">2.5.</span> <span class="toc-text">副作用链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber-树的根"><span class="toc-number">2.6.</span> <span class="toc-text">Fiber 树的根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber-节点的结构"><span class="toc-number">2.7.</span> <span class="toc-text">Fiber 节点的结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算法概况"><span class="toc-number">3.</span> <span class="toc-text">算法概况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Render-阶段"><span class="toc-number">4.</span> <span class="toc-text">Render 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事务循环的主要流程"><span class="toc-number">4.1.</span> <span class="toc-text">事务循环的主要流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Commit-阶段"><span class="toc-number">5.</span> <span class="toc-text">Commit 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#挂载前生命周期方法"><span class="toc-number">5.1.</span> <span class="toc-text">挂载前生命周期方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-更新"><span class="toc-number">5.2.</span> <span class="toc-text">DOM 更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#挂载后生命周期方法"><span class="toc-number">5.3.</span> <span class="toc-text">挂载后生命周期方法</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&text=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&is_video=false&description=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【译】Fiber：深入了解 React 的全新调度算法&body=Check out this article: https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&title=【译】Fiber：深入了解 React 的全新调度算法"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/&name=【译】Fiber：深入了解 React 的全新调度算法&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Siyuan Cao
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/blog/">首页</a></li>
         
          <li><a href="/blog/archives/">归档</a></li>
         
          <li><a href="https://sr2k.top">简历</a></li>
         
          <li><a href="http://github.com/SR2k">项目</a></li>
         
          <li><a href="/blog/tags/">tags</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/blog/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/blog/lib/jquery/jquery.min.js"></script>
<script src="/blog/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/blog/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/blog/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-90173601-3', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
