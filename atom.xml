<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SR2k</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://sr2k.top/blog/"/>
  <updated>2019-08-23T05:07:00.150Z</updated>
  <id>https://sr2k.top/blog/</id>
  
  <author>
    <name>Siyuan Cao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>备战秋招</title>
    <link href="https://sr2k.top/blog/2019/08/22/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/"/>
    <id>https://sr2k.top/blog/2019/08/22/备战秋招/</id>
    <published>2019-08-22T01:58:14.000Z</published>
    <updated>2019-08-23T05:07:00.150Z</updated>
    
    <content type="html"><![CDATA[<p>这大概是一份问题列表，用来记录在面试中遇到的问题和现在能想到/找到的答案（或者先记录问题，答案等慢慢填坑）。</p><h1 id="JS-类问题"><a href="#JS-类问题" class="headerlink" title="JS 类问题"></a>JS 类问题</h1><h2 id="原型链是什么-amp-ES6-class"><a href="#原型链是什么-amp-ES6-class" class="headerlink" title="原型链是什么 &amp; ES6 class"></a>原型链是什么 &amp; ES6 class</h2><p>JavaScript 中的继承和传统意义上的面向对象语言有很大的不同，在 JavaScript 中，每个 function 就是一个“类”，搭配 <code>new</code> 操作符即可用来新建对象，new 出来的对象就是这个函数的实例，函数就是 new 出来对象的构造器，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'Xiaoming'</span>, <span class="number">22</span>)</span><br><span class="line"><span class="comment">// xiaoming 是 Student 的实例</span></span><br><span class="line"><span class="comment">// Student 是小明的构造器</span></span><br></pre></td></tr></table></figure><p>每一个 function 都有着一个 <code>prototype</code> 的属性，我们称之为“原型”，当我们调用某个对象的属性时，JS 引擎会优先查找对象本身有没有这个属性，如果没有，则会在原型中查找：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xiaoming.sayHi()</span><br><span class="line"><span class="comment">// Hi, my name is Xiaoming!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// xiaoming 自身只有 name 和 age 两个属性，但仍旧可以调用 sayHi，</span></span><br><span class="line"><span class="comment">// 这是因为其构造器的原型上有这个方法</span></span><br></pre></td></tr></table></figure><p>由于 <code>prototype</code> 本身也是一个对象，它也有自己的构造器，那么也就是说，如果我们调用了一个原型上没有的属性或方法，JS 引擎会继续去查找原型的构造器的原型，直到原型对象没有构造器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.toString()</span><br><span class="line"><span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们并没有定义过 toString 方法，但是仍可以调用，这里的调用链是：</span></span><br><span class="line"><span class="comment">// xiaoming -&gt; Student.prototype -&gt; Object.prototype</span></span><br></pre></td></tr></table></figure><p>可以看到，这些原型像一条链子一样串了起来，这种实现继承的模式我们称之为“原型链”。</p><p>如果我们需要覆盖原型链上的方法（即类似于其他语言中的 override），调用链之前的任何地方使用相同的键名创建属性，既可避免 JS 引擎向上查找原型链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.toString()</span><br><span class="line"><span class="comment">// "&#123;"name":"xiaoming","age":22&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 Student.prototype 上已经有了 toString，JS 引擎不会再去查找 Object.prototype</span></span><br></pre></td></tr></table></figure><p>ES6 的 class 本质上就是原型链继承模式的语法糖，如以下 ES6 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    Person.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getCount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`There are <span class="subst">$&#123;Person.count&#125;</span> person(people) right now`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, school) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age)</span><br><span class="line">    <span class="keyword">this</span>.school = school</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  Person.count++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Person.prototype.sayH = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.getCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`There are <span class="subst">$&#123;Person.count&#125;</span> person(people) right now`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, school</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.school = school</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.__proto__ = Person</span><br></pre></td></tr></table></figure><h2 id="闭包是什么、用处、使用"><a href="#闭包是什么、用处、使用" class="headerlink" title="闭包是什么、用处、使用"></a>闭包是什么、用处、使用</h2><h2 id="JS-运行时的垃圾回收机制"><a href="#JS-运行时的垃圾回收机制" class="headerlink" title="JS 运行时的垃圾回收机制"></a>JS 运行时的垃圾回收机制</h2><h2 id="this-连环问"><a href="#this-连环问" class="headerlink" title="this 连环问"></a><code>this</code> 连环问</h2><h2 id="事件循环-amp-手写输出结果"><a href="#事件循环-amp-手写输出结果" class="headerlink" title="事件循环 &amp; 手写输出结果"></a>事件循环 &amp; 手写输出结果</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="从按下回车到页面渲染之间发生的事情"><a href="#从按下回车到页面渲染之间发生的事情" class="headerlink" title="从按下回车到页面渲染之间发生的事情"></a>从按下回车到页面渲染之间发生的事情</h2><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h2 id="304-及缓存机制"><a href="#304-及缓存机制" class="headerlink" title="304 及缓存机制"></a>304 及缓存机制</h2><h1 id="常用-utils、polyfill-类问题"><a href="#常用-utils、polyfill-类问题" class="headerlink" title="常用 utils、polyfill 类问题"></a>常用 utils、polyfill 类问题</h1><h2 id="深拷贝的方法-amp-手写实现"><a href="#深拷贝的方法-amp-手写实现" class="headerlink" title="深拷贝的方法 &amp; 手写实现"></a>深拷贝的方法 &amp; 手写实现</h2><h2 id="防抖节流是什么-amp-手写实现"><a href="#防抖节流是什么-amp-手写实现" class="headerlink" title="防抖节流是什么 &amp; 手写实现"></a>防抖节流是什么 &amp; 手写实现</h2><p>防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p><p>如下，持续触发 scroll 事件时，并不执行 handle 函数，当 1000 毫秒内没有触发 scroll 事件时，才会延时触发 scroll 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout !== <span class="literal">null</span>)</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(fn, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><p>节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。</p><p>如下，持续触发 scroll 事件时，并不立即执行 handle 函数，每隔 1000 毫秒才会执行一次 handle 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt;= delay) &#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><h2 id="Promise-是什么-amp-手写简单实现"><a href="#Promise-是什么-amp-手写简单实现" class="headerlink" title="Promise 是什么 &amp; 手写简单实现"></a>Promise 是什么 &amp; 手写简单实现</h2><h2 id="JSONP-的简单实现"><a href="#JSONP-的简单实现" class="headerlink" title="JSONP 的简单实现"></a>JSONP 的简单实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对请求data进行格式化处理</span></span><br><span class="line"><span class="keyword">const</span> formateData = (data: <span class="built_in">Object</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="comment">// 避免有 &amp;=? 字符，对这些字符进行序列化</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    arr.push(<span class="string">`<span class="subst">$&#123;encodeURIComponent(key)&#125;</span>=<span class="subst">$&#123;data[key]&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域jsonp请求</span></span><br><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">param</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; data = &#123;&#125;, callbackName, onSuccess, onError, url, timeout &#125; = param;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> head = <span class="built_in">document</span>.querySelector(<span class="string">"head"</span>);</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  data[<span class="string">"callback"</span>] = callbackName;</span><br><span class="line">  <span class="keyword">const</span> _data = formateData(data);</span><br><span class="line">  script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;_data&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timer: <span class="built_in">number</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span>(<span class="params">jsonData</span>) </span>&#123;</span><br><span class="line">    head.removeChild(script);</span><br><span class="line">    timer != <span class="literal">null</span> &amp;&amp; clearTimeout(timer);</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">window</span>[callbackName] = <span class="literal">null</span>;</span><br><span class="line">    onSuccess &amp;&amp; onSuccess(jsonData);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>[callbackName] = <span class="literal">null</span>;</span><br><span class="line">      head.removeChild(script);</span><br><span class="line">      onError &amp;&amp; onError(&#123; message: <span class="string">"请求超时"</span> &#125;);</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//往head元素插入script元素，这个时候，script就插入文档中了，请求并加载src</span></span><br><span class="line">  head.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原生-AJAX-的简单实现"><a href="#原生-AJAX-的简单实现" class="headerlink" title="原生 AJAX 的简单实现"></a>原生 AJAX 的简单实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对请求data进行格式化处理</span></span><br><span class="line"><span class="keyword">const</span> formateData = (data: <span class="built_in">Object</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="comment">// 避免有 &amp;=? 字符，对这些字符进行序列化</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    arr.push(<span class="string">`<span class="subst">$&#123;encodeURIComponent(key)&#125;</span>=<span class="subst">$&#123;data[key]&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IAjaxParams&lt;T&gt; &#123;</span><br><span class="line">  data: <span class="built_in">Object</span>;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  onSuccess: <span class="function">(<span class="params">T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onError: <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>&lt;<span class="title">T</span>&gt;(<span class="params">params: IAjaxParams&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先对params进行处理，防止为空</span></span><br><span class="line">  <span class="keyword">const</span> &#123; data = &#123;&#125;, <span class="keyword">type</span> = <span class="string">'GET'</span>, url, onSuccess, onError &#125; = params;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通GET,POST请求</span></span><br><span class="line">  <span class="keyword">const</span> _type = <span class="keyword">type</span>.toUpperCase();</span><br><span class="line">  <span class="keyword">const</span> _data = formateData(data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_type === <span class="string">'GET'</span>) &#123;</span><br><span class="line">    xhr.open(_type, <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;_data&#125;</span>`</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    xhr.open(_type, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">    xhr.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; readyState, status, responseText &#125; = xhr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) || status === <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> res;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (onSuccess &amp;&amp; onSuccess <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">          res = <span class="built_in">JSON</span>.parse(responseText);</span><br><span class="line">          onSuccess.call(xhr, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (onError &amp;&amp; onError <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">          onError.call(xhr, <span class="keyword">new</span> <span class="built_in">Error</span>(responseText));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>XMLHttpRequest.readyState</code> 的值：</p><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">状态</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">UNSENT</td><td style="text-align:center">代理被创建，但尚未调用 <code>open()</code> 方法</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">OPENED</td><td style="text-align:center"><code>open()</code> 方法已经被调用</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">HEADERS_RECEIVED</td><td style="text-align:center"><code>send()</code> 方法已经被调用，并且头部和状态已经可获得</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">LOADING</td><td style="text-align:center">下载中，<code>responseText</code> 属性已经包含部分数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">DONE</td><td style="text-align:center">下载操作已完成</td></tr></tbody></table><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h1 id="框架类问题"><a href="#框架类问题" class="headerlink" title="框架类问题"></a>框架类问题</h1><h2 id="虚拟-DOM-是什么、为什么、优缺点"><a href="#虚拟-DOM-是什么、为什么、优缺点" class="headerlink" title="虚拟 DOM 是什么、为什么、优缺点"></a>虚拟 DOM 是什么、为什么、优缺点</h2><h2 id="diff-算法是什么、为什么、优缺点"><a href="#diff-算法是什么、为什么、优缺点" class="headerlink" title="diff 算法是什么、为什么、优缺点"></a>diff 算法是什么、为什么、优缺点</h2><h1 id="前端小技巧类问题"><a href="#前端小技巧类问题" class="headerlink" title="前端小技巧类问题"></a>前端小技巧类问题</h1><h2 id="跨域是什么-amp-解决"><a href="#跨域是什么-amp-解决" class="headerlink" title="跨域是什么 &amp; 解决"></a>跨域是什么 &amp; 解决</h2><p>是什么 todo</p><ul><li>JSONP</li><li>domain</li><li>后台的 CORS HTTP Header</li><li>Nginx 或其他服务端反向代理</li><li>iframe</li></ul><h2 id="常见性能优化"><a href="#常见性能优化" class="headerlink" title="常见性能优化"></a>常见性能优化</h2><ul><li>图片压缩，减小体积；大尺寸的简单图形可使用 SVG</li><li>使用 CSS Sprite、SVG Sprite、 BASE64、打包等，将多个零散文件合并成一个，减少 HTTP 请求；如果对 HTTP/2 比较熟的话还可以加一句或使用 HTTP/2，否则别提了免得被追问</li><li>静态资源部署在 CDN，加快下载速度</li><li>静态资源设置缓存</li><li>防阻塞</li><li>图片和模块的懒加载</li><li>函数去抖 + 截流</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><table><thead><tr><th style="text-align:center">中文名称</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">选择排序</td><td style="text-align:center">$n^2$</td><td style="text-align:center">$1$</td><td style="text-align:center">不稳</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">$n^2$</td><td style="text-align:center">$1$</td><td style="text-align:center">稳</td></tr><tr><td style="text-align:center">⭐️插入排序</td><td style="text-align:center">$n^2$</td><td style="text-align:center">$1$</td><td style="text-align:center">稳</td></tr><tr><td style="text-align:center">⭐️堆排序</td><td style="text-align:center">$n\lg n$</td><td style="text-align:center">$1$</td><td style="text-align:center">不稳</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$n^{1.3}$</td><td style="text-align:center">$1$</td><td style="text-align:center">不稳</td></tr><tr><td style="text-align:center">⭐️归并排序</td><td style="text-align:center">$n\lg n$</td><td style="text-align:center">$1$</td><td style="text-align:center">稳</td></tr><tr><td style="text-align:center">⭐️快速排序</td><td style="text-align:center">$n\lg n$</td><td style="text-align:center">$n\lg n$</td><td style="text-align:center">不稳</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center">$n+k$</td><td style="text-align:center">$n+k$</td><td style="text-align:center">稳</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">$n+k$</td><td style="text-align:center">$n+k$</td><td style="text-align:center">稳</td></tr></tbody></table><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>时间复杂度：$O(n\lg n)$</p><p>是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短。是一个不稳定的排序方法。</p><p>步骤：</p><ol><li>选择一个基准元素，通常选择第一个元素或者最后一个元素</li><li>通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小；另一部分记录的元素值比基准值大</li><li>此时基准元素在其排好序后的正确位置</li><li>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li></ol><p>实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.quickSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 取数组最接近中间的数为基准，奇数与偶数取值不同，但不影响</span></span><br><span class="line">  <span class="comment">// 当然，你可以选取第一个，或者最后一个数为基准</span></span><br><span class="line">  <span class="keyword">const</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左右区间，用于存放排序后的数</span></span><br><span class="line">  <span class="keyword">const</span> left = [];</span><br><span class="line">  <span class="keyword">const</span> right = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//小于基准，放于左区间，大于基准，放于右区间</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里使用concat操作符，将左区间，基准，右区间拼接为一个新数组</span></span><br><span class="line">  <span class="comment">// 然后递归1，2步骤，直至所有无序区间都 只剩下一个元素 ，递归结束</span></span><br><span class="line">  <span class="keyword">return</span> left.quickSort().concat([pivot], right.quickSort());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">14</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">76</span>, <span class="number">11</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.quickSort());</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>平均时间复杂度$O(n^2)$，最好情况$O(n)$，最差情况$O(n^2)$</p><p>空间复杂度$O(1)$</p><p>稳定性：稳定</p><p>步骤：通过无序区中相邻记录关键字间的比较和位置的交换，使关键字最小的记录如气泡一般逐渐往上“漂浮”直至“水面”。</p><p>实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params">sortAs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (sortAs(arr[j], arr[j + <span class="number">1</span>])) &#123;</span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>平均时间复杂度$O(n^2)$，最好情况$O(n^2)$，最差情况$O(n^2)$。</p><p>空间复杂度$O(1)$</p><p>稳定性：不稳定</p><p>实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selectSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>平均情况：$O(n^2)$，最佳情况，输入数组按升序排列：$O(n)$，最坏情况，输入数组按降序排列：$O(n^2)$</p><p>每次只处理一个元素，从后往前查找，找到该元素合适的插入位置。</p><p>实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.insertSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>])&#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.concat(left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> left  = arr.slice(<span class="number">0</span>, middle);</span><br><span class="line">  <span class="keyword">var</span> right = arr.slice(middle);</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目类问题"><a href="#项目类问题" class="headerlink" title="项目类问题"></a>项目类问题</h1><h2 id="实习项目难点、收获"><a href="#实习项目难点、收获" class="headerlink" title="实习项目难点、收获"></a>实习项目难点、收获</h2><h2 id="为什么不留在阿里"><a href="#为什么不留在阿里" class="headerlink" title="为什么不留在阿里"></a>为什么不留在阿里</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这大概是一份问题列表，用来记录在面试中遇到的问题和现在能想到/找到的答案（或者先记录问题，答案等慢慢填坑）。&lt;/p&gt;
&lt;h1 id=&quot;JS-类问题&quot;&gt;&lt;a href=&quot;#JS-类问题&quot; class=&quot;headerlink&quot; title=&quot;JS 类问题&quot;&gt;&lt;/a&gt;JS 类问题
      
    
    </summary>
    
    
      <category term="秋招" scheme="https://sr2k.top/blog/tags/%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>【译】Fiber：深入了解 React 的全新调度算法</title>
    <link href="https://sr2k.top/blog/2019/07/22/%E8%AF%91-Fiber-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3React%E7%9A%84%E5%85%A8%E6%96%B0%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>https://sr2k.top/blog/2019/07/22/译-Fiber-深入了解React的全新调度算法/</id>
    <published>2019-07-22T03:08:26.000Z</published>
    <updated>2019-07-22T03:17:57.952Z</updated>
    
    <content type="html"><![CDATA[<p>React 是一个用来制作 UI 的 JavaScript 库，其核心是跟踪组件状态的变化，并将其更新在屏幕上的机制<a href="https://medium.freecodecamp.org/what-every-front-end-developer-should-know-about-change-detection-in-angular-and-react-508f83f58c6a" target="_blank" rel="noopener">机制</a>，在 React 中，这一过程被称为<strong>协调</strong>。每当我们调用 <code>setState</code> 时，React 都会检测 state 和 props 是否发生了变化，并在 UI 中重新渲染组件。</p><p>React 的文档很好地提供了这个机制的<a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">大致简介</a>：整个过程中 React 元素的担当角色、生命周期方法和 <code>render</code> 方法，以及对各个子组件实施的 diff 算法。<code>render</code> 方法返回的这些不可变的 React 元素树通常被我们称为「virtual DOM」。在以前，这个术语帮助我们理解了 React 的工作模式，但也带来了许多困惑，所以现在 React 的文档已经不再使用它了，所以本文将会将他们称作「React 元素树」。</p><p>为了维护状态，除了 React 元素树，React 同时也维护着一些内部实例（如组件、DOM 节点等）构成的树。自 v16 开始，React 推出了一种全新的维护内部实例树的算法实现，并取代号为「<strong>Fiber</strong>」。要想了解 Fiber 架构带来的种种好处，你可以看这篇文章：<a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">《React 在 Fiber 中使用链表的原因和方法》</a>。</p><blockquote><p>如果没有 <a href="https://medium.com/u/a3a8af6addc1" target="_blank" rel="noopener">Dan Abramov</a> 的帮助，这篇文章得花多得多的时间才能完成，而且全面性也会大打折扣！<em>👍</em></p></blockquote><p>这是 React 内部架构系列教程的第一篇。在这篇文章中，我会深入介绍与核心算法有关的重要概念和数据结构。当我们了解地足够多的时候，我们会开始探索取得和操作 Fiber 树的算法和主要函数。这个系列的下一篇文章将会演示 React 是如何使用这个算法来实施初次渲染，并处理 state 和 props 的。从那开始我们将移步调度器的种种细节，以及实现副作用列表的机制。</p><p><a href="https://twitter.com/maxkoretskyi" target="_blank" rel="noopener"><strong>关注我获得最新消息！</strong></a></p><p>本文会介绍许多进阶知识 🧙‍。我鼓励你阅读本文，并理解 React 工作时的各种黑魔法。如果你打算为 React 作出贡献，这一系列文章也会是一个很好的指南。我是<a href="https://blog.angularindepth.com/level-up-your-reverse-engineering-skills-8f910ae10630" target="_blank" rel="noopener">逆向工程的重视拥趸</a>，所以这儿会有许多指向 React 16.6.0 源码的链接。</p><p>要学的东西很多，所以如果你感觉有压力，或者对有些东西现在还不太理解，请多花点时间，因为这很值得。<strong>需要注意的是你不需要这里的任何知识来使用 React，这篇文章只关乎 React 的内部实现原理。</strong></p><blockquote><p>我在 <a href="https://react-grid.ag-grid.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=reactcustom" target="_blank" rel="noopener"><strong>ag-Grid</strong></a> 担任技术推广工程师。 If you’re curious to learn about data grids or looking for the ultimate React data grid solution, get in touch or give it a try with the guide “<a href="https://blog.ag-grid.com/react-get-started-with-react-grid-in-5-minutes/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=getstartedangular" target="_blank" rel="noopener"><strong>Get started with React grid in 5 minutes</strong></a>”. I’m happy to answer any questions you may have.</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本文的示例是这样一个应用——界面上有一个按钮，点击它以后数字会增加，并在屏幕上渲染出来：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./demo.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>以及它的代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Update counter&lt;<span class="regexp">/button&gt;,</span></span><br><span class="line"><span class="regexp">      &lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在<a href="https://stackblitz.com/edit/react-t4rdmh" target="_blank" rel="noopener">这里</a>把玩一下这个例子，它就是一个简单的组件，在其 <code>render</code> 方法中返回 <code>button</code> 和 <code>span</code> 两个元素。当你点击按钮时，事件处理器会更新组件的 state，然后作为结果，<code>span</code> 元素中的文字会被更新。</p><p>React 在<strong>协调</strong>的过程中会做很多事情，比如在我们的示例 app 中，React 会在初次渲染完成后以及 state 被更新后做的事情大致包括：</p><ul><li>在 <code>ClickCounter</code> 中更新 <code>count</code> 属性；</li><li>找到 <code>ClickCounter</code> 和其 props，并进行比较；</li><li>更新 <code>span</code> 元素的 props。</li></ul><p><strong>协调</strong>的过程中还会发生其他事情，如调用<a href="https://reactjs.org/docs/react-component.html#updating" target="_blank" rel="noopener">生命周期方法</a>和更新<a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">引用（refs）</a>。<strong>在 Fiber 架构中，这些事情都统一地被称为「事务」。</strong>事务的种类通常取决于 React 元素的种类，例如对于一个类组件，React 需要创建一个实例，但是函数组件就不需要。你肯定知道，React 中有很多种元素，如类和函数组件、宿主组件（也就是 DOM 节点）、Portal 等。<a href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react/src/ReactElement.js#L171" target="_blank" rel="noopener"><code>createElement</code></a> 方法的第一个参数决定了 React 元素的种类，这个方法一般用于在 <code>render</code> 方法中创建 React 元素。</p><p>在开始探索 Fiber 算法和事物之前，我们现来熟悉一下 React 内部使用的数据结构。</p><h1 id="从-React-元素到-Fiber-节点"><a href="#从-React-元素到-Fiber-节点" class="headerlink" title="从 React 元素到 Fiber 节点"></a>从 React 元素到 Fiber 节点</h1><p>React 中每个元素都具有一个 UI 上的表现，我们可以称作「视图」或者「模板」。例如我们示例中 <code>ClickCounter</code> 组件的模板就是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.onClick&#125;&gt;Update counter&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure><h2 id="React-元素"><a href="#React-元素" class="headerlink" title="React 元素"></a>React 元素</h2><p>模板经过 JSX 编译器后，你就得到了一系列 React 元素，这些元素才是你真正在 React 组件中 <code>render</code> 方法返回的东西，而不是看起来的 HTML。由于 JSX 并不是非用不可的，<code>ClickCounter</code> 组件的 <code>render</code> 方法其实也可以重写成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  render() &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">      React.createElement(</span><br><span class="line">        <span class="string">'button'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          key: <span class="string">'1'</span>,</span><br><span class="line">          onClick: <span class="keyword">this</span>.onClick</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'Update counter'</span></span><br><span class="line">      ),</span><br><span class="line">      React.createElement(</span><br><span class="line">        <span class="string">'span'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          key: <span class="string">'2'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">this</span>.state.count</span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>render</code> 方法中调用的  <code>React.createElement</code> 函数将会创建一个这样的数据结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">    type: <span class="string">'button'</span>,</span><br><span class="line">    key: <span class="string">"1"</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: <span class="string">'Update counter'</span>,</span><br><span class="line">      onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">    type: <span class="string">'span'</span>,</span><br><span class="line">    key: <span class="string">"2"</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到，React 给这些对象加上了 <code>$$typeof</code> 属性来将其标记为 React 元素。接下来是用来描述一个元素 <code>type</code>、<code>key</code> 和 <code>props</code> 属性，它们的值取决于你传递给 <code>React.createElement</code> 方法的参数。请注意一下这里 React 会将字符串也作为 <code>span</code> 和 <code>button</code> 节点的子节点，而点击事件处理器则会被放置在 <code>button</code> 的 props 中。React 元素还会有一些字段如 <code>ref</code>，但是他们与这篇文章讨论的范畴无关。</p><p><code>ClickCounter</code> 对应的 React 元素没有任何 props 或 key：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">  key: <span class="literal">null</span>,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  ref: <span class="literal">null</span>,</span><br><span class="line">  type: ClickCounter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fiber-节点"><a href="#Fiber-节点" class="headerlink" title="Fiber 节点"></a>Fiber 节点</h2><p>在<strong>协调</strong>的过程中，每个 React 元素的 <code>render</code> 方法返回的数据会被合并至 Fiber 节点树，每个 React 元素都有一个与之对应的 Fiber 节点。与 React 元素不同的是，Fiber 并不是每次渲染都会重新生成，它们是保存着组件状态和 DOM 的可变数据结构。</p><p>前边我们说到过，React 元素类型的不同会导致 React 需要进行不同的操作。在我们的示例中，类组件 <code>ClickCounter</code> 会被调用生命周期方法和 <code>render</code> 方法；然而对于 <code>span</code> 这种宿主节点（DOM 节点），React 则会进行 DOM 的更新。所以每个 React 元素都会被转化成<a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js" target="_blank" rel="noopener">对应类型</a>的 Fiber 节点，后者会描述需要进行的事务。</p><p><strong>你可以认为 Fiber 节点就是一种代表需要进行的事务的数据结构，换言之也就是事务的最小单位。Fiber 架构同时还使得跟踪、安排、暂停和终止事务变得简单。</strong></p><p>当一个 React 元素第一次被转换成一个 Fiber 节点的时候，React 会通过 <a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L414" target="_blank" rel="noopener"><code>createFiberFromTypeAndProps</code></a> 函数来使用元素的信息来生成 Fiber 节点。在同步更新中，React 会重复使用 Fiber 节点，并根据与之相关的 React 元素上的数据来更新必要的属性。根据 <code>key</code> 属性，React 还可能会改变节点的层级。如果一个元素不再被 <code>render</code> 方法返回，React 会删除它。</p><blockquote><p>请参阅 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactChildFiber.js#L239" target="_blank" rel="noopener"><code>ChildReconciler</code></a> 函数，它会列出所有的操作类型，以及对应的 React 会对 Fiber 节点进行的操作。</p></blockquote><p>由于 React 会为每个 React 元素都创建 Fiber 节点，且这些元素构成一棵树，我们会得到一棵树状结构的 Fiber 节点。譬如在我们的示例中，这棵树会像这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./fiber-tree.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过 <code>child</code>、<code>sibling</code> 和 <code>return</code> 属性，所有 Fiber 节点会通过一个链表连接在一起。请参阅我的文章<a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">《React 在 Fiber 中使用链表的原因和方法》</a>来了解为什么要这么设计。</p><h2 id="Current-树和-workInProgress-树"><a href="#Current-树和-workInProgress-树" class="headerlink" title="Current 树和 workInProgress 树"></a>Current 树和 workInProgress 树</h2><p>初次渲染完成后，React 会得到一棵代表当前 app 状态的树，并据此渲染 UI。我们通常把这棵树称作「<strong>current</strong>」。当 React 开始更新的时候，它会创建一棵名叫「<strong>workInProgress</strong>」的树，这棵树反映了用来刷新 UI 的新状态。</p><p>所有对 Fiber 进行的操作都来自于 <code>workInProgress</code> 树。当 React 遍历  <code>current</code> 树的时候，对于每个 Fiber 节点，React 会创建一个新的节点（alternate），由这些 alternate 形成 <code>workInProgress</code> 树。新的节点使用 React 元素 <code>render</code> 方法返回的数据创建。在更新完成，所有的事务都结束后，React 会得到一棵 alternate 树，并可以刷新 UI。当 <code>workInProgress</code> 被渲染到屏幕，它就会取代先前的树，成为新的 <code>current</code> 树。</p><p>React 的核心原则之一是连贯性。React 总是会一次性地更新 DOM，而不会仅渲染部分结果。<code>workInProgress</code> 树充当的就是一个不会对用户展示的「草稿」，所以 React 可以先处理所有的节点，再把所有的变更刷新到屏幕。</p><p>在源码中，你可以找多从 <code>current</code> 和 <code>workInProgress</code> 树获取 Fiber 节点的函数，比如其中一个的函数签名如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>每个 Fiber 节点都在 <strong>alternate</strong> 字段中保存着另一棵树中它的副本： <code>current</code> 树中的指向 <code>workInProgress</code> 树中的，反之亦然。</p><h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>我们可以把 React 组件都想象成函数，他们接收 state 和 props，并计算出对应的 UI 的描述。由此，任何其他的操作，如操作 DOM 或调用生命周期方法都可以看作副作用，简称作用。<a href="https://reactjs.org/docs/hooks-overview.html#effect-hook" target="_blank" rel="noopener">副作用</a>在文档中是这么描述的：</p><blockquote><p>你之前可能已经在 React 组件中执行过数据获取、订阅或者手动<strong>修改过 DOM</strong>。我们统一把这些操作称为“副作用”，或者简称为“作用”。</p></blockquote><p>由此可以看出大多数 state 和 props 的更新都会导致副作用的产生。由于实施副作用也是一种事务，Fiber 是追踪除了更新以外的副作用的一种很有力机制。每个 Fiber 节点都可以和副作用相关联，存储在 <code>effectTag</code> 字段中。</p><p>所以，Fiber 中的副作用定义了更新完成后示例们需要进行的<strong><a href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js" target="_blank" rel="noopener">事务</a></strong>。对于宿主节点（DOM 元素），事务包括添加、更新和删除元素。对于类组件，React 可能需要更新 refs 并调用 <code>componentDidMount</code> 以及 <code>componentDidUpdate</code> 等生命周期方法。其他的 Fiber 节点也都有它们对应的副作用。</p><h2 id="副作用链表"><a href="#副作用链表" class="headerlink" title="副作用链表"></a>副作用链表</h2><p>React 处理更新的速度极快，为了达到这样的性能，它采用了许多很有趣的技术。<strong>其中之一便是构造一个带有副作用的 Fiber 节点组成的线形表，以此加快遍历速度。</strong>遍历一个线形表要比遍历一棵树快多了，而且这样（只有带副作用的 Fiber 节点才在链表中）可以避免在没有副作用的节点上浪费时间。</p><p>这个链表的目的是标记所有需要更新 DOM 或其他副作用的节点。它是 <code>finishedWork</code> 树的子集，它使用 <code>current</code> 和 <code>workInProgress</code> 树节点中的 <code>nextEffect</code> 属性而不是 <code>child</code> 属性来做为指针。</p><p><a href="https://medium.com/u/a3a8af6addc1" target="_blank" rel="noopener">Dan Abramov</a> 给出了一个副作用链表的比喻，他喜欢把它比作一棵圣诞树，树上挂小灯的电线把所有有副作用的节点都连在了一起。为了可视化这一过程，我们想象一下以下这棵 Fiber 节点树，其中桔红色的节点是有事务的。比如，我们的更新使得 <code>c2</code> 需要插入至 DOM，<code>d2</code> 和 <code>c1</code> 需要更新属性，<code>b2</code> 需要调用生命周期方法。副作用链表会将它们连在一起，因此 React 稍后可以跳过其他节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./effect-link-in-tree.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>你现在知道带有副作用的节点是如何构成链表的了，当遍历节点的时候，React 会通过 <code>firstEffect</code> 指针来找出链表的第一个元素。因此上图可以像下图一样表示成一个线形表：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./effect-link.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>你可以看到，React 会依照先子节点再夫节点的顺序实施副作用。</p><h2 id="Fiber-树的根"><a href="#Fiber-树的根" class="headerlink" title="Fiber 树的根"></a>Fiber 树的根</h2><p>每一个 React 都有一个或多个 DOM 元素作为容器。我们的示例中它是一个带有 <code>container</code> ID 的  <code>div</code> 元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> domContainer = <span class="built_in">document</span>.querySelector(<span class="string">'#container'</span>);</span><br><span class="line">ReactDOM.render(React.createElement(ClickCounter), domContainer);</span><br></pre></td></tr></table></figure><p>React 会为每个容器创建一个 <a href="https://github.com/facebook/react/blob/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74/packages/react-reconciler/src/ReactFiberRoot.js#L31" target="_blank" rel="noopener"><code>fiberRoot</code></a> 元素，你可以通过对 DOM 元素的引用来访问它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fiberRoot = query(<span class="string">'#container'</span>)._reactRootContainer._internalRoot</span><br></pre></td></tr></table></figure><p>这个 Fiber Root 就是 React 保存对 Fiber 树的引用的地方。它保存在 Fiber Root 的 <code>current</code> 属性中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hostRootFiberNode = fiberRoot.current</span><br></pre></td></tr></table></figure><p>Fiber 树的根是一个具有<a href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/shared/ReactWorkTags.js#L34" target="_blank" rel="noopener">特殊类型</a> <code>HostRoot</code> 的 Fiber 节点，React 会在内部创建它，并把它作为你最顶层组件的父节点。可以通过 <code>stateNode</code> 属性从 <code>HostRoot</code> 节点回到 <code>FiberRoot</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiberRoot.current.stateNode === fiberRoot; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>你可以从访问最顶层的 <code>HostRoot</code> 开始探索整棵 Fiber 树，或者你也可以像从一个组件实例获取一个单独的节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compInstance._reactInternalFiber</span><br></pre></td></tr></table></figure><h2 id="Fiber-节点的结构"><a href="#Fiber-节点的结构" class="headerlink" title="Fiber 节点的结构"></a>Fiber 节点的结构</h2><p>现在，我们来看看 <code>ClickCounter</code> 组件产出的 Fiber 节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  stateNode: <span class="keyword">new</span> ClickCounter,</span><br><span class="line">  type: ClickCounter,</span><br><span class="line">  alternate: <span class="literal">null</span>,</span><br><span class="line">  key: <span class="literal">null</span>,</span><br><span class="line">  updateQueue: <span class="literal">null</span>,</span><br><span class="line">  memoizedState: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  pendingProps: &#123;&#125;,</span><br><span class="line">  memoizedProps: &#123;&#125;,</span><br><span class="line">  tag: <span class="number">1</span>,</span><br><span class="line">  effectTag: <span class="number">0</span>,</span><br><span class="line">  nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及 DOM 元素 <code>span</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">  type: <span class="string">"span"</span>,</span><br><span class="line">  alternate: <span class="literal">null</span>,</span><br><span class="line">  key: <span class="string">"2"</span>,</span><br><span class="line">  updateQueue: <span class="literal">null</span>,</span><br><span class="line">  memoizedState: <span class="literal">null</span>,</span><br><span class="line">  pendingProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  memoizedProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  tag: <span class="number">5</span>,</span><br><span class="line">  effectTag: <span class="number">0</span>,</span><br><span class="line">  nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fiber节点中有许许多多的字段，前边我已经解释过 <code>alternate</code>、<code>effectTag</code> 和 <code>nextEffect</code> 的作用了。我们来看看其他的：</p><ul><li><code>stateNode</code> 保存着对 Fiber 节点对应的组件实例、DOM 节点或其他 React 元素的引用。通常我们认为这个属性保存了 Fiber 对应的本地状态；</li><li><code>type</code>定义了 Fiber 对应的函数或类。对于类组件，它指向构造函数；对于 DOM 元素，它是 HTML 标签。我经常用这个字段来确定一个 Fiber 节点对应的元素。</li><li><code>tag</code> 定义了 <a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js" target="_blank" rel="noopener">Fiber 的类型</a>。在协调算法中，它被用于确定需要完成的事务是什么。上面说到过，不同的 React 元素会对应不同的事务。<a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L414" target="_blank" rel="noopener"><code>createFiberFromTypeAndProps</code></a> 函数会把一个 React 元素映射成对应的 Fiber 节点。在我们的示例 app 中，<code>ClickCounter</code> 的 <code>tag</code> 属性的值是 <code>1</code>，代表 <code>ClassComponent</code>；而 <code>span</code>元素则是 <code>5</code>，代表 <code>HostComponent</code>。</li><li><code>updateQueue</code> 是一个状态更新、回调函数和 DOM 更新组成的队列；</li><li><code>memoizedState</code> 是 Fiber 上一次渲染中用来创建输出的 state，当触发更新时，它代表着当前 UI 显示着的 state；</li><li><code>memoizedProps</code> 则是 Fiber 上一次渲染中用来创建输出的 props；</li><li><code>pendingProps</code> 是 React 元素已经完成更新后新的数据产生的 props，它会被应用于子组件或 DOM 元素；</li><li><code>key</code> 是一个唯一的标识符，用于让 React 分辨哪些元素发生了变化（从列表中增加或删除）。它与 React 的列表渲染有关，请参阅<a href="https://reactjs.org/docs/lists-and-keys.html#keys" target="_blank" rel="noopener">这里</a>。</li></ul><p>你可以在<a href="https://github.com/facebook/react/blob/6e4f7c788603dac7fccd227a4852c110b072fe16/packages/react-reconciler/src/ReactFiber.js#L78" target="_blank" rel="noopener">这里</a>找到完整的 Fiber 节点的结构。我删掉了许多前文已经提到过的字段，跳过了<a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">上一篇文章中说过的</a>用于组成树状结构的 <code>child</code>, <code>sibling</code> 和 <code>return</code> 字段，一些 <code>Scheduler</code> 专用的字段如 <code>expirationTime</code>、<code>childExpirationTime</code> 和 <code>mode</code> 也没有被提及。</p><h1 id="算法概况"><a href="#算法概况" class="headerlink" title="算法概况"></a>算法概况</h1><p>React 的事务执行过程分为两个部分：<strong>渲染（render）</strong>和<strong>提交（commit）</strong>。</p><p>在第一个阶段 <code>render</code> 中，React 会把更新应用于通过 <code>setState</code> 或 <code>React.render</code> 排好期的组件，并分析出 UI 中需要更新的部分。如果是初次渲染，React 会为 <code>render</code> 方法返回的每个元素都创建一个新的 Fiber 节点。在接下来的更新中，已经存在的 React 元素的 Fiber 将会被复用并更新。<strong>这一阶段的结果是由标记了副作用的 Fiber 节点构成的一棵树。</strong>这些副作用描述了在接下来的 <code>commit</code> 阶段需要进行的事务。在这一阶段中，React 会把接收标有副作用的 Fiber 树，并把它应用到实例上。React 会遍历副作用链表，并把 DOM 更新等操作呈现给用户。</p><p><strong>有一件事很重要：在第一阶段过程 <code>render</code> 中的事务是可以异步执行的。</strong>React 可以根据可用时间的多少，在处理一个完或多个 Fiber 节点后停下来，暂存已经完成的事务，并发送一些事件，然后再从刚刚停下的地方继续。虽然有的时候它还是需要舍弃之前的结果然后从头再来。这种暂停得以实现的原因是，实施这些事务并没有产生类似于 DOM 更新之类的任何用户可见的更改。<strong>相反地，下一个阶段 <code>commit</code> 永远是同步执行的</strong>。这是因为这一阶段产生的结果对用户是可见的，比如更新 DOM，所以 React 需要将其一次性做完。</p><p>调用生命周期方法是 React 需要执行的事务之一。有些方式是在  <code>render</code> 阶段执行的，而有些则是在 <code>commit</code>阶段。在第一阶段 <code>render</code> 中会被调用的方法有：</p><ul><li><code>[UNSAFE_]componentWillMount</code> (已废弃)</li><li><code>[UNSAFE_]componentWillReceiveProps</code> (已废弃)</li><li><code>getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>[UNSAFE_]componentWillUpdate</code> (已废弃)</li><li><code>render</code></li></ul><p>如你所见，自 v16.3 开始，有些历史遗留的 <code>render</code> 阶段生命周期方法被标记了 <code>UNSAFE</code>，在文档中它们被称作历史遗留生命周期方法。他们会在将来的某个 16.x 发布中被废弃，而它们没有 <code>UNSAFE</code> 的副本也将在 17.0 中被移除。你可以在<a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">这里</a>了解到这些变更以及推荐的迁移路径。</p><p>你对这种变更的原因感到困惑吗？</p><p>好吧，我们刚刚说到 <code>render</code> 阶段并不产生如更新 DOM 的副作用，因此 React 可以异步地处理组件的更新（甚至在多个线程中完成）。然而，标记为  <code>UNSAFE</code> 的生命周期方法常常被误解和轻微地误用。开发者们倾向于把带有副作用的代码放置于这些方法中，这会导致全新的异步渲染实现产生问题。尽管只是没有 <code>UNSAFE</code> 的副本会被移除，这些方法仍可能在即将退出的的并发模式中导致问题（不过你可以选择不用这种模式）。</p><p>以下列表为会在 <code>commit</code> 阶段被调用的方法：</p><ul><li><code>getSnapshotBeforeUpdate</code></li><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul><p>因为这些方法会在同步的 <code>commit</code> 阶段被调用，它们可以包含副作用，以及操作 DOM。</p><p>好的，现在我们已经了解完了背景，并看完了遍历树和实施事务的算法的基本概况，是时候继续深究了。</p><h1 id="Render-阶段"><a href="#Render-阶段" class="headerlink" title="Render 阶段"></a>Render 阶段</h1><p>协调算法始终会通过调用 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1132" target="_blank" rel="noopener">renderRoot</a> 函数，从最顶层的 <code>HostRoot</code> Fiber 节点开始。然而，React 会跳过已经处理过的 Fiber 节点，直到它找到了还有尚未完成事务的节点。例如，如果你在组件树的较深位置调用了 <code>setState</code>，React 将还是从顶开始，不过会快速地跳过各个父组件，直到它找到了 <code>setState</code> 被调用的那个组件。</p><h2 id="事务循环的主要流程"><a href="#事务循环的主要流程" class="headerlink" title="事务循环的主要流程"></a>事务循环的主要流程</h2><p>所有节点都在<a href="https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js#L1136" target="_blank" rel="noopener">事务循环中</a>被处理，以下是同步版的事务循环的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">isYieldy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的代码中，<code>nextUnitOfWork</code> 引用着 <code>workInProgress</code> 树中带有事务的 Fiber 节点。React 取回 Fiber 树时，它会使用这个变量来检查是否还有其他带有未完成事务的 Fiber 节点。这个过程结束后，这个变量要不然是下一个 Fiber 节点，要不然就是 <code>null</code>，若是后者，React 就会退出事务循环，并可以提交这些改动了。</p><p>React 中主要有 4 个函数用来取回整棵树和完成事务：</p><ul><li><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1056" target="_blank" rel="noopener"><code>performUnitOfWork</code></a></li><li><a href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L1489" target="_blank" rel="noopener"><code>beginWork</code></a></li><li><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L879" target="_blank" rel="noopener"><code>completeUnitOfWork</code></a></li><li><a href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js#L532" target="_blank" rel="noopener"><code>completeWork</code></a></li></ul><p>为了演示它们的工作方法，请看一下下边这个动图，它描述了取回 Fiber 树的过程。出于演示的目的，我在这儿使用的是这些函数的简化版本实现，每个函数接收并处理一个 Fiber 节点。React 向下处理的过程中，你可以看到活动的 Fiber 节点也发生了变化。在动图中可以很清楚地看这个算法是如何从一棵子树跳到另一棵的：它会先完成事务，再返回父节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./algo.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>备注：竖直方向的连线代表的是兄弟节点，而拐弯的连线代表父子。例如 <code>b1</code> 没有子节点，而 <code>b2</code> 有一个子节点 <code>c1</code>。</p></blockquote><p>上面的动图<a href="https://vimeo.com/302222454" target="_blank" rel="noopener">在这儿有一个视频版本</a>，以便你暂停和回放，并观察当前节点和函数的状态。理论上，你可以把 <code>beginWork</code> 想象成「进入」一个组件，而 <code>completeWork</code> 就是「退出」了。你可以<a href="https://stackblitz.com/edit/js-ntqfil?file=index.js" target="_blank" rel="noopener">在这里玩一玩示例实现</a>。</p><p>让我们从前两个函数 <code>performUnitOfWork</code> 和 <code>beginWork</code> 开始：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = beginWork(workInProgress);</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'work performed for '</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performUnitOfWork</code> 是 Fiber 中所有操作开始的地方，它接收一个 <code>workInProgress</code> 树中的 Fiber 节点，并通过调用 <code>beginWork</code> 函数来开始事务。为了演示，我们此处就简单地把 Fiber 的名字 log 出来，然后标记这个节点为事务已完成。<strong><code>beginWork</code> 函数始终会返回循环中下一个待处理的节点或 <code>null</code></strong>。</p><p>如果下一个子节点存在，它会在 <code>workLoop</code> 函数中被赋值给 <code>nextUnitOfWork</code> 变量。然而，如果没有子节点，React 就知道它已经到达了子树的底端，因此可以完成对这个节点的操作。<strong>在这个节点完成后，React 会操作它的兄弟节点，并返回其父节点。</strong>这些工作是在 <code>completeUnitOfWork</code> 函数中完成的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> returnFiber = workInProgress.return;</span><br><span class="line">    <span class="keyword">let</span> siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">    nextUnitOfWork = completeWork(workInProgress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果存在兄弟节点，会将它返回以对它进行操作</span></span><br><span class="line">      <span class="keyword">return</span> siblingFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果 `returnFiber` 中没有更多事务了，会返回循环并完成父节点</span></span><br><span class="line">      workInProgress = returnFiber;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 到顶了！</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'work completed for '</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个函数的主旨就是一个大大的 <code>while</code> 循环。<code>workInProgress</code> 中的节点没有子节点的时候，React 就会进入这个函数。</p><p>在当前 Fiber 的事务结束后，React 会检查它是否有兄弟节点，如果有，React 会退出函数，并把兄弟节点返回。这个兄弟节点会被赋值给 <code>nextUnitOfWork</code> 变量，React 会从这个兄弟节点开始实施事务。有一点很重要：此时此刻 React 仅仅完成了先前兄弟节点的事务，它还没有对父节点实施事务。<strong>只有从子节点开始的当所有分支都结束了，它才会开始完成父节点的事务，并原路返回。</strong></p><p>从实现中可以发现，<code>performUnitOfWork</code> 和 <code>completeUnitOfWork</code> 主要是用来进行迭代的，而真正的操作发生在 <code>beginWork</code> 和 <code>completeWork</code> 函数中。本系列的下一篇文章中我们将会了解 React 进入  <code>beginWork</code> 和 <code>completeWork</code> 函数的时候，<code>ClickCounter</code> 组件和 <code>span</code> 节点会发生什么。</p><h1 id="Commit-阶段"><a href="#Commit-阶段" class="headerlink" title="Commit 阶段"></a>Commit 阶段</h1><p>这一阶段从 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L2306" target="_blank" rel="noopener"><code>completeRoot</code></a>函数开始。这也是 React 更新 DOM，并调用挂载前后的生命周期方法的地方。</p><p>进入这一阶段时，React 会保存着两棵树和副作用链表。第一棵树代表着当前 UI 中的 state；第二棵则是 <code>render</code> 阶段中产生的 alternate 树，源码中叫做 <code>finishedWork</code> 或 <code>workInProgress</code> 树，代表着 UI 中需要渲染的 state。和 current 树一样，这棵 alternate 树也是由 <code>child</code> 和 <code>sibling</code> 指针连起来的。</p><p>接下来是副作用链表——通过 <code>nextEffect</code> 指针连起来的 <code>finishedWork</code> 树。请记住副作用链表是运行 <code>render</code> 阶段的<em>结果</em>，该链表的目的描述需要插入、更新或删除的节点，以及需要调用生命周期方法的组件。<strong>而这个链表中的节点就是 coomit 阶段中会被迭代的。</strong></p><blockquote><p>出于 debug 的目的，<code>current</code> 树可以从 <code>FiberRoot</code> 节点的 <code>current</code> 属性中访问到，<code>finishedWork</code> 树可以从 <code>HostFiber</code> 节点的 <code>alternate</code> 属性访问到。</p></blockquote><p>Commit 阶段的核心函数是 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L523" target="_blank" rel="noopener"><code>commitRoot</code></a>，它做的事情基本上是：</p><ul><li>在被标记了 <code>SnapShot</code> 副作用的节点上调用  <code>getSnapshotBeforeUpdate</code> 生命周期方法；</li><li>在被标记了 <code>Deletion</code> 副作用的节点上调用 <code>componentWillUnmount</code> 生命周期方法；</li><li>进行 DOM 的增删改；</li><li>把 <code>finishedWork</code> 树设置为新的 current 树；</li><li>在被标记了 <code>Placement</code> 副作用的节点上调用 <code>componentDidMount</code> 生命周期方法；</li><li>在被标记了 <code>Update</code> 副作用的节点上调用 <code>componentDidUpdate</code> 生命周期方法。</li></ul><p>在调用了挂载前生命周期函数 <code>getSnapshotBeforeUpdate</code> 后，React 会提交树中所有的副作用，这一步有两个阶段。第一阶段会执行所有的 DOM（宿主元素）的插入、更新、删除以及 ref 的卸载。然后 React 会把 <code>finishedWork</code> 树分配给 <code>FiberRoot</code>，并把 <code>workInProgress</code> 树标记为 <code>current</code> 树。这一过程是在第一次 commit 阶段完成后以及第二次 commit 完成前进行的，所以前一棵树还在进行 <code>componentWillUnmount</code>，而 <code>finishedWork</code> 树正在执行 <code>componentDidMount/Update</code>；第二阶段 React 会调用其他所有的生命周期方法，和 ref 回调。这些方法会分成好几轮，以确保所有的替换、更新和删除都顺利执行了。</p><p>下边是一个实现了上述过程主旨的函数实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root, finishedWork</span>) </span>&#123;</span><br><span class="line">  commitBeforeMutationLifecycles()</span><br><span class="line">  commitAllHostEffects();</span><br><span class="line">  root.current = finishedWork;</span><br><span class="line">  commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的每一个子函数都实现了一个循环，从而迭代副作用链表，并检测副作用的类型。当它找到与本函数有关的副作用的时候就会执行。</p><h2 id="挂载前生命周期方法"><a href="#挂载前生命周期方法" class="headerlink" title="挂载前生命周期方法"></a>挂载前生命周期方法</h2><p>下边是一个例子，其中的代码会对副作用树进行迭代并检测节点是否带有 <code>Spapshot</code> 副作用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifecycles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Snapshot) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitBeforeMutationLifeCycles(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个类组件，这个副作用意味着调用 <code>getSnapshotBeforeUpdate</code>。</p><h2 id="DOM-更新"><a href="#DOM-更新" class="headerlink" title="DOM 更新"></a>DOM 更新</h2><p><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376" target="_blank" rel="noopener"><code>commitAllHostEffects</code></a> 函数是 React 更新 DOM 的地方。这个函数基本上就是定义了需要进行的操作的种类，并执行之：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">    <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">      commitPlacement(nextEffect);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">      commitPlacement(nextEffect);</span><br><span class="line">      commitWork(current, nextEffect);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Update: &#123;</span><br><span class="line">      commitWork(current, nextEffect);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">      commitDeletion(nextEffect);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 会在 <code>commitDeletion</code> 函数中调用 <code>componentWillUnmount</code> 方法，这还怪好玩的。</p><h2 id="挂载后生命周期方法"><a href="#挂载后生命周期方法" class="headerlink" title="挂载后生命周期方法"></a>挂载后生命周期方法</h2><p><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L465" target="_blank" rel="noopener"><code>commitAllLifecycles</code></a> 是 React 调用所有剩余的生命周期函数的地方，如 <code>componentDidUpdate</code> 和 <code>componentDidMount</code>。</p><hr><p>终于结束了！如果你对这篇文章有任何问题，请在评论中写出。<strong>你也可以看看本系列的下一篇<a href="https://medium.com/react-in-depth/in-depth-explanation-of-state-and-props-update-in-react-51ab94563311" target="_blank" rel="noopener">《深入探索 React 的 state 和 props 更新机制》</a>。</strong>我还有许多关于调度器、子协调过程和副作用列表构建过程的文章正在写作中，我还有创作一个以这篇文章为基础的 debug 心得分享的视频。</p><p><strong>血都要获得更多信息，请在 <a href="https://twitter.com/maxkoretskyi" target="_blank" rel="noopener">Twitter</a> 和 <a href="https://medium.com/@maxim.koretskyi" target="_blank" rel="noopener">Medium</a> 关注我。感谢你的阅读！如果你喜欢这篇文章，请给我点个鼓掌 👏。这对我大有帮助，而且可以让更多的人看到这篇文章。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React 是一个用来制作 UI 的 JavaScript 库，其核心是跟踪组件状态的变化，并将其更新在屏幕上的机制&lt;a href=&quot;https://medium.freecodecamp.org/what-every-front-end-developer-should-
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://sr2k.top/blog/tags/JavaScript/"/>
    
      <category term="翻译" scheme="https://sr2k.top/blog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="React" scheme="https://sr2k.top/blog/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="https://sr2k.top/blog/2019/07/19/arrow-functions/"/>
    <id>https://sr2k.top/blog/2019/07/19/arrow-functions/</id>
    <published>2019-07-19T05:04:35.000Z</published>
    <updated>2019-07-19T05:29:08.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>箭头函数和普通的 <code>function</code> 一样，可以接受参数然后返回值，但是它没有自己的 <code>this</code>、<code>arguments</code> 等，且不能当作构造函数使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = a + b</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅有一条语句时，可不写函数体的花括号，且这条语句的值会当作返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于：(a, b) =&gt; &#123; return a + b &#125;</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>仅有一个参数的时候，圆括号可写可不写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> absolute = <span class="function">(<span class="params">a</span>) =&gt;</span> a &gt; <span class="number">0</span> ? a : <span class="number">-1</span> * a</span><br><span class="line"><span class="keyword">const</span> absolute = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123; <span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : <span class="number">-1</span> * a &#125;</span><br></pre></td></tr></table></figure><p>没有参数时，箭头前写一对空的圆括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logNow = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"><span class="keyword">const</span> logNow = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>()) &#125;</span><br></pre></td></tr></table></figure><p>如果需要返回对象字面量如 <code>{ hello: &#39;world!&#39; }</code>，或使用解构语法拿到唯一的参数，必须用圆括号把字面量或解构包裹起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildObject = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123; <span class="attr">text</span>: str &#125;    <span class="comment">// 错误❌</span></span><br><span class="line"><span class="keyword">const</span> buildObject = <span class="function">(<span class="params">str</span>) =&gt;</span> (&#123; <span class="attr">text</span>: str &#125;)  <span class="comment">// 正确✅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildObject = &#123; text &#125; =&gt; alert(text)   <span class="comment">// 错误❌</span></span><br><span class="line"><span class="keyword">const</span> buildObject = <span class="function">(<span class="params">&#123; text &#125;</span>) =&gt;</span> alert(text) <span class="comment">// 正确✅</span></span><br></pre></td></tr></table></figure><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="没有自己的-this"><a href="#没有自己的-this" class="headerlink" title="没有自己的 this"></a>没有自己的 <code>this</code></h2><p>箭头函数不会绑定 <code>this</code> 的值，它的 <code>this</code> 和其上一级作用域相同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line"><span class="comment">// 在 node 中为空对象 &#123;&#125;，浏览器中为 window</span></span><br><span class="line"><span class="built_in">console</span>.log(that)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFunc</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'---- Function ----'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// this：调用 addFunc 的实例</span></span><br><span class="line">  <span class="comment">// node 中为 global，浏览器中为 window</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// node：false；浏览器：true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'that === this:   '</span>, that === <span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// node：true；浏览器：true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'global === this: '</span>, global === <span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'---- Function ----\n\n'</span>)</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addArrowFunc = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'---- Arrow Function ----'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// this：从外部（全局环境）继承来的 this</span></span><br><span class="line">  <span class="comment">// node 中即空对象 &#123;&#125;，浏览器中为 window</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// node：true；浏览器：true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'that === this:   '</span>, that === <span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// node：false；浏览器：true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'global === this: '</span>, global === <span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'---- Arrow Function ----\n\n'</span>)</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addArrowFunc(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">addFunc(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="不能作为构造函数"><a href="#不能作为构造函数" class="headerlink" title="不能作为构造函数"></a>不能作为构造函数</h2><p>箭头函数不能用于构造函数，因此也没有自己的 <code>prototype</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age  = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StudentArrowFunc = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age  = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student &#123;name: "Xiaoming", age: 22&#125;</span></span><br><span class="line"><span class="keyword">const</span> student1 = <span class="keyword">new</span> Student(<span class="string">'Xiaoming'</span>, <span class="number">22</span>)</span><br><span class="line"><span class="comment">// TypeError: StudentArrowFunc is not a constructor</span></span><br><span class="line"><span class="keyword">const</span> student2 = <span class="keyword">new</span> StudentArrowFunc(<span class="string">'Xiaohua'</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(StudentArrowFunc.prototype);</span><br></pre></td></tr></table></figure><h2 id="在类中的表现"><a href="#在类中的表现" class="headerlink" title="在类中的表现"></a>在类中的表现</h2><p>在 ES6 的 class 中使用箭头函数时，事实上是为每个实例都添加了一个属性，这个属性的值是这个箭头函数的<strong>拷贝</strong>，而方法的定义则是挂载至类的 <code>prototype</code>，通过原型链调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(<span class="string">`This is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>-years-old <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 相当于在 constructor 中加入 this.sayHiArrowFunc = () =&gt; ...</span></span><br><span class="line">  sayHiArrowFunc = <span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="string">`This is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>-years-old <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student1 = <span class="keyword">new</span> Student(<span class="string">'Xiaoming'</span>, <span class="number">22</span>)</span><br><span class="line"><span class="keyword">const</span> student2 = <span class="keyword">new</span> Student(<span class="string">'Xiaohong'</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;constructor: ƒ, sayHi: ƒ&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype)</span><br><span class="line"><span class="comment">// Student &#123;sayHiArrowFunc: ƒ, name: "Xiaoming", age: 22&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(student1)</span><br><span class="line"><span class="comment">// Student &#123;sayHiArrowFunc: ƒ, name: "Xiaohong", age: 16&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(student2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(student1.sayHi === student2.sayHi)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(student1.sayHi === Student.prototype.sayHi)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(student1.sayHiArrowFunc === student2.sayHiArrowFunc)</span><br></pre></td></tr></table></figure><p>由于箭头函数定义的方法是每个对象自身的属性，我们在继承的时候，被继承者不仅会继承类父类原型上的属性和方法，也会继承其实例上的属性和方法，于是就会有下面这种情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  print = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'print a'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  print() &#123; <span class="built_in">console</span>.log(<span class="string">'print b'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会输出 print a</span></span><br><span class="line"><span class="keyword">new</span> B().print()</span><br></pre></td></tr></table></figure><p>以上代码执行时，<code>new B()</code> 中的 <code>print()</code> 来自于 A 类的实例属性 <code>print</code>，它直接挂在实例的 <code>this</code> 上，所以其优先级反而会比自身的 <code>print()</code> 方法优先级更高，因此执行的输出是 <code>print a</code>。以上代码相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'print a'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承自 A</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'print a'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过原型实现继承</span></span><br><span class="line">B.__proto__ = A;</span><br><span class="line">B.prototype.__proto__ === A.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 B 自身定义的 print 方法</span></span><br><span class="line">B.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'print b'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> B().print();</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>箭头函数可以很好地简化代码，比如在没有 <code>Set</code> 的 polyfill 时的去重：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrUnique = arr.filter(<span class="function"><span class="keyword">function</span> <span class="title">onlyUnique</span>(<span class="params">val, i, arr</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(val) === i</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="keyword">const</span> arrUnique = arr.filter(<span class="function">(<span class="params">val, i, arr</span>) =&gt;</span> arr.indexOf(val) === i)</span><br></pre></td></tr></table></figure><p>在 React 的事件处理器中，使用箭头函数可以很方便地解决每次都需要手动 <code>bind(this)</code> 的问题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// 如果不绑定 this，在严格模式下这里是 undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123; <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">  render() &#123; <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="何时不应使用"><a href="#何时不应使用" class="headerlink" title="何时不应使用"></a>何时不应使用</h2><p>在对象字面量中使用时，箭头函数的 <code>this</code> 并不会绑定至对象本身，而是其上一级作用域，因此无法访问或操作对象的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  funcLog() &#123;</span><br><span class="line">  <span class="comment">// 指向 obj</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  arrFuncLog: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// node 指向空对象 &#123;&#125;，浏览器指向 window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.funcLog()</span><br><span class="line">obj.arrFuncLog()</span><br></pre></td></tr></table></figure><p>在某些需要访问调用者（即 <code>this</code>）的回调函数中也不要使用箭头函数，比如下面是想在按钮点击的时候切换类名，但是使用箭头函数会使得 <code>this</code> 并不指向调用它的按钮：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// this 等于上一级作用域的 this</span></span><br><span class="line">  <span class="keyword">this</span>.classList.toggle(<span class="string">'active'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面也说过，箭头函数定义的属性会在每个实例都拷贝一份，因此在包含大量的组件实例（如一个长列表）时应当避免使用箭头函数，否则会有性能上的损失，如<a href="https://medium.com/@charpeni/arrow-functions-in-class-properties-might-not-be-as-great-as-we-think-3b3551c440b1" target="_blank" rel="noopener">Medium 上 @charpeni 做的一份测试</a>，渲染 100 个组件时的性能：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4QBMRXhpZgAATU0AKgAAAAgAAgESAAMAAAABAAEAAIdpAAQAAAABAAAAJgAAAAAAAqACAAQAAAABAAAFeKADAAQAAAABAAAC1wAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/+IH6ElDQ19QUk9GSUxFAAEBAAAH2GFwcGwCIAAAbW50clJHQiBYWVogB9kAAgAZAAsAGgALYWNzcEFQUEwAAAAAYXBwbAAAAAAAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1hcHBsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZGVzYwAAAQgAAABvZHNjbQAAAXgAAAWcY3BydAAABxQAAAA4d3RwdAAAB0wAAAAUclhZWgAAB2AAAAAUZ1hZWgAAB3QAAAAUYlhZWgAAB4gAAAAUclRSQwAAB5wAAAAOY2hhZAAAB6wAAAAsYlRSQwAAB5wAAAAOZ1RSQwAAB5wAAAAOZGVzYwAAAAAAAAAUR2VuZXJpYyBSR0IgUHJvZmlsZQAAAAAAAAAAAAAAFEdlbmVyaWMgUkdCIFByb2ZpbGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG1sdWMAAAAAAAAAHwAAAAxza1NLAAAAKAAAAYRkYURLAAAALgAAAaxjYUVTAAAAJAAAAdp2aVZOAAAAJAAAAf5wdEJSAAAAJgAAAiJ1a1VBAAAAKgAAAkhmckZVAAAAKAAAAnJodUhVAAAAKAAAApp6aFRXAAAAFgAAAsJuYk5PAAAAJgAAAthjc0NaAAAAIgAAAv5oZUlMAAAAHgAAAyBpdElUAAAAKAAAAz5yb1JPAAAAJAAAA2ZkZURFAAAALAAAA4prb0tSAAAAFgAAA7ZzdlNFAAAAJgAAAth6aENOAAAAFgAAA8xqYUpQAAAAGgAAA+JlbEdSAAAAIgAAA/xwdFBPAAAAJgAABB5ubE5MAAAAKAAABERlc0VTAAAAJgAABB50aFRIAAAAJAAABGx0clRSAAAAIgAABJBmaUZJAAAAKAAABLJockhSAAAAKAAABNpwbFBMAAAALAAABQJydVJVAAAAIgAABS5hckVHAAAAJgAABVBlblVTAAAAJgAABXYAVgFhAGUAbwBiAGUAYwBuAP0AIABSAEcAQgAgAHAAcgBvAGYAaQBsAEcAZQBuAGUAcgBlAGwAIABSAEcAQgAtAGIAZQBzAGsAcgBpAHYAZQBsAHMAZQBQAGUAcgBmAGkAbAAgAFIARwBCACAAZwBlAG4A6AByAGkAYwBDHqUAdQAgAGgA7ABuAGgAIABSAEcAQgAgAEMAaAB1AG4AZwBQAGUAcgBmAGkAbAAgAFIARwBCACAARwBlAG4A6QByAGkAYwBvBBcEMAQzBDAEOwRMBD0EOAQ5ACAEPwRABD4ERAQwBDkEOwAgAFIARwBCAFAAcgBvAGYAaQBsACAAZwDpAG4A6QByAGkAcQB1AGUAIABSAFYAQgDBAGwAdABhAGwA4QBuAG8AcwAgAFIARwBCACAAcAByAG8AZgBpAGyQGnUoACAAUgBHAEIAIIJyX2ljz4/wAEcAZQBuAGUAcgBpAHMAawAgAFIARwBCAC0AcAByAG8AZgBpAGwATwBiAGUAYwBuAP0AIABSAEcAQgAgAHAAcgBvAGYAaQBsBeQF6AXVBeQF2QXcACAAUgBHAEIAIAXbBdwF3AXZAFAAcgBvAGYAaQBsAG8AIABSAEcAQgAgAGcAZQBuAGUAcgBpAGMAbwBQAHIAbwBmAGkAbAAgAFIARwBCACAAZwBlAG4AZQByAGkAYwBBAGwAbABnAGUAbQBlAGkAbgBlAHMAIABSAEcAQgAtAFAAcgBvAGYAaQBsx3y8GAAgAFIARwBCACDVBLhc0wzHfGZukBoAIABSAEcAQgAgY8+P8GWHTvZOAIIsACAAUgBHAEIAIDDXMO0w1TChMKQw6wOTA7UDvQO5A7oDzAAgA8ADwQO/A8YDrwO7ACAAUgBHAEIAUABlAHIAZgBpAGwAIABSAEcAQgAgAGcAZQBuAOkAcgBpAGMAbwBBAGwAZwBlAG0AZQBlAG4AIABSAEcAQgAtAHAAcgBvAGYAaQBlAGwOQg4bDiMORA4fDiUOTAAgAFIARwBCACAOFw4xDkgOJw5EDhsARwBlAG4AZQBsACAAUgBHAEIAIABQAHIAbwBmAGkAbABpAFkAbABlAGkAbgBlAG4AIABSAEcAQgAtAHAAcgBvAGYAaQBpAGwAaQBHAGUAbgBl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GTt9C/0P9vof8/RP9C/gB9xPnn3/AKtD7jKT8Unf6F/of7fQ/wCfon+hfwAe4ylQsNJ2bY2VsbK2NlbGytjZWxsrY2VsbK2NlbGytjZWxsrY2VsbK2NlbGytjZWxsqcJDk8ZeK/0P9vof8/RP5/Qv4Ff3Y/iXPkl/Tdf3Yp3zfP8O58kvjP/AKF/n/Q38Cv7sU7ZP+Hc+SXxn+h/t9D/AJ+ifz+hfwK/uxXl+Hc+SX9N1/dinfN/w7nyS/X/ANv9kfwK/uxUu5/w7nySKGE2pxjJTrGgbRflNpOzxd2cY5mm0IGw2wAUiTBh9iyPUhZoHqwaZGwi27M6sVyVp8BO1/of7fQ/5+ifz+hfwK/uxXl+Hc+SVVgnuGizEsamLC0oVq+/kaFl5PYM88J4IBtGlKnXsDKStXLUlQYBrlLQhAozvQuyEytV5VTOOX6Qr+7FO+b/AIdv5JFuMOjX0BDJUp2gkDFsPHY3TVoCvW7Ji07QBvYESJKdERtIQcPKKHFbsVtIFULAwriYjX7LWrDzj+kK/uxUu5/w7nyS/wBEDFHCY4+C/wBD/b6H/P0T+f0L+BX92K8vw7nyS/puv7sU75v+Hc+SX9N1/dipef4dz5JfGf6H+30P+fon8/oX8Cv7sU7Zfh3Pkl/TYfcZPfsu+a31lb6yt9ZW+srfWVvrK31lb6yt9ZW+srfWVvrK31lb6yt9ZW+srfWVvrKnORJPKX6aB7rLl1VctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVcuqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrl1VctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVcuqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrltVctqrl1X+t/P6F/Ar+7H9X1/dj+r6/ux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LCjULFjpFQsIgiHSdJ0lvA9o9P4KHe0XBksdIqFi2C2Cx0nSKnvnYO878Hbf0rpfReRRcogvKCr5jv8AWilsnqE5U8lETJ5l/uEwqnkenwXZPV+DtPcE5FPMRPuPNRMIovdQ/wBFsi94b5jfMtgXunkgqXVBOFE8xcogvKHqHc+B7R6fwUO9o5RBEwovdQ8kFS6nkJhouUQ80PUO5987B3naXT6u2/pXRfp5+m4q51vgvjS/hOy+r8HaO5pcuX0vp5F/ovrcvkvpe/g+0en8FDvaLk4L6f6L6XwIXv782o5nd3FU3FU3FU3FU3FU3FU3FUdVqP59ma9WkryV5K8leSvJXkrxXuX2dWtUjYRNImkTSJpE0iYIxEM/xF/6fP8A0h//xAAlEQEBAQAABQMEAwAAAAAAAAAAAQIQESExUFFwoCBgkLAycYD/2gAIAQMBCT8A+D9E9qKv01fxYX5mGWWGGGGGGGGGGGGGGGGU+Ft6fAa9Pa+qqqqqqqqqqqq/dk8jEREREREREREROERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERET9DLVaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaX2vvwLNco1zjfLhvr6cK1zXk1zb5e0153j/ACd+F664V3dvaSJ1TqnSO7sn9J1TqnSO8dvy/wARERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERET9TFKlSpUqVKniIiIiJ99SJEiRIkSJ4iIiIicZ4a+xM/2pWmmmmmml8RVVVVV8PERERE/Hp//2Q==" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数 - MDN</a></li><li><a href="https://medium.com/@charpeni/arrow-functions-in-class-properties-might-not-be-as-great-as-we-think-3b3551c440b1" target="_blank" rel="noopener">Arrow Functions in Class Properties Might Not Be As Great As We Think</a></li><li><a href="https://github.com/dwqs/blog/issues/67" target="_blank" rel="noopener">ES6 Class Methods 定义方式的差异</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;p&gt;箭头函数和普通的 &lt;code&gt;function&lt;/code&gt; 一样，可以接受参数然后返回值，但是它没有自己的 &lt;code&gt;this&lt;/cod
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://sr2k.top/blog/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://sr2k.top/blog/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>树和二叉树</title>
    <link href="https://sr2k.top/blog/2019/04/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://sr2k.top/blog/2019/04/18/树和二叉树/</id>
    <published>2019-04-18T06:32:12.000Z</published>
    <updated>2019-07-19T05:03:34.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-1-树的类型和定义"><a href="#6-1-树的类型和定义" class="headerlink" title="6.1 树的类型和定义"></a>6.1 树的类型和定义</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li><p>结点：数据元素+若干指向子树的分支</p></li><li><p>结点的度：分枝的个数</p></li><li><p>树的度：树中所有结点的度的最大值</p></li><li><p>叶子结点：度为零的结点</p></li><li><p>分支结点：度大于零的结点</p></li><li><p>从根到结点的路径：由从根到该结点所经分支和结点构成</p></li><li><p>一些结点之间的关系：</p><ul><li>孩子结点</li><li>双亲结点</li><li>兄弟结点</li><li>祖先结点</li><li>子孙结点</li></ul></li><li><p>结点的层次：假设根结点的层次为1，则第l层的结点的子树跟结点的层次为l+1</p></li><li><p>树的深度：树中叶子结点所在的最大层次</p></li><li><p>森林：是$m$（$m\geqslant 0$）棵互不相交的树的集合</p><p>任何一个非空树是一个二元组：$Tree = (root, F)$</p><ul><li>$root$被称为根结点</li><li>$F$被称为子树森林</li></ul></li><li><p>有向树（一般我们讨论的都是有向树）</p><ul><li>有确定的根</li><li>树根和子树根之间为有向关系</li></ul></li><li><p>有序树与无序树：子树之间是否存在次序关系（一般我们讨论的都是无序树）</p></li></ul><h2 id="和线性结构的比较"><a href="#和线性结构的比较" class="headerlink" title="和线性结构的比较"></a>和线性结构的比较</h2><table><thead><tr><th>线性结构</th><th>树结构</th></tr></thead><tbody><tr><td>第一个数据元素（无前驱）</td><td>根结点（无前驱）</td></tr><tr><td>最后一个数据元素（无后继）</td><td>多个叶子结点（无后继）</td></tr><tr><td>其他数据元素（一个前驱、一个后继）</td><td>树中其他结点（一个前驱、多个后继）</td></tr></tbody></table><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>$D$是具有相同特性的数据元素的集合</p><h3 id="数据关系"><a href="#数据关系" class="headerlink" title="数据关系"></a>数据关系</h3><p>若$D$为空集，则称为空树；</p><p>若$D$仅含一个数据元素，则$R$为空集，否则$R={H}$，$H$是如下二元关系：</p><ol><li>在$D$中存在唯一的成为根的数据元素<code>root</code>，它在$H$下无前驱；</li><li>若$D-{root} \ne \Phi$，则存在$D-{root}$的一个划分$D_1$，$D_2$，…，$D_m$（$m&gt;0$），对任意$j\ne k(1\leqslant j, k\leqslant m)$有$D_j\cap D_k=\Phi$，且对任意的$i$（$1\leqslant i\leqslant m$），惟一存在数据元素$x_i\in D_i$，有$&lt;root, x_i&gt;\in H$；</li><li>对应于$D-{root} \ne \Phi$的划分，$H-{&lt;root, x_1&gt;, …, &lt;root, x_m&gt;}$有惟一的一个划分$H_1$，$H_2$，…，$H_n$，对任意$j\ne k(1\leqslant j, k\leqslant m)$有$H_j\cap H_k=\Phi$，且对任意的$i$（$1\leqslant i\leqslant m$），$H_i$是$D_i$上的二元关系，$(D_i, {H_i})$是一颗符合本定义的树，称为根<code>root</code>的子树。</li></ol><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul><li><code>Root(T)</code></li><li><code>Value(T, cur_e)</code></li><li><code>Parent(T, cur_e)</code></li><li><code>LeftChild(T, cur_e)</code></li><li><code>RightSibling(T, cur_e)</code></li><li><code>TreeEmpty(T)</code></li><li><code>TreeDepth(T)</code></li><li><code>TraverseTree(T, Visit())</code></li></ul><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul><li><code>InitTree(&amp;T)</code></li><li><code>CreateTree(&amp;T, definition)</code></li><li><code>Assign(T, cur_e, value)</code></li><li><code>InsertChild(&amp;T, &amp;p, i, e)</code></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><code>DestroyTree(&amp;T)</code></li><li><code>ClearTree(&amp;T)</code></li><li><code>DeleteChild(&amp;T, &amp;p, i)</code></li></ul><h1 id="6-2-二叉树"><a href="#6-2-二叉树" class="headerlink" title="6.2 二叉树"></a>6.2 二叉树</h1><p>二叉树或为空树，或是由一个根结点加上两棵分别称为左子树和右子树的、互不交的二叉树组成。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A --- B</span><br><span class="line"></span><br><span class="line">B --- C</span><br><span class="line">C --- D</span><br><span class="line"></span><br><span class="line">A --- E</span><br><span class="line">E --- F</span><br><span class="line">F --- G</span><br><span class="line">G --- H</span><br><span class="line">G --- K</span><br></pre></td></tr></table></figure><p>二叉树的五种基本形态：</p><ul><li>空树</li><li>只含一个根结点</li><li>左子树为空树，右子树不为空</li><li>左子树不为空，右子树为空树</li><li>左右子树都不为空</li></ul><h2 id="两类特殊的二叉树"><a href="#两类特殊的二叉树" class="headerlink" title="两类特殊的二叉树"></a>两类特殊的二叉树</h2><ol><li>满二叉树：深度为$k$且含有$2^k-1$个结点的二叉树</li><li>完全二叉树：书中所含的$n$个结点和满二叉树中编号为$1$至$n$的结点一一对应</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">subgraph 满二叉树</span><br><span class="line">  a1 --&gt; b1</span><br><span class="line">  a1 --&gt; c1</span><br><span class="line">  b1 --&gt; d1</span><br><span class="line">  b1 --&gt; e1</span><br><span class="line">  c1 --&gt; f1</span><br><span class="line">  c1 --&gt; g1</span><br><span class="line">  d1 --&gt; h1</span><br><span class="line">  d1 --&gt; i1</span><br><span class="line">  e1 --&gt; j1</span><br><span class="line">  e1 --&gt; k1</span><br><span class="line">  f1 --&gt; l1</span><br><span class="line">  f1 --&gt; m1</span><br><span class="line">  g1 --&gt; n1</span><br><span class="line">  g1 --&gt; o1</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph 完全二叉树</span><br><span class="line">  a2 --&gt; b2</span><br><span class="line">  a2 --&gt; c2</span><br><span class="line">  b2 --&gt; d2</span><br><span class="line">  b2 --&gt; e2</span><br><span class="line">  c2 --&gt; f2</span><br><span class="line">  c2 --&gt; g2</span><br><span class="line">  d2 --&gt; h2</span><br><span class="line">  d2 --&gt; i2</span><br><span class="line">  e2 --&gt; j2</span><br><span class="line">  e2 --&gt; k2</span><br><span class="line">  f2 --&gt; l2</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>在二叉树的第$i$层上至多有$2^{i-1}$个结点（$i\geqslant 1$）；</li><li>深度为$k$的二叉树上至多含$2^k-1$个结点（$k\geqslant 1$）；</li><li>对于任何一棵二叉树，若他含有$n_0$个叶子结点、$n_2$个度为2的结点，则必存在关系式：$n_0=n_2+1$；</li><li>具有$n$个结点的完全二叉树的深度为$\lfloor\log_2n\rfloor+1$；</li><li>若对含$n$个结点的二叉树从上到下且从左到右进行$1$至$n$的编号，则对二叉树中任意一个编号为$i$的结点：</li></ol><ul><li>若$i=1$，则该结点事二叉树的根，无双亲；否则，编号为$\lfloor i/2\rfloor$的结点为其双亲结点；</li><li>若$2i&gt;n$，则该结点无左孩子结点；否则，编号为$2i$的结点为其左孩子结点；</li><li>若$2i+1&gt;n$，则该结点无右孩子结点；否则，编号为$2i+1$的结点为其右孩子结点。</li></ul><h2 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><ul><li><code>Root(T)</code></li><li><code>Value(T, e)</code></li></ul><p>关系查找：</p><ul><li><code>Parent(T, e)</code></li><li><code>LeftChild(T, e)</code></li><li><code>RightChild(T, e)</code></li><li><code>LeftSibling(T, e)</code></li><li><code>RightSibling(T, e)</code></li></ul><p>状态查询：</p><ul><li><code>BiTreeEmpty(T)</code></li><li><code>BiTreeDepth(T)</code></li></ul><p>遍历：</p><ul><li><code>PreIrderTraverse(T, Visit())</code></li><li><code>InOrderTraverse(T, Visit())</code></li><li><code>PostOrderTraverse(T, Visit())</code></li><li><code>LevelOrderTraverse(T, Visit())</code></li></ul><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><ul><li><code>InitBiTree(&amp;T)</code></li><li><code>Assign(T, &amp;e, value)</code></li><li><code>CreateBiTree(&amp;T, definition)</code></li><li><code>InsertChild(T, p, LR, c)</code></li></ul><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul><li><code>ClearBiTree(&amp;T)</code></li><li><code>DestroyBiTree(&amp;T)</code></li><li><code>DeleteChild(T, p, LR)</code></li></ul><h1 id="6-3-二叉树的存储结构"><a href="#6-3-二叉树的存储结构" class="headerlink" title="6.3 二叉树的存储结构"></a>6.3 二叉树的存储结构</h1><h2 id="二叉树的顺序存储表示"><a href="#二叉树的顺序存储表示" class="headerlink" title="二叉树的顺序存储表示"></a>二叉树的顺序存储表示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的最大结点数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100;</span></span><br><span class="line"><span class="comment">// 0 号但愿存储根结点</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure><p>补全成满二叉树（或完全二叉树）后，按照编号存储即可。</p><p>缺点：存储非完全二叉树时会造成空间浪费。</p><h2 id="二叉树的链式存储表示"><a href="#二叉树的链式存储表示" class="headerlink" title="二叉树的链式存储表示"></a>二叉树的链式存储表示</h2><h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">  TElemType      data;</span><br><span class="line">  <span class="comment">// 左右孩子指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h3 id="双亲链表"><a href="#双亲链表" class="headerlink" title="双亲链表"></a>双亲链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPTNode</span> &#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  <span class="comment">// 指向双亲的指针</span></span><br><span class="line">  <span class="keyword">int</span>       *parent;</span><br><span class="line">  <span class="comment">// 左、右孩子标志域</span></span><br><span class="line">  <span class="keyword">char</span>      LRTag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPTree</span> &#123;</span></span><br><span class="line">  BPTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">  <span class="comment">// 结点数目</span></span><br><span class="line">  <span class="keyword">int</span>     num_node;</span><br><span class="line">  <span class="comment">// 根结点的位置</span></span><br><span class="line">  <span class="keyword">int</span>     root;</span><br><span class="line">&#125; BPTree;</span><br></pre></td></tr></table></figure><h1 id="6-4-二叉树的遍历"><a href="#6-4-二叉树的遍历" class="headerlink" title="6.4 二叉树的遍历"></a>6.4 二叉树的遍历</h1><p>对于二叉树而言，可以有三条搜索路径：</p><ul><li>先上后下的按层次遍历;</li><li>先左（子树）后右（子树）的遍历；</li><li>先右（子树）后左（子树）的遍历；</li></ul><h2 id="先左后右的遍历算法"><a href="#先左后右的遍历算法" class="headerlink" title="先左后右的遍历算法"></a>先左后右的遍历算法</h2><h3 id="先（根）序的遍历算法"><a href="#先（根）序的遍历算法" class="headerlink" title="先（根）序的遍历算法"></a>先（根）序的遍历算法</h3><p>若二叉树为空树，则空操作，否则：</p><ol><li>访问跟结点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(BiTree T, <span class="keyword">void</span> (*visit)(TElemType &amp;e))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (T) &#123;</span><br><span class="line">    visit(T -&gt; data);</span><br><span class="line">    Preorder(T -&gt; lchild, visit);</span><br><span class="line">    Preorder(T -&gt; rchild, visit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中（根）序的遍历算法"><a href="#中（根）序的遍历算法" class="headerlink" title="中（根）序的遍历算法"></a>中（根）序的遍历算法</h3><p>若二叉树为空树，则空操作，否则：</p><ol><li>中序遍历左子树</li><li>访问跟结点</li><li>中序遍历右子树</li></ol><h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InorderTraverse</span><span class="params">(BiTree T, Status (*Visit)(TElemType e))</span> </span>&#123;</span><br><span class="line">  InitStack(S);</span><br><span class="line">  Push(S, T);</span><br><span class="line">  <span class="keyword">while</span> (!StackEmpty(S)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (GetTop(S, p) &amp;&amp; p)</span><br><span class="line">      Push(S, p -&gt; lchild);</span><br><span class="line">    Pop(S, p);</span><br><span class="line">    <span class="keyword">if</span> (!StackEmpty(S)) &#123;</span><br><span class="line">      Pop(S, p);</span><br><span class="line">      <span class="keyword">if</span> (!Visit(p -&gt; data))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">      Push(S, p -&gt; rchild);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后（根）序的遍历算法"><a href="#后（根）序的遍历算法" class="headerlink" title="后（根）序的遍历算法"></a>后（根）序的遍历算法</h3><p>若二叉树为空树，则空操作，否则：</p><ol><li>后序遍历左子树</li><li>中序遍历右子树</li><li>访问跟结点</li></ol><h2 id="二叉树遍历的应用"><a href="#二叉树遍历的应用" class="headerlink" title="二叉树遍历的应用"></a>二叉树遍历的应用</h2><h3 id="统计二叉树中叶子结点的个数"><a href="#统计二叉树中叶子结点的个数" class="headerlink" title="统计二叉树中叶子结点的个数"></a>统计二叉树中叶子结点的个数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountLeaf</span><span class="params">(BiTree T, <span class="keyword">int</span> &amp;count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (T) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((!T -&gt; lchild) &amp;&amp; (!T -&gt; rchild))</span><br><span class="line">      count++;</span><br><span class="line">    CountLeaf(T -&gt; lchild, count);</span><br><span class="line">    CountLeaf(T -&gt; rchild, count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的深度（后序遍历）"><a href="#求二叉树的深度（后序遍历）" class="headerlink" title="求二叉树的深度（后序遍历）"></a>求二叉树的深度（后序遍历）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!T)</span><br><span class="line">    depthval = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    depthL = Depth(T -&gt; lchild);</span><br><span class="line">    depthR = Depth(T -&gt; rchild);</span><br><span class="line">    depthval = <span class="number">1</span> + (depthL &gt; depthR ? depthL : depthR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depthval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制二叉树（后续遍历）"><a href="#复制二叉树（后续遍历）" class="headerlink" title="复制二叉树（后续遍历）"></a>复制二叉树（后续遍历）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree *<span class="title">CopyTree</span><span class="params">(BiTNode *T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!T)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (T -&gt; lchild)</span><br><span class="line">    newlptr = CopyTree(T -&gt; lchild);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    newlptr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (T -&gt; rchild)</span><br><span class="line">    newrptr = CopyTree(T -&gt; rchild);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    newrptr = <span class="literal">NULL</span>;</span><br><span class="line">  newnode = GetTreeNode(T -&gt; data, newlptr, newrptr);</span><br><span class="line">  <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立二叉树的存储结构"><a href="#建立二叉树的存储结构" class="headerlink" title="建立二叉树的存储结构"></a>建立二叉树的存储结构</h3><p>不同的定义方法有不同的存储方法。</p><h4 id="按给定的先序序列建立二叉链表"><a href="#按给定的先序序列建立二叉链表" class="headerlink" title="按给定的先序序列建立二叉链表"></a>按给定的先序序列建立二叉链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line">  if (ch == '')</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(T = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))</span><br><span class="line">      <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    T -&gt; data = ch;</span><br><span class="line">    CreateBiTree(T -&gt; lchild);</span><br><span class="line">    CreateBiTree(T -&gt; rchild);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按给定的表达式建立相应二叉树"><a href="#按给定的表达式建立相应二叉树" class="headerlink" title="按给定的表达式建立相应二叉树"></a>按给定的表达式建立相应二叉树</h4><p>// 略</p><h1 id="6-5-线索二叉树"><a href="#6-5-线索二叉树" class="headerlink" title="6.5 线索二叉树"></a>6.5 线索二叉树</h1><p>遍历二叉树的结果是求得结点的一个线性序列。</p><ul><li>指向该线性序列中的「前驱」和「后继」的指针，称作「线索」；</li><li>包含「线索」的存储结构，称作「线索链表」；</li><li>与其相应的二叉树，「线索二叉树」。</li></ul><p>线性链表的约定：在二叉链表的结点中增加两个标志域，并作如下规定：</p><ul><li>若该结点的左子树不空，则<code>lchild</code>域的指针指向其左子树，且左标志域的值为<code>0</code>；否则，<code>lchild</code>域的指针指向其「前驱」，且左标志的值为<code>1</code>；</li><li>若该结点的右子树不空，则<code>rchild</code>域的指针指向其右子树，且右标志域的值为<code>0</code>；否则，<code>lchild</code>域的指针指向其「后继」，且右标志的值为<code>1</code>；</li></ul><p>线性链表的结构描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  <span class="comment">// Link == 0：指针</span></span><br><span class="line">  Link,</span><br><span class="line">  <span class="comment">// Thread == 1：线索</span></span><br><span class="line">  Thread</span><br><span class="line">&#125; PointerThr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> &#123;</span></span><br><span class="line">  TElemType        data;</span><br><span class="line">  <span class="comment">// 左右指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">  <span class="comment">// 左右标志</span></span><br><span class="line">  PointerThr       LTag, RTag;</span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><h2 id="线索链表的遍历算法"><a href="#线索链表的遍历算法" class="headerlink" title="线索链表的遍历算法"></a>线索链表的遍历算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = firstNode(T); p; p = Succ(p))</span><br><span class="line">  Visit(p);</span><br></pre></td></tr></table></figure><p>以中序线索化链表的遍历算法为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T, Status (*Visit)(TElemType e))</span> </span>&#123;</span><br><span class="line">  <span class="comment">// p指向根结点</span></span><br><span class="line">  p = T -&gt; lchild;</span><br><span class="line">  <span class="comment">// 空树或遍历结束时p==T</span></span><br><span class="line">  <span class="keyword">while</span> (p != T) &#123;</span><br><span class="line">    <span class="keyword">while</span> (P -&gt; LTag == Link)</span><br><span class="line">      p = p -&gt; lchild;</span><br><span class="line">    <span class="keyword">if</span> (!Visit(p -&gt; data))</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">while</span> (p -&gt; RTag == Thread &amp;&amp; p -&gt; rchild != T) &#123;</span><br><span class="line">    <span class="comment">// 访问后继结点</span></span><br><span class="line">      p = p -&gt; rchild;</span><br><span class="line">      Visit(p -&gt; data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p行进至右子树根</span></span><br><span class="line">    p = p -&gt; rchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建立线索链表"><a href="#建立线索链表" class="headerlink" title="建立线索链表"></a>建立线索链表</h2><p>在中序遍历的过程中修改结点的左、右指针域，以保存当前访问结点的「前驱」和「后继」信息。遍历过程中，附设指针<code>pre</code>，并始终保持指针<code>pre</code>指向当前访问的、指针<code>p</code>所指结点的前驱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">    InThreading(p -&gt; lchild);</span><br><span class="line">    <span class="keyword">if</span> (!p -&gt; lchild) &#123;</span><br><span class="line">      p -&gt; LTag = Thread;</span><br><span class="line">      p -&gt; lchild = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p -&gt; rchild) &#123;</span><br><span class="line">      p -&gt; RTag = Thread;</span><br><span class="line">      p -&gt; rchild = p;</span><br><span class="line">    &#125;</span><br><span class="line">    InThreading(p -&gt; rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-6-树和森林的表示方法"><a href="#6-6-树和森林的表示方法" class="headerlink" title="6.6 树和森林的表示方法"></a>6.6 树和森林的表示方法</h1><h2 id="树的三种存储结构"><a href="#树的三种存储结构" class="headerlink" title="树的三种存储结构"></a>树的三种存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span> &#123;</span></span><br><span class="line">  Elem data;</span><br><span class="line">  <span class="comment">// 双亲位置域</span></span><br><span class="line">  <span class="keyword">int</span>  parent;</span><br><span class="line">&#125; PTNode;</span><br></pre></td></tr></table></figure><p>树结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">  <span class="keyword">int</span>    r, n;</span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure><p>如树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A --- B</span><br><span class="line">A --- C</span><br><span class="line">A --- D</span><br><span class="line">C --- E</span><br><span class="line">C --- F</span><br><span class="line">F --- G</span><br></pre></td></tr></table></figure><p>可以存储为：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>data</code></th><th style="text-align:center"><code>parent</code></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">A</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">B</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">C</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">E</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">F</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">G</td><td style="text-align:center">5</td></tr></tbody></table><h3 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>           child;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  Elem          data;</span><br><span class="line">  ChildPtr      firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  CTBox         nodes[MAX_TREE_SIZE];</span><br><span class="line">  <span class="keyword">int</span>           n, r;</span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p>如上链表可表示为：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>data</code></th><th style="text-align:center"><code>firstchild</code>（此处写的是链表）</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">A</td><td style="text-align:center">1 -&gt; 2 -&gt; 3</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">B</td><td style="text-align:center">^</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">C</td><td style="text-align:center">4 -&gt; 5</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D</td><td style="text-align:center">^</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">E</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">F</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">G</td><td style="text-align:center">^</td></tr></tbody></table><h3 id="树的二叉链表（孩子-兄弟链表）"><a href="#树的二叉链表（孩子-兄弟链表）" class="headerlink" title="树的二叉链表（孩子-兄弟链表）"></a>树的二叉链表（孩子-兄弟链表）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">  Elem data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">    // 相当于二叉树的左指针，指向其第一个子结点</span></span><br><span class="line"><span class="class">    *<span class="title">firstchild</span>,</span></span><br><span class="line"><span class="class">  // 相当于二叉树的右指针，指向其兄弟结点</span></span><br><span class="line"><span class="class">  *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上文的树，可以表示为这样的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A --- |左|B</span><br><span class="line">B --- |右|C</span><br><span class="line">C --- |左|E</span><br><span class="line">C --- |右|D</span><br><span class="line">E --- |右|F</span><br><span class="line">F --- |左|G</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>data</code></th><th style="text-align:center"><code>firstchild</code></th><th style="text-align:center"><code>nextsibling</code></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">A</td><td style="text-align:center">1</td><td style="text-align:center">^</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">B</td><td style="text-align:center">^</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">C</td><td style="text-align:center">4</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D</td><td style="text-align:center">^</td><td style="text-align:center">^</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">E</td><td style="text-align:center">^</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">F</td><td style="text-align:center">6</td><td style="text-align:center">^</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">G</td><td style="text-align:center">^</td><td style="text-align:center">^</td></tr></tbody></table><h2 id="森林和二叉树"><a href="#森林和二叉树" class="headerlink" title="森林和二叉树"></a>森林和二叉树</h2><p>设森林：$\left{ \begin{align<em>}F &amp;= (T_1, T_2, …, T_n)\T_1 &amp;= (root, t_{11}, t_{12}, …, t_{1m})\end{align</em>} \right.$</p><p>二叉树：$B = (LBT, Node(root), RBT);$</p><h3 id="由森林转化成二叉树"><a href="#由森林转化成二叉树" class="headerlink" title="由森林转化成二叉树"></a>由森林转化成二叉树</h3><ul><li>若$F=\Phi$，则$B=\Phi$；</li><li>否则：<ul><li>由$ROOT(T_1)$对应的到$Node(root)$（第一棵树的根变成二叉树的根）；</li><li>由$(t_{11}, t_{12}, … t_{1m})$对应得到$LBT$（第一棵树的子树森林变成二叉树的左子树）；</li><li>由$(T_2, T_3, …, T_N)$对应得到$RBT$（除去第一棵树的森林得到二叉树的右子树）。</li></ul></li></ul><p>如森林：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph T1</span><br><span class="line">A --- B</span><br><span class="line">A --- E</span><br><span class="line">A --- K</span><br><span class="line">B --- D</span><br><span class="line">B --- I</span><br><span class="line">E --- J</span><br><span class="line">D --- H</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph T2</span><br><span class="line">C --- F</span><br><span class="line">C --- M</span><br><span class="line">F --- L</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph T3</span><br><span class="line">G --- N</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可以转化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A --- |L|B</span><br><span class="line">B --- |L|D</span><br><span class="line">D --- |L|H</span><br><span class="line">D --- |R|I</span><br><span class="line">B --- |R|E</span><br><span class="line">E --- |L|J</span><br><span class="line">E --- |R|K</span><br><span class="line">A --- |R|C</span><br><span class="line">C --- |L|F</span><br><span class="line">F --- |L|L</span><br><span class="line">F --- |R|M</span><br><span class="line">C --- |R|G</span><br><span class="line">G --- |L|N</span><br></pre></td></tr></table></figure><h3 id="二叉树转化成森林"><a href="#二叉树转化成森林" class="headerlink" title="二叉树转化成森林"></a>二叉树转化成森林</h3><ul><li>若$B=\Phi$，则$F=\Phi$；</li><li>否则：<ul><li>由$Node(root)$对应的到$ROOT(T_1)$；</li><li>由$LBT$对应得到$(t_{11}, t_{12}, … t_{1m})$；</li><li>由$RBT$对应得到$(T_2, T_3, …, T_N)$。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;6-1-树的类型和定义&quot;&gt;&lt;a href=&quot;#6-1-树的类型和定义&quot; class=&quot;headerlink&quot; title=&quot;6.1 树的类型和定义&quot;&gt;&lt;/a&gt;6.1 树的类型和定义&lt;/h1&gt;&lt;h2 id=&quot;基本术语&quot;&gt;&lt;a href=&quot;#基本术语&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://sr2k.top/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="严蔚敏数据结构与算法" scheme="https://sr2k.top/blog/tags/%E4%B8%A5%E8%94%9A%E6%95%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="学习" scheme="https://sr2k.top/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="https://sr2k.top/blog/2019/04/17/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://sr2k.top/blog/2019/04/17/栈和队列/</id>
    <published>2019-04-17T08:09:23.000Z</published>
    <updated>2019-07-19T05:03:34.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-1-栈的类型定义"><a href="#3-1-栈的类型定义" class="headerlink" title="3.1 栈的类型定义"></a>3.1 栈的类型定义</h1><h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>$$<br>D = {a_i | a_i \in \texttt{ElemSet}, i = 1, 2, …, n, n \geqslant 0}<br>$$</p><h2 id="数据关系"><a href="#数据关系" class="headerlink" title="数据关系"></a>数据关系</h2><p>$$<br>R1 = {&lt;a_{i-1}, a_i&gt; | a_{i-1}, a_i \in D, i = 2, …, n}<br>$$</p><p>约定$a_n$端为栈顶，$a_1$端为栈底。</p><p><strong>后进先出</strong>：栈中元素依次按$a_1$、$a_@$、…、$a_n$入栈，而退栈的第一个元素应为栈顶元素。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="结构初始化"><a href="#结构初始化" class="headerlink" title="结构初始化"></a>结构初始化</h3><ul><li><p><code>InitStack(&amp;S)</code></p><ul><li>操作结果：构造一个空栈$S$</li></ul></li></ul><h3 id="销毁结构"><a href="#销毁结构" class="headerlink" title="销毁结构"></a>销毁结构</h3><ul><li><p><code>DestroyStack(&amp;S)</code></p><ul><li><p>初始条件：栈$S$已存在</p></li><li><p>操作结果：栈$S$被销毁</p></li></ul></li></ul><h3 id="引用型操作"><a href="#引用型操作" class="headerlink" title="引用型操作"></a>引用型操作</h3><ul><li><p><code>StackEmpty(S)</code></p><ul><li><p>初始条件：栈$S$已存在</p></li><li><p>操作结果：若栈$S$为空栈，则返回<code>TRUE</code>，否则返回<code>FALSE</code></p></li></ul></li><li><p><code>StackLength(S)</code></p><ul><li><p>初始条件：栈$S$已存在</p></li><li><p>操作结果：返回$S$的元素个数，即栈的长度</p></li></ul></li><li><p><code>GetTop(S, &amp;e)</code></p><ul><li><p>初始条件：栈$S$已存在，且非空</p></li><li><p>操作结果：用<code>e</code>返回$S$的栈顶元素</p></li></ul></li></ul><h3 id="加工型操作"><a href="#加工型操作" class="headerlink" title="加工型操作"></a>加工型操作</h3><ul><li><p><code>ClearStack(&amp;S)</code></p><ul><li><p>初始条件：栈$S$已存在</p></li><li><p>操作结果：将$S$清为空栈</p></li></ul></li><li><p><code>Push(&amp;S, e)</code>（入栈操作）</p><ul><li><p>初始条件：栈$S$已存在</p></li><li><p>操作结果：插入元素$e$为新的栈顶元素</p></li></ul></li><li><p><code>Pop(&amp;S, &amp;e)</code></p><ul><li><p>初始条件：栈$S$已存在且非空</p></li><li><p>操作结果：删除$S$的栈顶元素，并用<code>e</code>返回其值</p></li></ul></li></ul><h1 id="3-2-栈的应用举例"><a href="#3-2-栈的应用举例" class="headerlink" title="3.2 栈的应用举例"></a>3.2 栈的应用举例</h1><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>基于短除法：</p><p>$$<br>N = (N \div d) \times d + N \% d<br>$$</p><p>例如：$(1348)_{10} = (2504)_8$，其运算过程如下：</p><table><thead><tr><th style="text-align:center">$N$</th><th style="text-align:center">$N \div 8$</th><th style="text-align:center">$N\%8$</th></tr></thead><tbody><tr><td style="text-align:center">1348</td><td style="text-align:center">168</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">168</td><td style="text-align:center">21</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">2</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">2</td></tr></tbody></table><p>计算顺序：自上而下；输出顺序：自下而上。刚好符合栈后进先出的特点。</p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conversion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, N);</span><br><span class="line">    <span class="keyword">while</span> (N) &#123;</span><br><span class="line">        Push(S, N % <span class="number">8</span>);</span><br><span class="line">        N = N / <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(S)) &#123;</span><br><span class="line">        Pop(S, e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式中括号匹配的检验"><a href="#表达式中括号匹配的检验" class="headerlink" title="表达式中括号匹配的检验"></a>表达式中括号匹配的检验</h2><p>检验的方法用「期待的急迫程度」来描述：每出现一个左括号，就会急切地期待与之配对的右括号出现。</p><p>因此大致思路可以描述为：</p><ul><li><p>如果是左括号<code>(</code>、<code>[</code>或<code>{</code>，则入栈</p></li><li><p>如果是右括号，则先判断是否为空栈</p><ul><li><p>若栈空，则表明右括号多了</p></li><li><p>若栈不空，则使用<code>GetTop</code>判断是否匹配</p><ul><li><p>匹配：左括号出栈</p></li><li><p>不匹配：错误</p></li></ul></li></ul></li><li><p>表达式检验结束时：</p><ul><li><p>若栈空，则匹配正确</p></li><li><p>否则左括号多了</p></li></ul></li></ul><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matching</span><span class="params">(<span class="built_in">string</span> &amp;<span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= Length(<span class="built_in">exp</span>)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> of <span class="built_in">exp</span>[i] &#123;</span><br><span class="line">        <span class="keyword">case</span> 左括号:</span><br><span class="line">            Push(S, <span class="built_in">exp</span>[i]);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> 右括号:</span><br><span class="line">            <span class="keyword">if</span> (!StackEmpty(S) &amp;&amp; Match(GetTop(S), <span class="built_in">exp</span>[i])) &#123;</span><br><span class="line">                Pop(S, e);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!StackEmpty(S))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（我觉着其实这样更好：）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="string">'&#123;&#125;'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'()'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'[]'</span> <span class="keyword">in</span> s:</span><br><span class="line">        s = s.replace(<span class="string">'&#123;&#125;'</span>, <span class="string">''</span>)</span><br><span class="line">        s = s.replace(<span class="string">'[]'</span>, <span class="string">''</span>)</span><br><span class="line">        s = s.replace(<span class="string">'()'</span>, <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> s == <span class="string">''</span></span><br></pre></td></tr></table></figure><h2 id="行编辑程序"><a href="#行编辑程序" class="headerlink" title="行编辑程序"></a>行编辑程序</h2><p><code>#</code>为退格符，<code>@</code>为退行符（退格到行首）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (ch != EOF) &#123;</span><br><span class="line">    <span class="keyword">while</span> (ch != EOF &amp;&amp; ch != <span class="string">'\n'</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">                Pop(S, c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'@'</span>:</span><br><span class="line">                ClearStack(S);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Push(S, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迷宫求解"><a href="#迷宫求解" class="headerlink" title="迷宫求解"></a>迷宫求解</h2><p>通常使用「穷举求解」的方法：</p><ul><li><p>若当前位置「可通」，则纳入路径，继续前进</p></li><li><p>若当前位置「不可通」，则后退，换向探索</p></li><li><p>若四周均「不可通」，则从路径中删除</p></li></ul><p>TODO…</p><h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><p>TODO…</p><h2 id="实现递归"><a href="#实现递归" class="headerlink" title="实现递归"></a>实现递归</h2><p>TODO…</p><h1 id="3-3-栈类型的实现"><a href="#3-3-栈类型的实现" class="headerlink" title="3.3 栈类型的实现"></a>3.3 栈类型的实现</h1><p>类似于线性表的顺序映像实现，指向表尾的指针可以做为栈顶指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INCREMENT 10;</span></span><br><span class="line"></span><br><span class="line">typde <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="keyword">int</span>       stacksize;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><h1 id="3-4-队列的类型定义"><a href="#3-4-队列的类型定义" class="headerlink" title="3.4 队列的类型定义"></a>3.4 队列的类型定义</h1><h2 id="数据对象-1"><a href="#数据对象-1" class="headerlink" title="数据对象"></a>数据对象</h2><p>$$<br>D = {a_i | a_i \in \texttt{ElemSet}, i = 1, 2, …, n, n \geqslant 0}<br>$$</p><h2 id="数据关系-1"><a href="#数据关系-1" class="headerlink" title="数据关系"></a>数据关系</h2><p>$$<br>R1 = {&lt;a_{i-1}, a_i&gt; | a_{i-1}, a_i \in D, i = 2, …, n}<br>$$</p><p>约定$a_1$端为队列头，$a_n$端为队列尾。</p><p><strong>后进先出</strong>：栈中元素依次按$a_1$、$a_@$、…、$a_n$入栈，而退栈的第一个元素应为栈顶元素。</p><h2 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="结构初始化-1"><a href="#结构初始化-1" class="headerlink" title="结构初始化"></a>结构初始化</h3><ul><li><p><code>InitQueue(&amp;Q)</code></p><ul><li>操作结果：构造一个空队列$Q$</li></ul></li></ul><h3 id="销毁结构-1"><a href="#销毁结构-1" class="headerlink" title="销毁结构"></a>销毁结构</h3><ul><li><p><code>DestroyQueue(&amp;Q)</code></p><ul><li><p>初始条件：队列$Q$已存在</p></li><li><p>操作结果：队列$Q$被销毁</p></li></ul></li></ul><h3 id="引用型操作-1"><a href="#引用型操作-1" class="headerlink" title="引用型操作"></a>引用型操作</h3><ul><li><p><code>QueueEmpty(Q)</code></p><ul><li><p>初始条件：队列$Q$已存在</p></li><li><p>操作结果：若$S$为空队列，则返回<code>TRUE</code>，否则返回<code>FALSE</code></p></li></ul></li><li><p><code>QueueLength(Q)</code></p><ul><li><p>初始条件：队列$Q$已存在</p></li><li><p>操作结果：返回$Q$的元素个数，即队列的长度</p></li></ul></li><li><p><code>GetHead(Q, &amp;e)</code></p><ul><li><p>初始条件：队列$Q$已存在，且非空</p></li><li><p>操作结果：用<code>e</code>返回$Q$的头部元素</p></li></ul></li></ul><h3 id="加工型操作-1"><a href="#加工型操作-1" class="headerlink" title="加工型操作"></a>加工型操作</h3><ul><li><p><code>ClearQueue(&amp;Q)</code></p><ul><li><p>初始条件：队列$Q$已存在</p></li><li><p>操作结果：将$Q$清为空队列</p></li></ul></li><li><p><code>EnQueue(&amp;Q, e)</code></p><ul><li><p>初始条件：队列$Q$已存在</p></li><li><p>操作结果：插入元素$e$为新的队尾元素</p></li></ul></li><li><p><code>DeQueue(&amp;Q, &amp;e)</code></p><ul><li><p>初始条件：队列$Q$已存在且非空</p></li><li><p>操作结果：删除$S$的队头元素，并用<code>e</code>返回其值</p></li></ul></li></ul><h1 id="3-5-队列类型的实现"><a href="#3-5-队列类型的实现" class="headerlink" title="3.5 队列类型的实现"></a>3.5 队列类型的实现</h1><h2 id="链队列——链式映像"><a href="#链队列——链式映像" class="headerlink" title="链队列——链式映像"></a>链队列——链式映像</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    QElemType    data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure><h2 id="循环队列——顺序映像"><a href="#循环队列——顺序映像" class="headerlink" title="循环队列——顺序映像"></a>循环队列——顺序映像</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 100;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 初始化的动态分配存储空间</span></span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="comment">// 头指针，若队列不空，指向队列头元素</span></span><br><span class="line">    <span class="keyword">int</span>       front;</span><br><span class="line">    <span class="comment">// 尾指针，若队列不空，指向队列尾元素的下一个位置</span></span><br><span class="line">    <span class="keyword">int</span>       rear;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-1-栈的类型定义&quot;&gt;&lt;a href=&quot;#3-1-栈的类型定义&quot; class=&quot;headerlink&quot; title=&quot;3.1 栈的类型定义&quot;&gt;&lt;/a&gt;3.1 栈的类型定义&lt;/h1&gt;&lt;h2 id=&quot;数据对象&quot;&gt;&lt;a href=&quot;#数据对象&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://sr2k.top/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="严蔚敏数据结构与算法" scheme="https://sr2k.top/blog/tags/%E4%B8%A5%E8%94%9A%E6%95%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="学习" scheme="https://sr2k.top/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="https://sr2k.top/blog/2019/04/16/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://sr2k.top/blog/2019/04/16/线性表/</id>
    <published>2019-04-16T10:14:46.000Z</published>
    <updated>2019-07-19T05:03:34.684Z</updated>
    
    <content type="html"><![CDATA[<p>基本特征：</p><ol><li>集合中必存在唯一的一个「第一元素」</li><li>集合中必存在唯一的一个「最后元素」</li><li>除第一元素外，均有唯一的后继</li><li>除第一元素外，均有唯一的前驱</li></ol><h1 id="2-1-线性表的类型定义"><a href="#2-1-线性表的类型定义" class="headerlink" title="2.1 线性表的类型定义"></a>2.1 线性表的类型定义</h1><h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>$$<br>D = {a_i | a_i \in \texttt{ElemSet}, i = 1, 2, …, n, n\geqslant 0}<br>$$</p><ul><li>称$n$为线性表的<strong>表长</strong></li><li>称$n=0$的线性表为<strong>空表</strong></li></ul><h2 id="数据关系"><a href="#数据关系" class="headerlink" title="数据关系"></a>数据关系</h2><p>$$<br>R1={&lt;a_{i-1}, a_i&gt;|a_{i-1}, a_i \in D, i = 2, …, n}<br>$$</p><ul><li>设线性表为$(a_1, a_2, …, a_i, …, a_n)$，称$i$为$a_i$在线性表中的<strong>位序</strong></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="结构初始化"><a href="#结构初始化" class="headerlink" title="结构初始化"></a>结构初始化</h3><ul><li><code>InitList(&amp;L)</code><ul><li>操作结果：构造一个空的线性表$L$</li></ul></li></ul><h3 id="销毁结构"><a href="#销毁结构" class="headerlink" title="销毁结构"></a>销毁结构</h3><ul><li><code>DestroyList(&amp;L)</code><ul><li>初始条件：线性表$L$已存在</li><li>操作结果：销毁线性表$L$</li></ul></li></ul><h3 id="引用型操作"><a href="#引用型操作" class="headerlink" title="引用型操作"></a>引用型操作</h3><ul><li><code>ListEmpty(L)</code><ul><li>初始条件：线性表$L$已存在</li><li>操作结果：若$L$为空表，则返回<code>TRUE</code>，否则返回<code>FALSE</code></li></ul></li><li><code>ListLength(L)</code><ul><li>初始条件：线性表$L$已存在</li><li>操作结果：返回$L$中数据元素的个数</li></ul></li><li><code>PriorElem(L, cur_e, &amp;pre_e)</code><ul><li>初始条件：线性表$L$已存在</li><li>操作结果：若<code>cur_e</code>是$L$的数据元素，且不是第一个，则用<code>pre_e</code>返回它的前驱，否则操作失败，<code>pre_e</code>无定义</li></ul></li><li><code>NextElem(L, cur_e, &amp;next_e)</code><ul><li>初始条件：线性表$L$已存在</li><li>操作结果：若<code>cur_e</code>是$L$的数据元素，且不是最后一个，则用<code>next_e</code>返回它的后驱，否则操作失败，<code>next_e</code>无定义</li></ul></li><li><code>GetItem(L, i, &amp;e)</code><ul><li>初始条件：线性表$L$已存在，$1\leqslant i\leqslant \texttt{ListLength}(L)+1$</li><li>操作结果：用<code>e</code>返回$L$中第<code>i</code>个数据元素的值</li></ul></li><li><code>LocateElem(L, e, compare())</code><ul><li>初始条件：线性表$L$已存在，<code>compare()</code>是数据元素判定函数</li><li>操作结果：返回$L$中第1个与<code>e</code>满足关系<code>compare()</code>的数据元素的位序。若这样的数据元素不存在，则返回值为0</li></ul></li><li><code>ListTraverse(L, visit())</code><ul><li>初始条件：线性表$L$已存在</li><li>操作结果：依次对$L$的每个数据元素调用函数<code>visit()</code>。一旦<code>visit()</code>调用失败，则操作失败</li></ul></li></ul><h3 id="加工型操作"><a href="#加工型操作" class="headerlink" title="加工型操作"></a>加工型操作</h3><ul><li><code>ClearList(&amp;L)</code><ul><li>初始条件：线性表$L$已存在</li><li>操作结果：将$L$重置为空表</li></ul></li><li><code>PutElem(L, i, &amp;e)</code><ul><li>初始条件：线性表$L$已存在，$1\leqslant i\leqslant \texttt{ListLength}(L)+1$</li><li>操作结果：$L$中第<code>i</code>个元素赋值同<code>e</code>的值</li></ul></li><li><code>ListInsert(&amp;L, i, e)</code><ul><li>初始条件：线性表$L$已存在，$1\leqslant i\leqslant \texttt{ListLength}(L)+1$</li><li>操作结果：在$L$中第<code>i</code>个位置之前插入新的数据元素<code>e</code>，$L$的长度加1</li></ul></li><li><code>ListDelete(&amp;L, i, &amp;e)</code><ul><li>初始条件：线性表$L$已存在且非空，$1\leqslant i\leqslant \texttt{ListLength}(L)+1$</li><li>操作结果：删除$L$的第<code>i</code>个元素，并用<code>e</code>返回其值，$L$的长度减1</li></ul></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例2-1：union（并集）"><a href="#例2-1：union（并集）" class="headerlink" title="例2.1：union（并集）"></a>例2.1：<code>union</code>（并集）</h3><p>假设：有两个集合$A$和$B$分别用两个线性表$LA$和$LB$表示（即：线性表中的数据元素即为集合的成员）。</p><p>现要求一个新的集合$A = A \cup B$。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ol><li>从线性表$LB$中依次取得每个数据元素：<code>GetElem(LB, i)</code> -&gt; <code>e</code></li><li>依次在线性表$LA$中进行查访：<code>LocateElem(LA, e, equal())</code></li><li>若不存在，则插入之：<code>ListInsert(LA, n+1, e)</code></li></ol><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(List &amp;La, List Lb)</span> </span>&#123;</span><br><span class="line">    La_len = ListLength(La);</span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Lb_len; i++) &#123;</span><br><span class="line">        GetElem(Lb, i, e);</span><br><span class="line">        <span class="keyword">if</span> (!LocateElem(La, e, equal))</span><br><span class="line">            ListInsert(La, ++La_len, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>控制结构：<code>for</code>循环</p><p>基本操作：<code>LocateElem(La, q, equal())</code></p><p>时间复杂度：</p><ul><li>顺序映像：TODO…</li><li>链式映像：TODO…</li></ul><h3 id="例2-2：purge（净化）"><a href="#例2-2：purge（净化）" class="headerlink" title="例2.2：purge（净化）"></a>例2.2：<code>purge</code>（净化）</h3><p>已知一个有序非纯集合$B$，试构造一个纯集合$A$，使$A$中只包含$B$中所有值各不相同的数据元素。</p><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">purge</span><span class="params">(List &amp;La, List Lb)</span> </span>&#123;</span><br><span class="line">    InitList(La);</span><br><span class="line">    La_len = ListLength(La);</span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Lb_len; i++) &#123;</span><br><span class="line">        GetItem(Lb, i, e);</span><br><span class="line">        <span class="keyword">if</span> (ListEmpty(La) || !equal(en, e)) &#123;</span><br><span class="line">            ListInsert(La, ++La_len, e);</span><br><span class="line">            en = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><p>控制结构：<code>for</code>循环</p><p>基本操作：<code>GetElem(Lb, i, e)</code></p><p>时间复杂度：</p><ul><li>顺序映像：TODO…</li><li>链式映像：TODO…</li></ul><h3 id="例2-3：merge（归并）"><a href="#例2-3：merge（归并）" class="headerlink" title="例2.3：merge（归并）"></a>例2.3：<code>merge</code>（归并）</h3><p>归并两个「其数据元素按值非递减有序排列」的线性表$LA$和$LB$，求得线性表$LC$也具有同样的特征。</p><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeOrderedList</span><span class="params">(List La, List Lb, List &amp;Lc)</span> </span>&#123;</span><br><span class="line">    InitList(Lc);</span><br><span class="line"></span><br><span class="line">    i = j = <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    La_len = ListLength(La);</span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((i &lt;= La_len) &amp;&amp; (j &lt;= Lb_len)) &#123;</span><br><span class="line">        GetItem(La, i, ai);</span><br><span class="line">        GetItem(Lb, j, bj);</span><br><span class="line">        <span class="keyword">if</span> (ai &lt;= bj) &#123;</span><br><span class="line">            ListInsert(Lc, ++k, ai);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ListInsert(Lc, ++k, bj);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= La_len) &#123;</span><br><span class="line">        GetItem(La, i++, ai);</span><br><span class="line">        ListInsert(Lc, ++k, ai);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= Lb_len) &#123;</span><br><span class="line">        GetItem(Lb, j++, bj);</span><br><span class="line">        ListInsert(Lc, ++k, bj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><p>控制结构：三个并列的<code>while</code>循环</p><p>基本操作：<code>ListInsert(Lc, ++k, e)</code></p><p>时间复杂度：</p><ul><li>顺序映像：TODO…</li><li>链式映像：TODO…</li></ul><h1 id="2-2-线性表类型的实现——顺序映像"><a href="#2-2-线性表类型的实现——顺序映像" class="headerlink" title="2.2 线性表类型的实现——顺序映像"></a>2.2 线性表类型的实现——顺序映像</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用一组地址连续的存储单元依次存放线性表中的数据元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+----+-----+------+----+-----+----|</span><br><span class="line">| a1 | a2 | ... | ai-1 | ai | ... | an |</span><br><span class="line">+----+----+-----+------+----+-----+----|</span><br></pre></td></tr></table></figure><p>线性表的起始地址称作线性表的基地址。</p><p>以「存储位置相邻」表示有序对$&lt;a_{i-1}, a_i&gt;$即：$\mathrm{LOC}(a_i) = \mathrm{LOC}(a_{i-1}) + C$。其中$C$为一个数据元素所占的存储量。</p><p>所有数据元素的存储位置均取决于第一个元素的存储位置：$\mathrm{LOC}(a_i) = \mathrm{LOC}(a_1) + (i-1)\times C$</p><p>顺序映像的C语言描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性表存储空间的初始分配量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 80</span></span><br><span class="line"><span class="comment">// 线性表存储空间的分配增量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INCREMENT 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 存储空间基址</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="comment">// 当前长度</span></span><br><span class="line">    <span class="keyword">int</span>      length;</span><br><span class="line">    <span class="comment">// 当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">    <span class="keyword">int</span>      listSize;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L.elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.listsize = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>时间复杂度：$O(n)$。</p><p>线性表操作<code>LocateItem</code>的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SqList L,</span></span></span><br><span class="line"><span class="function"><span class="params">    ElemType e,</span></span></span><br><span class="line"><span class="function"><span class="params">    Status(*compare)(ElemType, ElemType)</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    p = L.elem;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= L.length &amp;&amp; !(*compare)(*p++, e))</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= L.length)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>将$(a_1, …, a_{i-1}, a_i, …, a_n)$变为$(a_1, …, a_{i-1}, e, a_i, …, a_n)$。</p><p>时间复杂度：$O(n)$。</p><p>考虑平均的情况：</p><p>假设在第$i$个元素之前插入的概率为$p_i$，则在长度为n的线性表中插入一个元素所需移动元素次数的期望值为：</p><p>$$E_{is} = \sum_{i=1}^{n+1} p_i (n-i+1)$$</p><p>若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为：</p><p>线性表操作<code>InsertItem</code>的实现：</p><p>$$E_{is} = \frac1{n+1} \sum_{i=1}^{n+1} (n-i+1) = \frac n2$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 当前空间已满，重新分配</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= L.listsize) &#123;</span><br><span class="line">        newbase = (ElemType*)<span class="built_in">realloc</span>(</span><br><span class="line">            L.elem,</span><br><span class="line">            (L.listsize + LIST_INCREMENT) * <span class="keyword">sizeof</span>(ElemType)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 存储分配失败</span></span><br><span class="line">        <span class="keyword">if</span> (!newbase)</span><br><span class="line">            <span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">        <span class="comment">// 新基址</span></span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        <span class="comment">// 增加存储容量</span></span><br><span class="line">        L.listsize += LIST_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// q为插入位置</span></span><br><span class="line">    q = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 插入位置及之后的元素右移</span></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; --p)</span><br><span class="line">        *(p + <span class="number">1</span>) = *p;</span><br><span class="line">    <span class="comment">// 插入e</span></span><br><span class="line">    *q = e;</span><br><span class="line">    <span class="comment">// 表长增1</span></span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>将$(a_1, …, a_{i-1}, a_i, a_{i+1}, …, a_n)$变为$(a_1, …, a_{i-1}, a_{i+1}, …, a_n)$。</p><p>时间复杂度：$O(n)$。</p><p>考虑平均的情况：</p><p>假设删除第$i$个元素的概率为$q_i$，则在长度为$n$的线性表中删除一个元素所需移动元素次数的期望值为：</p><p>$$E_{dl} = \sum_{i=1}^n q_i (n-i)$$</p><p>若假定在线性表中任何一个位置上进行删除操作的概率都是相等的，则移动元素的期望值为：</p><p>$$E_{dl} = \frac1n\sum_{i=1}^n(n-i) = \frac{n-1}2$$</p><p>线性表操作<code>DeleteItem</code>的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i &gt; L.length))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    e = *p;</span><br><span class="line">    q = L.elem + L.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (++p; p &lt;= q; ++p)</span><br><span class="line">        *(p - <span class="number">1</span>) = *p;</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-3-线性表类型的实现——链式映像"><a href="#2-3-线性表类型的实现——链式映像" class="headerlink" title="2.3 线性表类型的实现——链式映像"></a>2.3 线性表类型的实现——链式映像</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>用一组<strong>地址任意</strong>的存储单元存放线性表中的数据元素。</p><p>元素+指针=结点。以「节点的序列」表示线性表——称作链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">subgraph A1</span><br><span class="line">    a1</span><br><span class="line">    p1[ ]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph A2</span><br><span class="line">    a2</span><br><span class="line">    p2[ ]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph A3</span><br><span class="line">    a3</span><br><span class="line">    p3[^]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">p1 --&gt; a2</span><br><span class="line">p2 --&gt; a3</span><br></pre></td></tr></table></figure><p>以线性表中第一个数据元素$a_1$的存储地址作为线性表的地址，称作线性表的头指针。</p><p>结点和单链表的C语言描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 数据域</span></span><br><span class="line">    ElemType     data;</span><br><span class="line">    <span class="comment">// 指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;p -&gt; data);</span><br><span class="line">        p -&gt; next = L -&gt; next;</span><br><span class="line">        L -&gt; next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作实现-1"><a href="#操作实现-1" class="headerlink" title="操作实现"></a>操作实现</h2><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>基本操作为：使指针<code>p</code>始终只想线性表中的第<code>j</code>个数据元素。</p><p>时间复杂度：$O(n)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetItem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    p = L -&gt; next;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i);</span><br><span class="line">        <span class="keyword">return</span> ERROR</span><br><span class="line">    e = p -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>基本操作为：找到线性表中第<code>i-1</code>个节点，修改其指向后继的指针。</p><p>即有序对$&lt;a_{i-1}, a_i&gt;$改变为$&lt;a_{i-1}, e&gt;$和$&lt;e, a_i&gt;$。</p><p>时间复杂度：$O(n)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s -&gt; data = e;</span><br><span class="line">    s -&gt; next = p -&gt; next;</span><br><span class="line">    p -&gt; next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>基本操作为：找到线性表中第<code>i-1</code>个节点，修改其指向后继的指针。</p><p>即有序对$&lt;a_{i-1}, a_i&gt;$和$&lt;a_i, a_{i+1}&gt;$改变为$&lt;a_{i-1}, a_{i+1}&gt;$。</p><p>时间复杂度：$O(n)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p -&gt; next &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    q = p -&gt; next;</span><br><span class="line">    p -&gt; next = q -&gt; next;</span><br><span class="line">    e = q -&gt; data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表的问题"><a href="#单链表的问题" class="headerlink" title="单链表的问题"></a>单链表的问题</h2><ol><li><p>表长是一个隐含的值；</p></li><li><p>在最后位置插入元素时需要遍历整个链表；</p></li><li><p>「位序」概念淡化，结点的「位置」概念强化。</p></li></ol><p>改进：TODO…</p><h2 id="其他形式的链表"><a href="#其他形式的链表" class="headerlink" title="其他形式的链表"></a>其他形式的链表</h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> &#123;</span></span><br><span class="line">    ElemType       data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>最后一个节点的指针域的指针又指回第一个节点的链表。</p><h1 id="2-4-一元多项式的表示"><a href="#2-4-一元多项式的表示" class="headerlink" title="2.4 一元多项式的表示"></a>2.4 一元多项式的表示</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>$$<br>P_n(x) = p_0 + p_1x + p_2x^2 + … + p_nx^n<br>$$</p><p>在计算机中可以用一个线性表来表示：</p><p>$$<br>P = (p_0, p_1, …, p_n)<br>$$</p><p>但是在存储很多系数为0的情况下就不合适了（如$S(x) = 1+3x^{10000}-2x^{999}$）。</p><p>一般情况下一元多项式可写成：</p><p>$$<br>P_n(x) = p_1x^{e_1} + p_2x^{e_2} + … + p_mx^{e_m}<br>$$</p><p>其中，$p_i$是指数为$e_i$的项的非零系数。</p><p>因此在计算机中可以表示为：</p><p>$$<br>((p_1, e_1), (p_2, e_2), …, (p_m, e_m))<br>$$</p><blockquote><p>如：</p><p>$$<br>P_{999}(x) = 7x^3 - 2x^{12} - 8x^{999}<br>$$</p><p>可以表示为：</p><p>$$<br>((7, 3), (-2, 12), (-8, 999))<br>$$</p></blockquote><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 系数</span></span><br><span class="line">    <span class="keyword">float</span> coef;</span><br><span class="line">    <span class="comment">// 指数</span></span><br><span class="line">    <span class="keyword">int</span>   expn;</span><br><span class="line">&#125; term, ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LinkList polynomial;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePolyn</span><span class="params">(polynomial &amp;P, <span class="keyword">int</span> m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyPolyn</span><span class="params">(polynomial &amp;P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPolyn</span><span class="params">(polynomial &amp;P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">PolynLength</span><span class="params">(polynomial &amp;P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SubPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiplyPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依a的指数值&lt;（或=）（或&gt;）b的指数值，分别返回-1、0和+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(term a, term b)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="算法实现（部分）"><a href="#算法实现（部分）" class="headerlink" title="算法实现（部分）"></a>算法实现（部分）</h2><h3 id="create：创建"><a href="#create：创建" class="headerlink" title="create：创建"></a><code>create</code>：创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span> </span>&#123;</span><br><span class="line">    ha = GetHead(Pa);</span><br><span class="line">    hb = GetHead(Pb);</span><br><span class="line">    qa = NextPos(Pa, ha);</span><br><span class="line">    qb = NextPos(Pa, hb);</span><br><span class="line">    <span class="keyword">while</span> (qa &amp;&amp; qb) &#123;</span><br><span class="line">        a = GetCurElem(qa);</span><br><span class="line">        b = GetCurElem(qb);</span><br><span class="line">        <span class="keyword">switch</span> (*cmp(a, b)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                ha = qa;</span><br><span class="line">                qa = NextPos(Pa, qa);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                sum = a.coef + b.coef;</span><br><span class="line">                <span class="keyword">if</span> (sum != <span class="number">0.0</span>) &#123;</span><br><span class="line">                    SetCurElem(qa, sum);</span><br><span class="line">                    ha = qa;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    DelFirst(hb, qb);</span><br><span class="line">                    FreeNode(qa);</span><br><span class="line">                &#125;</span><br><span class="line">                DelFirst(hb, qb);</span><br><span class="line">                FreeNode(qb);</span><br><span class="line">                qb = NextPos(Pb, hb);</span><br><span class="line">                qa = NextPos(Pa, ha);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                DelFirst(hb, qb);</span><br><span class="line">                InsFirst(ha, qb);</span><br><span class="line">                qb = NextPos(Pb, hb);</span><br><span class="line">                ha = NextPos(Pa, ha);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ListEmpty(Pb))</span><br><span class="line">        Append(Pa, qb);</span><br><span class="line">    FreeNode(hb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集合中必存在唯一的一个「第一元素」&lt;/li&gt;
&lt;li&gt;集合中必存在唯一的一个「最后元素」&lt;/li&gt;
&lt;li&gt;除第一元素外，均有唯一的后继&lt;/li&gt;
&lt;li&gt;除第一元素外，均有唯一的前驱&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-1-线性
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://sr2k.top/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="严蔚敏数据结构与算法" scheme="https://sr2k.top/blog/tags/%E4%B8%A5%E8%94%9A%E6%95%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="学习" scheme="https://sr2k.top/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Angular自定义表单组件</title>
    <link href="https://sr2k.top/blog/2019/03/22/Angular%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/"/>
    <id>https://sr2k.top/blog/2019/03/22/Angular自定义表单组件/</id>
    <published>2019-03-22T05:51:11.000Z</published>
    <updated>2019-07-19T05:03:34.682Z</updated>
    
    <content type="html"><![CDATA[<p>Angular、Vue、React 等框架为前端引入了「模块化的概念」，我们可以预先定义好不同的组件，然后在各处复用。而表单在各种 WebApp 中都处于十分重要的位置。今天这个简单的小教程就是在 Angular 中实现一个可以复用的自定义表单组建。</p><p>这个表单组建功能十分简单：允许用户输入手机号，并选择手机号的国家区号。</p><h1 id="新建-amp-配置项目"><a href="#新建-amp-配置项目" class="headerlink" title="新建&amp;配置项目"></a>新建&amp;配置项目</h1><p>首先我们使用 Angular CLI 来新建一个最最普通的 Angular 应用，并创建一个名叫 <code>PhoneNumInput</code><br>的组件作为我们的自定义表单组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我更喜欢用 Yarn 所以这里先跳过 NPM 的安装过程了</span></span><br><span class="line">ng new ng-custom-form-control-demo --skip-install</span><br><span class="line"><span class="built_in">cd</span> ng-custom-form-control-demo</span><br><span class="line">yarn</span><br><span class="line"></span><br><span class="line">ng g c phone-num-input</span><br></pre></td></tr></table></figure><p>由于我们会使用响应式表单，因此需要在 <code>app.module.ts</code> 中的 <code>imports</code> 中导入<br><code>ReactiveFormsModule</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/app.module.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">imports: [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ReactiveFormsModule</span><br><span class="line">]</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h2><p>接下来，我们需要为自组件添加一个输入框和一个选择框，修改 <code>phone-num-input.component.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/phone-num-input/phone-num-input.component.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> [<span class="attr">ngModel</span>]=<span class="string">"regionCode"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"+86"</span>&gt;</span>+86<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"+1"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> <span class="attr">placeholder</span>=<span class="string">"Phone number..."</span> [<span class="attr">ngModel</span>]=<span class="string">"phoneNum"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>phone-num-input.component.ts</code> 中新增两个属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/phone-num-input/phone-num-input.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PhoneNumInputComponent <span class="keyword">implements</span> OnInit, ControlValueAccessor &#123;</span><br><span class="line">  regionCode = <span class="string">'+86'</span>;</span><br><span class="line">  phoneNum = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引入子组件"><a href="#引入子组件" class="headerlink" title="引入子组件"></a>引入子组件</h2><p>然后，我们需要在 <code>AppComponent</code> 中引入我们的表单组件。</p><p>将 <code>app.component.html</code> 中的内容修改为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/app/app.component.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> [<span class="attr">formGroup</span>]=<span class="string">"form"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-phone-num-input</span> <span class="attr">formControlName</span>=<span class="string">"phoneNum"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-phone-num-input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后修改 <code>app.component.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/app.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表单</span></span><br><span class="line">  form: FormGroup;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注入 FormBuilder 来生成表单</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> fb: FormBuilder</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="comment">// 生成表单</span></span><br><span class="line">    <span class="keyword">this</span>.form = <span class="keyword">this</span>.fb.group(&#123;</span><br><span class="line">      phoneNum: [<span class="literal">null</span>, [Validators.pattern(<span class="regexp">/^\+1/</span>)]]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注册服务提供商"><a href="#注册服务提供商" class="headerlink" title="注册服务提供商"></a>注册服务提供商</h1><p>现在，我们需要让 Angular 知道我们的 <code>PhoneNumInputComponent</code> 是一个自定义表单组件，因此<br>需要为其注册服务提供商，在 <code>phone-num-input.component.ts</code> 中 <code>PhoneNumInputComponent</code><br>的类定义之前假如如下元数据：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/phone-num-input/phone-num-input.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> APP_PHONE_NUM_INPUT_VALUE_ACCESSOR = &#123;</span><br><span class="line">  provide: NG_VALUE_ACCESSOR,</span><br><span class="line">  useExisting: forwardRef(<span class="function"><span class="params">()</span> =&gt;</span> PhoneNumInputComponent),</span><br><span class="line">  multi: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在 <code>PhoneNumInputComponent</code> 的 <code>@Component</code> 装饰器中加上一个 <code>providers</code> 数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/phone-num-input/phone-num-input.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  providers: [APP_PHONE_NUM_INPUT_VALUE_ACCESSOR]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="ControlValueAccessor-接口"><a href="#ControlValueAccessor-接口" class="headerlink" title="ControlValueAccessor 接口"></a><code>ControlValueAccessor</code> 接口</h1><p>要使用自定义表单组件，我们必须为组件实现 <code>ControlValueAccessor</code> 接口，以此来告诉 Angualr<br>表单如何与我们的组件交互，此接口的定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ControlValueAccessor &#123;</span><br><span class="line">  <span class="comment">// 外部向组件内写入数值</span></span><br><span class="line">  writeValue(obj: <span class="built_in">any</span>): <span class="built_in">void</span></span><br><span class="line">  <span class="comment">// 注册数据变化回调</span></span><br><span class="line">  registerOnChange(fn: <span class="built_in">any</span>): <span class="built_in">void</span></span><br><span class="line">  <span class="comment">// 注册脏值回调</span></span><br><span class="line">  registerOnTouched(fn: <span class="built_in">any</span>): <span class="built_in">void</span></span><br><span class="line">  <span class="comment">// 禁用状态配置</span></span><br><span class="line">  setDisabledState(isDisabled: <span class="built_in">boolean</span>)?: <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>PhoneNumInputComponent</code> 类修改如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/phone-num-input/phone-num-input.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PhoneNumInputComponent <span class="keyword">implements</span> ControlValueAccessor &#123;</span><br><span class="line">  registerOnChange(fn: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>) &#123;</span><br><span class="line">  registerOnTouched(fn: <span class="function">(<span class="params">touched: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>) &#123;</span><br><span class="line">  setDisabledState(isDisabled: <span class="built_in">boolean</span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  writeValue(val: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很复杂，下边用例子解释这些方法要怎么使用。</p><h2 id="禁用组件"><a href="#禁用组件" class="headerlink" title="禁用组件"></a>禁用组件</h2><p>首先，我们来实现一个最最简单的功能：在父组件禁用我们的表单组件。</p><p>修改 <code>app.module.ts</code>，增加表单禁用的属性和方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/app.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  formDisabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  toggleFormDisable() &#123;</span><br><span class="line">    <span class="keyword">this</span>.formDisabled = !<span class="keyword">this</span>.formDisabled;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.formDisabled) &#123;</span><br><span class="line">      <span class="keyword">this</span>.form.disable();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.form.enable();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>app.component.html</code>，添加禁用表单的按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/app/app.component.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"toggleFormDisable()"</span>&gt;</span>Toggle Disable<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们就要实现 <code>setDisabledState</code> 方法了。这个方法会在父组件请求修改子表单组件的禁用状态<br>时被调用，因此，修改 <code>phone-num-input.component.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/phone-num-input/phone-num-input.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PhoneNumInputComponent <span class="keyword">implements</span> OnInit, ControlValueAccessor &#123;</span><br><span class="line">  disabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  setDisabledState(isDisabled: <span class="built_in">boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.disabled = isDisabled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>phone-num-input.component.html</code> 中把我们的 <code>input</code> 的 <code>disabled</code> 属性绑定到<br>组件上的 <code>disabled</code> 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/phone-num-input/phone-num-input.component.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> <span class="attr">placeholder</span>=<span class="string">"Phone number..."</span> [<span class="attr">disabled</span>]=<span class="string">"disabled"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>现在，你在 <code>AppComponent</code> 中点击 Toggle Disable 按钮时，子组件的 <code>input</code> 就会在禁用/启用<br>的状态中切换了。</p><h2 id="父组件向表单组件传值"><a href="#父组件向表单组件传值" class="headerlink" title="父组件向表单组件传值"></a>父组件向表单组件传值</h2><p>现在假设我们的用户已经在别处提供过手机号了，因此我们希望在 <code>AppComponent</code> 被初始化时就给<br><code>PhoneNumInputComponent</code> 提供一个初始值。这里就可以使用 <code>writeValue</code> 方法了。</p><p>首先修改 <code>AppComponent</code> 的 <code>ngOnInit()</code> 钩子方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/app.component.ts</span></span><br><span class="line"></span><br><span class="line">ngOnInit() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.form.get(<span class="string">'phoneNum'</span>).setValue(<span class="string">'+86-13912345678'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>PhoneNumInputComponent</code> 的 <code>writeValue()</code> 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/phone-num-input/phone-num-input.component.ts</span></span><br><span class="line"></span><br><span class="line">writeValue(val: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> s = val.split(<span class="string">'-'</span>);</span><br><span class="line">  <span class="keyword">this</span>.regionCode = s[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">this</span>.phoneNum = s[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每次打开你的 app，页面上都会显示预先定义好的值了。</p><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><p>现在，我们要在用户输入时告诉父组件数据的变化，这里是用的是 <code>registerOnChange()</code> 注册的方法。</p><p>在 <code>app-component.html</code> 中加入一行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/app/app.component.ts --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Your phone number is: &#123;&#123;this.form.get('phoneNum').value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br></pre></td></tr></table></figure><p>现在，让我们注册一下子组件向父组件传值的方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/phone-num-input/phone-num-input.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PhoneNumInputComponent <span class="keyword">implements</span> ControlValueAccessor &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  onChange: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// registerOnChange 会给我们传入一个函数，用来向上传值，我们需要把这个函数保存下来</span></span><br><span class="line">  registerOnChange(fn: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onChange = fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们需要观测 <code>PhoneNumInputComponent</code> 中两个 <code>ngModel</code> 的变化，因此修改<br><code>phone-num-input.component.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/phone-num-input/phone-num-input.component.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> [<span class="attr">ngModel</span>]=<span class="string">"regionCode"</span></span></span><br><span class="line"><span class="tag">        (<span class="attr">ngModelChange</span>)=<span class="string">"regionCodeChange($event)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"+86"</span>&gt;</span>+86<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"+1"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">placeholder</span>=<span class="string">"Phone number..."</span></span></span><br><span class="line"><span class="tag">       [<span class="attr">ngModel</span>]=<span class="string">"phoneNum"</span></span></span><br><span class="line"><span class="tag">       (<span class="attr">ngModelChange</span>)=<span class="string">"phoneNumChange($event)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后在组件中添加对应的变动处理方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/phone-num-input/phone-num-input.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PhoneNumInputComponent <span class="keyword">implements</span> ControlValueAccessor &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  regionCodeChange(val: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.regionCode = val;</span><br><span class="line">    <span class="comment">// 调用传值方法，向父组件传值</span></span><br><span class="line">    <span class="keyword">this</span>.onChange(<span class="string">`<span class="subst">$&#123;this.regionCode&#125;</span>-<span class="subst">$&#123;this.phoneNum&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  phoneNumChange(val: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.phoneNum = val;</span><br><span class="line">    <span class="comment">// 调用传值方法，向父组件传值</span></span><br><span class="line">    <span class="keyword">this</span>.onChange(<span class="string">`<span class="subst">$&#123;this.regionCode&#125;</span>-<span class="subst">$&#123;this.phoneNum&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，你在输入框里输入数值，首页的 <code>&lt;p&gt;</code> 里的电话号码也会跟着变了～</p><h2 id="更新组件脏值状态"><a href="#更新组件脏值状态" class="headerlink" title="更新组件脏值状态"></a>更新组件脏值状态</h2><p>如果你足够细心，你会发现我之前给表单添加了一条验证规则：<code>Validators.pattern(/^\+1/)</code>，这就<br>意味着只有以 +1 开头的手机号才是正确的。</p><p>现在我们要给表单增加一个提示，告诉用户你的输入不正确。试想，如果你是用户，你明明还没有修改表单的<br>数据，表单就告诉你输错了，肯定是个不好的体验。更好的设计应该是：用户已经手动修改过数据了，而且输<br>错了，再显示提示。</p><p>在 Angular 中我们可以使用 <code>FormControl</code> 的 <code>touched</code> 属性知道值是否被用户动过。</p><p>修改你的，添加错误提示语：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/app/app.component.ts --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">ngIf</span>=<span class="string">"this.form.get('phoneNum').touched &amp;&amp; this.form.get('phoneNum').hasError('pattern')"</span>&gt;</span></span><br><span class="line">  Phone number shall start with +1!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br></pre></td></tr></table></figure><p>现在，我们需要在子组件 <code>&lt;input&gt;</code> 和 <code>&lt;select&gt;</code> 被修改时通知父组件：这个值被用户动过啦！</p><p>修改 <code>phone-num-input.component.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/phone-num-input/phone-num-input.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PhoneNumInputComponent <span class="keyword">implements</span> ControlValueAccessor &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  onTouched: <span class="function">(<span class="params">touched: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 和之前一样，把传进来的函数保存下来</span></span><br><span class="line">  registerOnTouched(fn: <span class="function">(<span class="params">touched: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onTouched = fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  regionCodeChange(val: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.onTouched(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  phoneNumChange(val: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.onTouched(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><h2 id="app-module-ts"><a href="#app-module-ts" class="headerlink" title="app-module.ts"></a><code>app-module.ts</code></h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    PhoneNumInputComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    ReactiveFormsModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="app-component-html"><a href="#app-component-html" class="headerlink" title="app-component.html"></a><code>app-component.html</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> [<span class="attr">formGroup</span>]=<span class="string">"form"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-phone-num-input</span> <span class="attr">formControlName</span>=<span class="string">"phoneNum"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-phone-num-input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> *<span class="attr">ngIf</span>=<span class="string">"this.form.get('phoneNum').touched &amp;&amp; this.form.get('phoneNum').hasError('pattern')"</span>&gt;</span></span><br><span class="line">    Phone number shall start with +1!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Your phone number is: &#123;&#123;this.form.get('phoneNum').value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"toggleFormDisable()"</span>&gt;</span>Toggle Disable<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="app-component-ts"><a href="#app-component-ts" class="headerlink" title="app-component.ts"></a><code>app-component.ts</code></h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.sass'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  title = <span class="string">'ng-custom-form-control-demo'</span>;</span><br><span class="line">  form: FormGroup;</span><br><span class="line">  formDisabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> fb: FormBuilder</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.form = <span class="keyword">this</span>.fb.group(&#123;</span><br><span class="line">      phoneNum: [<span class="literal">null</span>, [Validators.pattern(<span class="regexp">/^\+1/</span>)]]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.form.get(<span class="string">'phoneNum'</span>).setValue(<span class="string">'+86-13912345678'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toggleFormDisable() &#123;</span><br><span class="line">    <span class="keyword">this</span>.formDisabled = !<span class="keyword">this</span>.formDisabled;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.formDisabled) &#123;</span><br><span class="line">      <span class="keyword">this</span>.form.disable();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.form.enable();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="phone-num-input-component-html"><a href="#phone-num-input-component-html" class="headerlink" title="phone-num-input.component.html"></a><code>phone-num-input.component.html</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> [<span class="attr">ngModel</span>]=<span class="string">"regionCode"</span></span></span><br><span class="line"><span class="tag">        (<span class="attr">ngModelChange</span>)=<span class="string">"regionCodeChange($event)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"+86"</span>&gt;</span>+86<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"+1"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">placeholder</span>=<span class="string">"Phone number..."</span></span></span><br><span class="line"><span class="tag">       [<span class="attr">ngModel</span>]=<span class="string">"phoneNum"</span></span></span><br><span class="line"><span class="tag">       (<span class="attr">ngModelChange</span>)=<span class="string">"phoneNumChange($event)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="phone-num-input-component-ts"><a href="#phone-num-input-component-ts" class="headerlink" title="phone-num-input.component.ts"></a><code>phone-num-input.component.ts</code></h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> APP_PHONE_NUM_INPUT_VALUE_ACCESSOR = &#123;</span><br><span class="line">  provide: NG_VALUE_ACCESSOR,</span><br><span class="line">  useExisting: forwardRef(<span class="function"><span class="params">()</span> =&gt;</span> PhoneNumInputComponent),</span><br><span class="line">  multi: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-phone-num-input'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./phone-num-input.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./phone-num-input.component.sass'</span>],</span><br><span class="line">  providers: [APP_PHONE_NUM_INPUT_VALUE_ACCESSOR]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PhoneNumInputComponent <span class="keyword">implements</span> ControlValueAccessor &#123;</span><br><span class="line">  regionCode = <span class="string">'+86'</span>;</span><br><span class="line">  phoneNum = <span class="string">''</span>;</span><br><span class="line">  onChange: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onTouched: <span class="function">(<span class="params">touched: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  disabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  registerOnChange(fn: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onChange = fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  registerOnTouched(fn: <span class="function">(<span class="params">touched: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onTouched = fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setDisabledState(isDisabled: <span class="built_in">boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.disabled = isDisabled;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  writeValue(val: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> s = val.split(<span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">this</span>.regionCode = s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.phoneNum = s[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  regionCodeChange(val: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.regionCode = val;</span><br><span class="line">    <span class="keyword">this</span>.onChange(<span class="string">`<span class="subst">$&#123;this.regionCode&#125;</span>-<span class="subst">$&#123;this.phoneNum&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.onTouched(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  phoneNumChange(val: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.phoneNum = val;</span><br><span class="line">    <span class="keyword">this</span>.onChange(<span class="string">`<span class="subst">$&#123;this.regionCode&#125;</span>-<span class="subst">$&#123;this.phoneNum&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.onTouched(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Angular、Vue、React 等框架为前端引入了「模块化的概念」，我们可以预先定义好不同的组件，然后在各处复用。而表单在各种 WebApp 中都处于十分重要的位置。今天这个简单的小教程就是在 Angular 中实现一个可以复用的自定义表单组建。&lt;/p&gt;
&lt;p&gt;这个表单
      
    
    </summary>
    
    
      <category term="TypeScript" scheme="https://sr2k.top/blog/tags/TypeScript/"/>
    
      <category term="Angular" scheme="https://sr2k.top/blog/tags/Angular/"/>
    
      <category term="前端" scheme="https://sr2k.top/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的面向对象</title>
    <link href="https://sr2k.top/blog/2018/01/12/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://sr2k.top/blog/2018/01/12/JavaScript面向对象/</id>
    <published>2018-01-12T11:24:14.000Z</published>
    <updated>2019-07-19T05:03:34.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象简介"><a href="#对象简介" class="headerlink" title="对象简介"></a>对象简介</h1><p>在JS中创建一个对象十分简单，可以使用<code>Object</code>构造方法，也可以直接使用对象字面量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Siyuan"</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><p>JS引擎在内部使用的特性，描述了属性的各种特征。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><code>[[Configurable]]</code>：能否通过<code>delete</code>删除属性、能否修改属性的特性、或者能否把属性修改为访问器属性。默认值为<code>true</code>；</li><li><code>[[Enumerable]]</code>：能否通过<code>for-in</code>循环遍历到此属性。默认值为<code>true</code>；</li><li><code>[[Writable]]</code>：能否修改属性的值。默认值为<code>true</code>；</li><li><code>[[Value]]</code>：此属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为<code>undefined</code>。</li></ul><p>ES5的<code>Object.defineProperty()</code>方法可以修改上述各值。这个方法接收三个参数：</p><ul><li>属性所在的对象；</li><li>属性的名字；</li><li>描述符对象。</li></ul><p>其中，描述符（descriptor）对象的属性必须是：<code>configurable</code>、<code>enumerable</code>、<code>writable</code>和<code>value</code>，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">"Siyuan"</span> </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name);    <span class="comment">//"Siyuan"</span></span><br><span class="line">person.name = <span class="string">"Not Siyuan"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);    <span class="comment">//"Siyuan"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是严格模式下会报错</span></span><br></pre></td></tr></table></figure><p>如果把<code>configurable</code>设置为<code>false</code>，就不能再把它变回可配置了。此时，再调用<code>Object.defineProperty()</code>方法修改除<code>writable</code>之外的特性，都会导致错误。也就是说，可以多次调用<code>Object.defineProperty()</code>方法修改同一个属性，但在把<code>configurable</code>特性设置为<code>false</code>之后就会有限制了。</p><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性包含一对可选的<code>getter</code>和<code>setter</code>函数。他们函数负责决定如何处理数据。访问器属性有如下4个特性：</p><ul><li><code>[[Configurable]]</code>；</li><li><code>[[Enumerable]]</code>；</li><li><code>[[Get]]</code>：在读取属性时调用的函数。默认值为<code>undefined</code>；</li><li><code>[[Set]]</code>：在写入属性时调用的函数。默认值为<code>undefined</code>。</li></ul><p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>来定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sr2k = &#123; </span><br><span class="line">  _absCount: <span class="number">6</span> <span class="comment">// 嗯谁不想要腹肌捏 ///w//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(sr2k, <span class="string">"absCount"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._absCount;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">  <span class="comment">// 正常人不会有超过8块的腹肌吧…</span></span><br><span class="line">    <span class="keyword">this</span>._absCount = newValue &gt; <span class="number">8</span> ? <span class="number">8</span> : newValue; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sr2k.absCount = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sr2k.absCount); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>ES5又定义了一个<code>Object.defineProperties()</code>方法，可以一次定义多个属性。这个方法接收两个对象参数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sr2k = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(sr2k, &#123;</span><br><span class="line">  _hadBreakfast: &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  hungry: &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  hadBreakfast: &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._hadBreakfast;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="keyword">this</span>._hadBreakfast = newValue;</span><br><span class="line">      <span class="comment">// 吃了早饭就不饿啦</span></span><br><span class="line">      <span class="keyword">this</span>.hungry = !newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>使用ES5的<code>Object.getOwnPropertyDescriptor()</code>方法，可以取得给定属性的描述符：</p><p>如上文吃早饭的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_hadBreakfast"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get);   <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"hadBreakfast"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);        <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get);   <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = name;</span><br><span class="line">  obj.age  = age;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解决了创建多个相似对象的问题；</li><li>没有解决对象识别的问题（即怎样知道一个对象的类型）。</li></ul><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>与工厂模式相比，构造函数：</p><ul><li>没有显式地创建对象；</li><li>直接将属性和方法赋给了<code>this</code>对象；</li><li>没有<code>return</code>语句。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"><span class="comment">// this就指向了这个new出来的新对象</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age  = age;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sr2k = <span class="keyword">new</span> Person(<span class="string">"Siyuan"</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sr2k <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(sr2k <span class="keyword">instanceof</span> Person);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(sr2k.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h3><p>构造函数也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过<code>new</code>操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过<code>new</code>操作符来调用，那它跟普通函数也不会有什么两样。</p><p>在使用<code>new</code>操作符时，函数内<code>this</code>就指向了这个<code>new</code>出来的新对象；而不使用<code>this</code>时，就依据原来的上下文判断<code>this</code>了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当作构造函数使用，this指向new出来的person</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">"Siyuan"</span>, <span class="number">22</span>);</span><br><span class="line">person.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为普通函数调用，this指向window</span></span><br><span class="line">Person(<span class="string">"Siyuan"</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用，this指向这个对象</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Siyuan"</span>, <span class="number">22</span>);</span><br><span class="line">o.sayName();     <span class="comment">//"Siyuan"</span></span><br></pre></td></tr></table></figure><h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>每个方法都要在每个实例上重新创建一遍，无法实现继承。且每个对象都有自己的方法，虽然作用一样，却不是同一个<code>Function</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person(<span class="string">""</span>, <span class="number">0</span>).sayName === <span class="keyword">new</span> Person(<span class="string">""</span>, <span class="number">0</span>).sayName <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都有一个<code>prototype</code>（原型）属性，这个属性指向一个对象，而这个对象的用途是<strong>包含可以由特定类型的所有实例共享的属性和方法</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Siyuan"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">22</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();   <span class="comment">//"Siyuan"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();   <span class="comment">//"Siyuan"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个<code>prototype</code>属性，这个属性指向函数的<strong>原型对象</strong>。</p><p>在默认情况下，所有原型对象都会自动获得一个<code>constructor</code>（构造函数）属性，这个属性是一个指向<code>prototype</code>属性所在函数的指针。</p><p>就拿前面的例子来说，<code>Person.prototype.constructor</code>指向<code>Person</code>。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。</p><p>创建了自定义的构造函数之后，其原型对象默认只会取得<code>constructor</code>属性；至于其他方法，则都是从<code>Object</code>继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ES5中称作针叫<code>[[Prototype]]</code>。虽然在脚本中没有标准的方式访问<code>[[Prototype]]</code>，但大部分浏览器在每个对象上都支持一个属性<code>__proto__</code>。</p><p>更加标准地获得<code>[[Prototype]]</code>的方法是使用ES5的<code>Object.getPrototypeOf()</code>，在所有支持的实现中，这个方法返回<code>[[Prototype]]</code>的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph a</span><br><span class="line">func[function]</span><br><span class="line">  prototype</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph b</span><br><span class="line">obj[object]</span><br><span class="line">  proto[__proto__]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph c</span><br><span class="line">  protoObj[prototypeObject]</span><br><span class="line">  con[constructor]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">prototype --&gt; protoObj</span><br><span class="line">constructor --&gt; func</span><br><span class="line">proto --&gt; protoObj</span><br></pre></td></tr></table></figure><p>读取某个对象的某个属性时，查找这个属性的顺序如下：</p><ul><li>如果在实例中找到了具有给定名字的属性，则返回该属性的值；</li><li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性；如果在原型对象中找到了这个属性，否则继续查找原型对象的原型对象；</li><li>直到查找到<code>Object</code>，还是没有找到这个属性，则返回<code>undefined</code>。</li></ul><p>使用<code>hasOwnProperty</code>方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法是从<code>Object</code>继承来的），它只在给定属性存在于对象实例中时，才会返回<code>true</code>。来看下面这个例子。</p><h3 id="原型与in操作符"><a href="#原型与in操作符" class="headerlink" title="原型与in操作符"></a>原型与in操作符</h3><p>有两种方式使用<code>in</code>操作符：单独使用和在<code>for-in</code>循环中使用。</p><p>在单独使用时，<code>in</code>操作符会在通过对象能够访问给定属性时返回<code>true</code>，<strong>无论</strong>该属性存在于实例中还是原型中。</p><p>由于<code>in</code>操作符只要通过对象能够访问到属性就返回<code>true</code>，<code>hasOwnProperty()</code>只在属性存在于实例中时才返回<code>true</code>，因此只要<code>in</code>操作符返回<code>true</code>而<code>hasOwnProperty()</code>返回<code>false</code>，就可以确定属性是原型中的属性。</p><p>在使用<code>for-in</code>循环时，返回的是所有能够通过对象访问的、可枚举的（<code>enumerated</code>）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将<code>[[Enumerable]]</code>标记为<code>false</code>属性）的实例属性也会在<code>for-in</code>循环中返回。</p><p>要取得对象自身的所有可枚举的实例属性，可以使用ES5的<code>Object.keys()</code>方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p><h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><p>每次都写一个<code>Func.prototype.xxx = xxx;</code>十分繁琐，因此更常见的做法是用一个对象字面量来重写整个原型对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name : <span class="string">"siyuan"</span>,</span><br><span class="line">  age : <span class="number">22</span>,</span><br><span class="line">  sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样做与之前大体相同，不过有一点区别：<code>Person.prototype</code>不再带有指向<code>Person</code>的<code>constructor</code>属性了，因此只能通过<code>instanceof</code>操作符来判断对象的类型。</p><p>不过你也可以给<code>prototype</code>手动加上<code>constructor</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name : <span class="string">"siyuan"</span>,</span><br><span class="line">  age : <span class="number">22</span>,</span><br><span class="line">  sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line"><span class="comment">// 要保证constructor是不可枚举的</span></span><br><span class="line">enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型。</p><p>所有原生的引用类型（<code>Object</code>、<code>Array</code>、<code>String</code>，etc）都是采用这种原型模式创建的。</p><p>所有原生引用类型都在其构造函数的原型上定义了方法。例如在<code>Array.prototype</code>中可以找到<code>sort()</code>方法，而在<code>String.prototype</code>中可以找到<code>substring()</code>方法。</p><h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><p>原型模式省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下<strong>都将取得相同的属性值</strong>。</p><p>原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，这个问题很大很大：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name : "Siyuan",</span><br><span class="line">  age : 22,</span><br><span class="line">  friends : ["Eddy", "Jeffrey"],</span><br><span class="line">  sayName : function () &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Amanda"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);    <span class="comment">// ["Eddy", "Jeffrey", "Amanda"]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);    <span class="comment">// ["Eddy", "Jeffrey", "Amanda"]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p><p>这样每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person,</span><br><span class="line">  sayName : function()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Siyuan"</span>, <span class="number">22</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Eddy"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends);    <span class="comment">// "Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">// "Shelby,Count"</span></span><br><span class="line">alert(person1.friends === person2.friends);    <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>动态原型模式把所有信息都封装在了构造函数中，通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><p>在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。假设你想创建一个具有额外方法的特殊数组，但又不能直接修改<code>Array</code>构造函数，因此可以使用这个模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建数组</span></span><br><span class="line">  <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 添加值</span></span><br><span class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line">  values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回数组</span></span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖<code>instanceof</code>操作符来确定对象类型。由于存在上述问题，建议在可以使用其他模式的情况下，不要使用这种模式。</p></blockquote><h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用<code>this</code>的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用<code>this</code>和<code>new</code>），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。</p><p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：</p><ul><li>新创建对象的实例方法不引用<code>this</code>；</li><li>不使用<code>new</code>操作符调用构造函数。</li></ul><p>按照稳妥构造函数的要求，可以将前面的<code>Person</code>构造函数重写如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建要返回的对象</span></span><br><span class="line">  <span class="keyword">const</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...定义私有变量和函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加方法</span></span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(name);</span><br><span class="line">  &#125;;    </span><br><span class="line"><span class="comment">// 返回对象</span></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，变量<code>friend</code>中保存的是一个稳妥对象，而除了调用<code>sayName()</code>方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>让原型对象等于另一个类型的实例，此时原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>原型中包含引用类型值存在问题，我们可以使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）：在子类型构造函数的内部调用超类型构造函数。</p><p>函数只不过是在特定环境中执行代码的对象，因此通过使用<code>apply()</code>和<code>call()</code>方法也可以在（将来）新创建的对象上执行构造函数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// 继承了SuperType</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);    <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);    <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure><h2 id="组合继承-1"><a href="#组合继承-1" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（combination inheritance）指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。</p><p>其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);      <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line">instance1.sayName();          <span class="comment">// "Nicholas"</span></span><br><span class="line">instance1.sayAge();           <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);      <span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line">instance2.sayName();          <span class="comment">// "Greg"</span></span><br><span class="line">instance2.sayAge();           <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>ES5新增了<code>Object.create()</code>方法，接收两个参数：</p><ul><li>用作新对象原型的对象；</li><li>（可选的）一个为新对象定义额外属性的对象。</li></ul><p>在传入一个参数的情况下，<code>Object.create()</code>与<code>object()</code>方法的行为相同。</p><p><code>Object.create()</code>方法的第二个参数与<code>Object.defineProperties()</code>方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">"Greg"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name); <span class="comment">// "Greg"</span></span><br></pre></td></tr></table></figure><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄生式继承模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">  <span class="keyword">const</span> clone = <span class="built_in">Object</span>(original); </span><br><span class="line">  <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回这个对象</span></span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">// "hi"</span></span><br></pre></td></tr></table></figure><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>寄生组合式继承是通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。</p><p>本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="built_in">Object</span>(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line">    prototype.constructor = subType;             <span class="comment">// 增强对象</span></span><br><span class="line">    subType.prototype = prototype;               <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对象简介&quot;&gt;&lt;a href=&quot;#对象简介&quot; class=&quot;headerlink&quot; title=&quot;对象简介&quot;&gt;&lt;/a&gt;对象简介&lt;/h1&gt;&lt;p&gt;在JS中创建一个对象十分简单，可以使用&lt;code&gt;Object&lt;/code&gt;构造方法，也可以直接使用对象字面量：&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://sr2k.top/blog/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="https://sr2k.top/blog/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript高级程序设计" scheme="https://sr2k.top/blog/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何在 macOS 上使用 NSTouchBar</title>
    <link href="https://sr2k.top/blog/2017/10/10/%E8%AF%91-%E5%A6%82%E4%BD%95%E5%9C%A8macOS%E4%B8%8A%E4%BD%BF%E7%94%A8NSTouchBar/"/>
    <id>https://sr2k.top/blog/2017/10/10/译-如何在macOS上使用NSTouchBar/</id>
    <published>2017-10-09T16:01:11.000Z</published>
    <updated>2019-07-19T05:03:34.685Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://www.raywenderlich.com/" target="_blank" rel="noopener">raywenderlich.com</a> 的 <a href="https://www.raywenderlich.com/147118/use-nstouchbar-macos" target="_blank" rel="noopener">How to Use NSTouchBar on macOS</a>，已咨询对方网站，可至多翻译 10 篇文章。<br>各位若有英语阅读能力的话，还是<del>先打赏然后</del>去阅读英文原吧😉。<br>综上，此翻译版本仅供参考，<strong>谢绝转载</strong>。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-52bd2e529f437384.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>对了我跟着这个教程敲代码的时候发现文中所有的 <code>@available(OSX 10.12.1, *)</code> 其实应为 <code>@available(OSX 10.12.2, *)</code>，但是出于对原文的尊重没有修改，请各位注意～</p></blockquote><p>等了好久好久<del>终于等到今天</del>之后，Apple 终于发布了新款的 MacBook Pro，它最惹人瞩目的应该就是那块（小小的）触屏了吧。</p><p>新款设备用全新的 Touch Bar 替代了原有的功能键，它们可扩展、支持多点触控，更重要的是，Touch Bar 对开发者们完全开放，这意味着你的 macOS app 可以获得一种全新的交互方式。</p><p>如果你是一个 macOS 开发者，你一定很希望自己的 app 能够立刻使用上这项前沿科技。在这个教程中，我会将向你们展示如何使用全新的 <code>NSTouchBar</code> API 来为你的 macOS app 创建一个动态的 Touch Bar。</p><blockquote><p><strong>注意：</strong>这个教程需要 Xcode 8.1 或更高版本以及 macOS 10.12.1 (Build 16B2657) 或更高版本，否则的话你将无法运行 Touch Bar 模拟器。你可以在 <strong></strong> → <strong>关于本机</strong>里点击数字版本号来查看 build 版本。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f1e49c156d4e8aba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><br>如果你的版本不够，你可以在 <a href="https://support.apple.com/kb/dl1897" target="_blank" rel="noopener">Apple 的网站上</a> 下载。</p></blockquote><h1 id="Touch-Bar-是个啥？"><a href="#Touch-Bar-是个啥？" class="headerlink" title="Touch Bar 是个啥？"></a>Touch Bar 是个啥？</h1><p>如上文所述，Touch Bar 是一块安装在键盘上方的细长形的触摸屏，它允许用户使用一种全新的方式来与 app（以及 Mac）进行交互。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-1920310de9ddfda1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在 Touch Bar 上有三个默认的部分：</p><ul><li><em>系统按钮</em>：根据运行的 app，这里将会显示一个系统级的按钮，比如 esc；</li><li><em>App 区域</em>：你的 app 可以控制的显示区域，也就是我们的主舞台；</li><li><em>控制条</em>：这里用于显示你熟悉的控制按钮，比如亮度、音量等。</li></ul><p>和其它许多 Apple 的新科技一样，Touch Bar 也拥有自己的《人机交互则例（Human Interface Guidelines）》，为了你的 app 和其它 Mac app 拥有统一的用户体验，你应当遵循这份则例。你可以<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/OSXHIGuidelines/AbouttheTouchBar.html" target="_blank" rel="noopener">点击这里</a>阅读它。</p><p>概括说来，这份则例中比较重要的几点有：</p><ul><li><strong>App 中的某个功能不应该只能在 Touch Bar 中使用</strong>：即使部份用户还未升级到最新的硬件，你的 app 也应该尽量为他们提供一样的功能。如果你决定为 Touch Bar 加入某些功能，请确保这个功能也能在 app 的其他某处也可以访问到。另外 Touch Bar 是可以被用户禁用的，所以也别太指望你的用户能一直看到它；</li><li><strong>Touch Bar 是键盘的延伸，而不是一个显示屏</strong>：诚然，Touch Bar 是一个显示屏，但是它不是显示器的延伸，而是一个与 app 交互的窗口。你不应该在 Touch Bar 上用滚来滚去的内容或 blingbling 的警告打扰用户的视线；</li><li><strong>快速响应</strong>：用户在键盘上按下一个真实的按键时，按键会立即给予一个反馈（也就是被按下去了）。同理，用户在 Touch Bar 上按下一个虚拟按钮时，你也应该给他们提供即时的反馈。</li></ul><h1 id="如何让你的-app-支持-Touch-Bar"><a href="#如何让你的-app-支持-Touch-Bar" class="headerlink" title="如何让你的 app 支持 Touch Bar"></a>如何让你的 app 支持 Touch Bar</h1><p>要让你的 app 支持 Touch Bar，你需要使用 Apple 提供的两个类：<code>NSTouchBar</code> 和  <code>NSTouchBarItem</code>（当然还有他们的子类）。</p><p>某些 <code>NSTouchBarItem</code> 的子类提供了这些功能：</p><ul><li><strong>Slider</strong>：滑动调节某个值；</li><li><strong>Popover</strong>：把更多功能藏入一个二级菜单中；</li><li><strong>Color Picker</strong>：和名字一样，用来选取颜色的咯🤷‍♀️；</li><li><strong>Custom</strong>：这个子类是你的天下，你可以在它的里面塞入文本、按钮以及其他各种各样的控件。</li></ul><p>从文字大小颜色到图片内容，你可以随意自定义你的 item，从而为你的用户提供一个传统键盘无法提供的、更加牛×的交互方式，但是请时刻请谨记《人机交互则例》。现在我们要开始动工啦。</p><h1 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h1><p>在开始敲代码之前，请先<a href="https://koenig-media.raywenderlich.com/uploads/2016/10/TouchBar-Starter-2.zip" target="_blank" rel="noopener">点击这里</a>下载初始项目的源代码。</p><p>我们要编写的 app 是一个简单的旅行记录 app。打开初始项目，如果你的设备不支持 Touch Bar，请点击 Xcode 菜单栏上的 <strong>Window</strong> → <strong>Show Touch Bar</strong>，Touch Bar 的模拟器就会出现在屏幕上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-1ad812514b33ca1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>编译并运行你的 app，你将会看到 Touch Bar 上除了 esc 按钮和控制条以外空空如也。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-1c112d10fa6ba8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-eb56c213cf6eb050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们要做的第一步是告诉系统我们的 app 需要自定义 Touch Bar。打开 <strong>AppDelegate.swift</strong>，将这些代码添加到 <code>applicationDidFinishLaunching(_:)</code> 方法中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">(<span class="number">_</span> aNotification: Notification)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> #available(<span class="type">OSX</span> <span class="number">10.12</span>.<span class="number">1</span>, *) &#123;</span><br><span class="line">    <span class="type">NSApplication</span>.shared().isAutomaticCustomizeTouchBarMenuItemEnabled = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码将会帮你搞定启用 Touch Bar 所需要的各种操作，（在写这篇文章的时候）Xcode 还没有 macOS 10.12.1 的配套 SDK，所以你需要在 Touch Bar 相关的代码周边添加 <code>#available(OS X 10.12.1, *)</code>，当然如果你忘了这件事，Xcode 会给你一个温馨的提醒😉。</p><p>打开 <strong>WindowController.swift</strong>，找到 <code>makeTouchBar()</code>，这个方法用于检测 <code>ViewController</code> 是否含有一个可以被返回的 Touch Bar，如果有，它会把这个 Touch Bar 返回给 <strong>Window</strong>，然后呈现给用户。现在，我们还没有创建 Touch Bar，所以什么也不会发生。</p><p>在你开始创建自己的 Touch Bar 和 Touch Bar Item 之前，你需要注意这些类都需要独一无二的 identifier（标识符），打开 <strong>TouchBarIdentifiers.swift</strong>，你将能看到两个扩展定义了一些标识符：<code>NSTouchBarCustomizationIdentifier</code> 和 <code>NSTouchBarItemIdentifier</code>。</p><p>前往 <strong>ViewController.swift</strong>，并把这些带码添加到文件最后 <code>// MARK: - TouchBar Delegate</code> 注释的后方：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(<span class="type">OSX</span> <span class="number">10.12</span>.<span class="number">1</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">NSTouchBarDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeTouchBar</span><span class="params">()</span></span> -&gt; <span class="type">NSTouchBar?</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> touchBar = <span class="type">NSTouchBar</span>()</span><br><span class="line">    touchBar.delegate = <span class="keyword">self</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    touchBar.customizationIdentifier = .travelBar</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    touchBar.defaultItemIdentifiers = [.infoLabelItem]</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    touchBar.customizationAllowedItemIdentifiers = [.infoLabelItem]</span><br><span class="line">    <span class="keyword">return</span> touchBar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此处，通过重写 <code>makeTouchBar()</code> 方法，你给你的 View 或 Window 创建了一个 Touch Bar，在这个方法中：</p><ol><li>创建一个新的 <code>TouchBar</code> 并设置它的 delegate；</li><li>设置 customizationIdentifier（自定义标识符），每个 <code>TouchBar</code> 和 <code>TouchBarItem</code> 都需要一个独一无二的标识符；</li><li>设置 Touch Bar 的默认 item 标识符，这将会告诉 Touch Bar 它将会容纳哪些 item；</li><li>这一步是允许用户可以自定义的 item。作为参考，你可以打开 Finder，点击菜单栏上的 <strong>显示</strong> → <strong>自定 Multi-Touch Bar</strong>看看自定义 Touch Bar 是什么效果。</li></ol><p>接下来，我们还需要设置 <code>.infoLabelItem</code> 是什么样子的，在同一个 extension 中添加：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">touchBar</span><span class="params">(<span class="number">_</span> touchBar: NSTouchBar, makeItemForIdentifier identifier: NSTouchBarItemIdentifier)</span></span> -&gt; <span class="type">NSTouchBarItem?</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> identifier &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">NSTouchBarItemIdentifier</span>.infoLabelItem:</span><br><span class="line">      <span class="keyword">let</span> customViewItem = <span class="type">NSCustomTouchBarItem</span>(identifier: identifier)</span><br><span class="line">      customViewItem.view = <span class="type">NSTextField</span>(labelWithString: <span class="string">"\u&#123;1F30E&#125; \u&#123;1F4D3&#125;"</span>)</span><br><span class="line">      <span class="keyword">return</span> customViewItem</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现<code>touchBar(_:makeItemForIdentifier:)</code> 方法，你可以自定义你的 Touch Bar Item，在段代码里，你创建了一个 <code>NSCustomTouchBarItem</code>，并把它的 <code>view</code> 设置为了 <code>NSTextField</code>。</p><p>编译并运行你的 app，你可以看到 Touch Bar 多了一个 item。 </p><p><img src="http://upload-images.jianshu.io/upload_images/5477931-96245a90a25d22dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>耶✌️！通过一番努力你得到了……两个 emoji…好吧，现在我们来添加一些别的控件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-88d35baba7596185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="Text-Field-和-Scrubber"><a href="#Text-Field-和-Scrubber" class="headerlink" title="Text Field 和 Scrubber"></a>Text Field 和 Scrubber</h1><p>在 <code>makeTouchBar()</code> 里，把 <code>touchBar.defaultItemIdentifiers = [.infoLabelItem]</code> 修改为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchBar.defaultItemIdentifiers = [.infoLabelItem, .flexibleSpace, .ratingLabel, .ratingScrubber]</span><br></pre></td></tr></table></figure><p>这些代码会让 Touch Bar 显示三个 item：一个 label、一个 scrubber 以及一个 <code>.flexibleSpace</code>。这是一个动态的间距，它可以把各种 item 按组进行整洁的分类。此外你还可以使用 <code>.fixedSpaceSmall</code> 和 <code>.fixedSpaceLarge</code> 这两个固定间距。</p><p>和之前的那个 label 一样，你也需要自定义这些 item，把这些 <code>cases</code> 添加到 <code>touchBar(_:makeItemForIdentifier:)</code> 里的 <code>switch</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">NSTouchBarItemIdentifier</span>.ratingLabel:</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> customViewItem = <span class="type">NSCustomTouchBarItem</span>(identifier: identifier)</span><br><span class="line">  customViewItem.view = <span class="type">NSTextField</span>(labelWithString: <span class="string">"Rating"</span>)</span><br><span class="line">  <span class="keyword">return</span> customViewItem</span><br><span class="line"><span class="keyword">case</span> <span class="type">NSTouchBarItemIdentifier</span>.ratingScrubber:</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">let</span> scrubberItem = <span class="type">NSCustomTouchBarItem</span>(identifier: identifier)   </span><br><span class="line">  <span class="keyword">let</span> scrubber = <span class="type">NSScrubber</span>()</span><br><span class="line">  scrubber.scrubberLayout = <span class="type">NSScrubberFlowLayout</span>()</span><br><span class="line">  scrubber.register(<span class="type">NSScrubberTextItemView</span>.<span class="keyword">self</span>, forItemIdentifier: <span class="string">"RatingScrubberItemIdentifier"</span>)</span><br><span class="line">  scrubber.mode = .fixed</span><br><span class="line">  scrubber.selectionBackgroundStyle = .roundedBackground</span><br><span class="line">  scrubber.delegate = <span class="keyword">self</span></span><br><span class="line">  scrubber.dataSource = <span class="keyword">self</span></span><br><span class="line">  scrubberItem.view = scrubber</span><br><span class="line">  scrubber.bind(<span class="string">"selectedIndex"</span>, to: <span class="keyword">self</span>, withKeyPath: #keyPath(rating), options: <span class="literal">nil</span>)    </span><br><span class="line">  <span class="keyword">return</span> scrubberItem</span><br></pre></td></tr></table></figure><p>一步一步来看：</p><ol><li>为「评分」新建了一个新的 label item；</li><li>然后创建一个新的 item 用来展示 <code>NSScrubber</code>。这是一个 Touch Bar 特有的控件，它允许你在若干个项目中进行选择。Scrubber 需要一个代理来处理事件，你需要做的是设置一个 <code>delegate</code>（初始项目的源代码已经在 <strong>ViewController</strong> 里实现过这个协议了）。</li></ol><p>编译并运行你的 app，你将会看到 Touch Bar 里多出了两个新的 item，当你点击某个 scrubber 里的项目后，在 app 的主窗口里能看到数值的调整。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-de1447818a28d7be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="Segmented-Control"><a href="#Segmented-Control" class="headerlink" title="Segmented Control"></a>Segmented Control</h1><p>接下来，我们来添加一个 Segmented Control。这个控件没有使用 Delegate 模式，因此这刚好可以让你体验一下怎么设置 Touch Bar 里的 <strong>Target-Action（目标动作）</strong>。回到 <code>makeTouchBar()</code> 中，把这三个 item 添加到 <code>defaultItemIdentifiers</code> 里：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchBar.defaultItemIdentifiers = [.infoLabelItem, .flexibleSpace, .ratingLabel, .ratingScrubber, .flexibleSpace, .visitedLabelItem, .visitedItem, .visitSegmentedItem]</span><br></pre></td></tr></table></figure><p>以及把最后的三个 <code>case</code> 添加到 <code>touchBar(_:makeItemForIdentifier:)</code> 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">NSTouchBarItemIdentifier</span>.visitedLabelItem:</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> customViewItem = <span class="type">NSCustomTouchBarItem</span>(identifier: identifier)</span><br><span class="line">  customViewItem.view = <span class="type">NSTextField</span>(labelWithString: <span class="string">"Times Visited"</span>)</span><br><span class="line">  <span class="keyword">return</span> customViewItem</span><br><span class="line"><span class="keyword">case</span> <span class="type">NSTouchBarItemIdentifier</span>.visitedItem:</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">let</span> customViewItem = <span class="type">NSCustomTouchBarItem</span>(identifier: identifier)</span><br><span class="line">  customViewItem.view = <span class="type">NSTextField</span>(labelWithString: <span class="string">"--"</span>)</span><br><span class="line">  customViewItem.view.bind(<span class="string">"value"</span>, to: <span class="keyword">self</span>, withKeyPath: #keyPath(visited), options: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">return</span> customViewItem</span><br><span class="line"><span class="keyword">case</span> <span class="type">NSTouchBarItemIdentifier</span>.visitSegmentedItem:</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">let</span> customActionItem = <span class="type">NSCustomTouchBarItem</span>(identifier: identifier)</span><br><span class="line">  <span class="keyword">let</span> segmentedControl = <span class="type">NSSegmentedControl</span>(images: [<span class="type">NSImage</span>(named: <span class="type">NSImageNameRemoveTemplate</span>)!, <span class="type">NSImage</span>(named: <span class="type">NSImageNameAddTemplate</span>)!], trackingMode: .momentary, target: <span class="keyword">self</span>, action: #selector(changevisitedAmount(<span class="number">_</span>:)))</span><br><span class="line">  segmentedControl.setWidth(<span class="number">40</span>, forSegment: <span class="number">0</span>)</span><br><span class="line">  segmentedControl.setWidth(<span class="number">40</span>, forSegment: <span class="number">1</span>)</span><br><span class="line">  customActionItem.view = segmentedControl</span><br><span class="line">  <span class="keyword">return</span> customActionItem</span><br></pre></td></tr></table></figure><p>一步一步看：</p><ol><li>和之前一样，创建一个简单的 Label；</li><li>创建另一个 Label，但这一次使用 <strong>bind</strong> 来把 Label 要显示的文本绑定到一个属性上；</li><li>最后，创建一个 Segmented Control，并设置它的 action。你可以看到，为它设置一个 action 和其他常见控件是完全一样的。</li></ol><p>编译并运行，除了 Scrubber，你现在还可以和 Segmented Control 交互了。此外，在 Touch Bar 里修改一个数值，app 的主窗口中也会显示出来，反之亦然。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-a7c5438cf524b6a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="彩色按钮"><a href="#彩色按钮" class="headerlink" title="彩色按钮"></a>彩色按钮</h1><p>能让用户使用 Touch Bar 来进行「保存」操作是一个不错的点子，因为这个按钮和别的按钮都不一样，我们可以把它设置成绿色的。你可以使用 <code>NSButton</code> 的 <code>bezelColor</code> 属性来给它设置一个特殊的颜色。</p><p>打开 <strong>TouchBarIdentifiers.swift</strong>，在 <code>NSTouchBarItemIdentifier</code> extension 里，添加这些代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> saveItem = <span class="type">NSTouchBarItemIdentifier</span>(<span class="string">"com.razeware.SaveItem"</span>)</span><br></pre></td></tr></table></figure><p>这将会从头开始创建一个标识符，以此允许你在 Touch Bar 里添加一个 item。</p><p>返回 <strong>ViewController.swift</strong>，添加一个新的 <code>.flexSpace</code> 和 <code>.saveItem</code>  到 Touch Bar 的 <code>defaultItemIdentifiers</code> 里：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchBar.defaultItemIdentifiers = [.infoLabelItem, .flexibleSpace, .ratingLabel, .ratingScrubber, .flexibleSpace, .visitedLabelItem, .visitedItem, .visitSegmentedItem, .flexibleSpace, .saveItem]</span><br></pre></td></tr></table></figure><p>基本上完成了，最后一步是对按钮进行一些设置。在 <code>touchBar(_:makeItemForIdentifier:)</code> 中添加最后一个 <code>case</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">NSTouchBarItemIdentifier</span>.saveItem:</span><br><span class="line">  <span class="keyword">let</span> saveItem = <span class="type">NSCustomTouchBarItem</span>(identifier: identifier)</span><br><span class="line">  <span class="keyword">let</span> button = <span class="type">NSButton</span>(title: <span class="string">"Save"</span>, target: <span class="keyword">self</span>, action: #selector(save(<span class="number">_</span>:)))</span><br><span class="line">  button.bezelColor = <span class="type">NSColor</span>(red:<span class="number">0.35</span>, green:<span class="number">0.61</span>, blue:<span class="number">0.35</span>, alpha:<span class="number">1.00</span>)</span><br><span class="line">  saveItem.view = button</span><br><span class="line">  <span class="keyword">return</span> saveItem</span><br></pre></td></tr></table></figure><p>通过 <code>bezelColor</code>，你已经把这个按钮成功地修改成了绿色。</p><p>编译并运行，你会看到 Touch Bar 上有了一个绿色的按钮，它和窗口中的 <strong>Save</strong> 按钮拥有一样的功能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-c9f44cf8bb30f2df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="现在该做些啥？"><a href="#现在该做些啥？" class="headerlink" title="现在该做些啥？"></a>现在该做些啥？</h1><p>你可以<a href="https://koenig-media.raywenderlich.com/uploads/2016/10/TouchBar-Final-3.zip" target="_blank" rel="noopener">点击这里</a>下载最终完成的项目。 </p><p>这些就是 Touch Bar 的基础了。显然，Apple 希望 Touch Bar 的开发过程越简单越好，因此你可以尽快把这些特性尽快地带给新 MacBook Pro 的用户。</p><p>在这个教程中，你学到了：</p><ol><li>如何设置你的 app，让它能显示 Touch Bar；</li><li>如何在 Touch Bar 里显示静止的 Label；</li><li>如何使用 binding（绑定）来添加一个动态的 Label；</li><li>如何在 Touch Bar 中添加控件，并处理它们的事件。</li></ol><p>请不要在此停下！<code>NSTouchBar</code> 和 <code>NSTouchBarItem</code> 中还有很多值得探索的特性。你可以试着在 Touch Bar 里添加一个 Popover，或者也可以试试在你的 app 里格式化一个文本，你还可以在试着去在 Interface Builder 里创建一个 Touch Bar。</p><p><a href="https://www.raywenderlich.com/147118/use-nstouchbar-macos" target="_blank" rel="noopener">How to Use NSTouchBar on macOS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.raywenderlich.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raywenderlich.com&lt;/a&gt; 的 &lt;a href=&quot;https://www.r
      
    
    </summary>
    
    
      <category term="翻译" scheme="https://sr2k.top/blog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ray Wenderlich" scheme="https://sr2k.top/blog/tags/Ray-Wenderlich/"/>
    
      <category term="macOS" scheme="https://sr2k.top/blog/tags/macOS/"/>
    
      <category term="Swift" scheme="https://sr2k.top/blog/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】macOS 上的 Core Graphics 入门教程</title>
    <link href="https://sr2k.top/blog/2017/09/25/%E8%AF%91-macOS%E4%B8%8A%E7%9A%84CoreGraphics%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://sr2k.top/blog/2017/09/25/译-macOS上的CoreGraphics入门教程/</id>
    <published>2017-09-25T09:54:11.000Z</published>
    <updated>2019-07-19T05:03:34.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://www.raywenderlich.com/" target="_blank" rel="noopener">raywenderlich.com</a> 的 <a href="https://www.raywenderlich.com/128614/core-graphics-os-x-tutorial" target="_blank" rel="noopener">Core Graphics on macOS Tutorial</a>，已咨询对方网站，可至多翻译 10 篇文章。<br>希望各位有英语阅读能力的话，还是<strong>先打赏</strong>然后去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。<br>综上，此翻译版本仅供参考，<strong>谢绝转载</strong>。</p><p>也欢迎你点击我的头像查看我翻译的其他 macOS 开发教程💋</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-5204a02b7332fac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p><strong>更新于 2016-9-22：</strong>此教程已更新至 Xcode 8 和 Swift 3。</p></blockquote><p>你肯定见过许多拥有漂亮的界面和华丽的自定义视图的 app，它们肯定在你的心里留下了深刻的印象，因为它们是<strong>那！么！好！看！</strong></p><p><strong>Core Graphics</strong> 是 Apple 提供的 2D 绘图引擎，也几乎是 macOS 和 iOS 所有框架中最酷的了。它可以用来绘制你能想到的所有图形，从简单的几何形状到复杂的阴影和渐变等视觉效果。</p><p>在这个 macOS Core Graphics 教程中，你将会创造一个叫做 <strong>DiskInfo</strong> 的自定义视图，它能用一张饼图和一个条状图来显示出你 Mac 上的硬盘可用空间。这个教程将会让你拥有把平淡单调的 UI 变得精彩纷呈的能力：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f0a35f95c87f254e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在这个教程中你将学会：</p><ul><li>创建并配置一个自定义视图，这是绘制图形元素的必要条件；</li><li>实现实时渲染预览功能，有了它你不需要编译和运行，就能在 Interface Builder 里看到你对图形的各种修改；</li><li>用代码绘制路径、填充图形、创建剪切蒙版剪辑和渲染文本；</li><li>使用 <strong>AppKit</strong> 里的 <strong>Cocoa Drawing</strong> 工具提供的高级类和方法。</li></ul><p>在第一部分中，你将会通过 Core Graphics 来实现绘制一个饼图，稍后你将会学习如何用 Cocoa Drawing 实现相同的效果。</p><p>所以拿起你的小画刷，我们要开始作画啦～</p><h1 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h1><p><a href="https://koenig-media.raywenderlich.com/uploads/2016/06/DiskInfo-Starter.zip" target="_blank" rel="noopener">点击这里</a>下载 DiskInfo 的起步工程，编译并运行它：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-6aed1359cd471275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这个 app 会罗列出你的所有硬盘，点击任何一个即可查看他的详细信息。</p><p>在操作之前，我们先来熟悉一下这个项目的结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-8f84eb5ad169695c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>ViewController.swift</strong>：app 的主要 View Controller；</li><li><strong>VolumeInfo.swift</strong>：实现了用于处理硬盘信息的 <code>VolumeInfo</code> 类，以及用于分析不同文件类型所占空间的 <code>FilesDistribution</code> 结构体；</li><li><strong>NSColor+DiskInfo.swift</strong> 和 <strong>NSFont+DiskInfo.swift</strong>：扩展了 NSColor，定义了 app 中会用到的颜色和字体；</li><li><strong>CGFloat+Radians.swift</strong>：扩展了 CGFloat，提供了转换角度值和弧度制的 helper 方法；</li><li><strong>MountedVolumesDataSource.swift</strong> 和 <strong>MountedVolumesDelegate.swift</strong>：实现了显示硬盘信息所必需的各类方法。</li></ul><blockquote><p><strong>注意：</strong>这个 app 可以显示你真正的硬盘用量信息，但在这个教程中，它将会生成随机的数据。<br>每次启动 app 时都计算一次硬盘上所有文件的类型会很耗时，也会消磨完你所有的乐趣，没人愿意在这上面浪费时间，对吧😉？</p></blockquote><h1 id="创建一个自定义视图"><a href="#创建一个自定义视图" class="headerlink" title="创建一个自定义视图"></a>创建一个自定义视图</h1><p>你要做的第一件事是创建一个名叫 <code>GraphView</code> 的自定义视图。这将会是你绘制饼状图和条形图的地方。这个部分中你需要做两件事：</p><ol><li>创建一个 <code>NSView</code> 的子类；</li><li>重写 <code>draw(_:)</code> 方法，加入一些用于绘制的代码。</li></ol><h2 id="创建-NSView-的子类"><a href="#创建-NSView-的子类" class="headerlink" title="创建 NSView 的子类"></a>创建 NSView 的子类</h2><p>选中项目导航器的 <strong>Views</strong> 分组，点击去 Xcode 菜单上的 <strong>File</strong> → <strong>New</strong> → <strong>File…</strong>，然后点击 <strong>macOS</strong> → <strong>Source</strong> → <strong>Cocoa Class</strong> 模版。</p><p>点击 <strong>Next</strong>，把新的类命名为 <code>GraphView</code>，并让它继承自 <code>NSView</code>，把语言选择为 <strong>Swift</strong>。</p><p>点击 <strong>Next</strong> 和 <strong>Create</strong> 来保存你的文件。</p><p>打开 <strong>Main.storyboard</strong>，在 <strong>View Controller Scene</strong> 中，从<strong>控件库</strong>里拖入一个 <strong>Custom View</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-4fc358f76ed26670.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>选中这个 Custom View，在<strong>身份检查器</strong>里，把它的类名设置为 <code>GraphView</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-3dd1e7d056a92c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>你需要一些约束，所以保持 Graph View 的选中状态，点击 Auto Layout 工具栏上的 <strong>Pin</strong> 按钮，把它的 <strong>Top</strong>、<strong>Bottom</strong>、<strong>Leading</strong> 和 <strong>Trailing</strong> 约束设置为 0，然后点击 <strong>Add 4 Constrains</strong> 按钮。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-80fe225f08e1c3f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>点击 Auto Layout 工具栏上的三角形的 <strong>Resolve Auto Layout Issues</strong> 按钮，然后在 <strong>Selected Views</strong> 部分中点击 <strong>Update Frames</strong>。如果这个选项不可用，你可能需要先点击空白处取消选中 Graph View，然后再次选中它。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-8316bd45e283b331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="重写-draw"><a href="#重写-draw" class="headerlink" title="重写 draw(_:)"></a>重写 <code>draw(_:)</code></h2><p>打开 <strong>GraphView.swift</strong>，你能看到 Xcode 自动为我们创建了一个 <code>draw(_:)</code> 的实现。把那行注释替换成以下代码，并确保你别不小心删掉了它调用父类此方法的那一行哦。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSColor</span>.white.setFill() </span><br><span class="line"><span class="type">NSRectFill</span>(bounds)</span><br></pre></td></tr></table></figure><p>第一行代码把填充颜色设置为了白色，然后通过调用 <code>NSRectFill</code> 方法，你把整个视图的背景设成了白色。</p><p>编译并运行：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-3a9a9a76b687046c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>你已经把自定义视图的背景从默认的灰色改成了白色。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-e86ac3d6a8e288b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>哈哈，我们的画布已经就绪！就是这么简单～</p><h1 id="实时渲染预览：-IBDesignable-和-IBInspectable"><a href="#实时渲染预览：-IBDesignable-和-IBInspectable" class="headerlink" title="实时渲染预览：@IBDesignable 和 @IBInspectable"></a>实时渲染预览：<code>@IBDesignable</code> 和 <code>@IBInspectable</code></h1><p>Xcode 6 为我们带来了一个牛×的功能：实时渲染预览。它允许你在 Interface Builder 里查看你自定义的视图的样子，而不用每次都编译和运行。</p><p>要启用这个功能，你需要用 <code>@IBDesignable</code> 来修饰你的类；并实现 <code>prepareForInterfaceBuilder()</code> 方法来提供一些示例数据（实现这个方法不是必须的）。</p><p>打开 <strong>GraphView.swift</strong>，在类的定义之前加入：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBDesignable</span></span><br></pre></td></tr></table></figure><p>现在你需要提供一些示例数据，把这些代码添加到 <code>GraphView</code> 类中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileDistribution: <span class="type">FilesDistribution?</span> &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    needsDisplay = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForInterfaceBuilder</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> used = <span class="type">Int64</span>(<span class="number">100000000000</span>)</span><br><span class="line">  <span class="keyword">let</span> available = used / <span class="number">3</span></span><br><span class="line">  <span class="keyword">let</span> filesBytes = used / <span class="number">5</span></span><br><span class="line">  <span class="keyword">let</span> distribution: [<span class="type">FileType</span>] = [</span><br><span class="line">    .apps(bytes: filesBytes / <span class="number">2</span>, percent: <span class="number">0.1</span>),</span><br><span class="line">    .photos(bytes: filesBytes, percent: <span class="number">0.2</span>),</span><br><span class="line">    .movies(bytes: filesBytes * <span class="number">2</span>, percent: <span class="number">0.15</span>),</span><br><span class="line">    .audio(bytes: filesBytes, percent: <span class="number">0.18</span>),</span><br><span class="line">    .other(bytes: filesBytes, percent: <span class="number">0.2</span>)</span><br><span class="line">  ]</span><br><span class="line">  fileDistribution = <span class="type">FilesDistribution</span>(capacity: used + available,</span><br><span class="line">                                       available: available,</span><br><span class="line">                                       distribution: distribution)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将会定义一个 <code>fileDistribution</code> 属性用于存储硬盘的信息。当这个属性发生改变，它会设置这个视图的 <code>needsDisplay</code> 属性为 <code>true</code>，从而让视图重绘自己的内容。</p><p>然后，它实现了  <code>prepareForInterfaceBuilder()</code> 方法，以此创建了一个各种文件类型的例子，用于给 Xcode 预览这个视图。</p><blockquote><p><strong>注意：</strong>你甚至可以在 Interface Builder 里实时修改视觉属性。这要求你用 <code>@IBInspectable</code> 来修饰这个属性。</p></blockquote><p>下一步：用 <code>@IBInspectable</code> 修饰所有的视觉属性，把这些代码添加到 <code>GraphView</code> 的声明中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">Constants</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> barHeight: <span class="type">CGFloat</span> = <span class="number">30.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> barMinHeight: <span class="type">CGFloat</span> = <span class="number">20.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> barMaxHeight: <span class="type">CGFloat</span> = <span class="number">40.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> marginSize: <span class="type">CGFloat</span> = <span class="number">20.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> pieChartWidthPercentage: <span class="type">CGFloat</span> = <span class="number">1.0</span> / <span class="number">3.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> pieChartBorderWidth: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> pieChartMinRadius: <span class="type">CGFloat</span> = <span class="number">30.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> pieChartGradientAngle: <span class="type">CGFloat</span> = <span class="number">90.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> barChartCornerRadius: <span class="type">CGFloat</span> = <span class="number">4.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> barChartLegendSquareSize: <span class="type">CGFloat</span> = <span class="number">8.0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> legendTextMargin: <span class="type">CGFloat</span> = <span class="number">5.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barHeight: <span class="type">CGFloat</span> = <span class="type">Constants</span>.barHeight &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    barHeight = <span class="built_in">max</span>(<span class="built_in">min</span>(barHeight, <span class="type">Constants</span>.barMaxHeight), <span class="type">Constants</span>.barMinHeight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> pieChartUsedLineColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.pieChartUsedStrokeColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> pieChartAvailableLineColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.pieChartAvailableStrokeColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> pieChartAvailableFillColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.pieChartAvailableFillColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> pieChartGradientStartColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.pieChartGradientStartColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> pieChartGradientEndColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.pieChartGradientEndColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartAvailableLineColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.availableStrokeColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartAvailableFillColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.availableFillColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartAppsLineColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.appsStrokeColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartAppsFillColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.appsFillColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartMoviesLineColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.moviesStrokeColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartMoviesFillColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.moviesFillColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartPhotosLineColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.photosStrokeColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartPhotosFillColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.photosFillColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartAudioLineColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.audioStrokeColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartAudioFillColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.audioFillColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartOthersLineColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.othersStrokeColor</span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">var</span> barChartOthersFillColor: <span class="type">NSColor</span> = <span class="type">NSColor</span>.othersFillColor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">colorsForFileType</span><span class="params">(fileType: FileType)</span></span> -&gt; (strokeColor: <span class="type">NSColor</span>, fillColor: <span class="type">NSColor</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> fileType &#123;</span><br><span class="line">  <span class="keyword">case</span> .audio(<span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="keyword">return</span> (strokeColor: barChartAudioLineColor, fillColor: barChartAudioFillColor)</span><br><span class="line">  <span class="keyword">case</span> .movies(<span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="keyword">return</span> (strokeColor: barChartMoviesLineColor, fillColor: barChartMoviesFillColor)</span><br><span class="line">  <span class="keyword">case</span> .photos(<span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="keyword">return</span> (strokeColor: barChartPhotosLineColor, fillColor: barChartPhotosFillColor)</span><br><span class="line">  <span class="keyword">case</span> .apps(<span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="keyword">return</span> (strokeColor: barChartAppsLineColor, fillColor: barChartAppsFillColor)</span><br><span class="line">  <span class="keyword">case</span> .other(<span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="keyword">return</span> (strokeColor: barChartOthersLineColor, fillColor: barChartOthersFillColor)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一大坨代码的作用是：</p><ol><li>声明了带有许多常量的结构体 —— 你得在这个 app 的各个地方用到它们；</li><li>用 <code>@IBInspectable</code> 修饰所有可配置的属性。并使用 <strong>NSColor+DiskInfo.swift</strong> 中的值为它们赋值。注意：要使一个属性「inspectable」（可以在 Interface Builder 里直接编辑），你必须声明它的类型，即使大多数情况下 Swift 会帮你做这件事儿；</li><li>定义一个 Helper 方法，为不同的文件类型返回它的笔触颜色和填充颜色。你在绘制「什么文件占了多大地儿」的图表的时候会用到它。</li></ol><p>打开 <strong>Main.stroyboard</strong>，你应该能注意到 Graph View 已经从默认的灰色变成了白色，这意味着实时渲染预览已经起作用了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-466bd5ddecfe519d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>选中 Graph View，打开<strong>属性检查器</strong>，你会发现所有的「inspectable」属性已经出现在这里了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-ea983d52c0f02849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在开始，要查看调整好的效果，你可以直接编译和运行，也可以直接在 Interface Builder 里查看。</p><p>万事俱备，是时候开始真正的绘制啦！</p><h1 id="Graphics-Context（图形上下文）"><a href="#Graphics-Context（图形上下文）" class="headerlink" title="Graphics Context（图形上下文）"></a>Graphics Context（图形上下文）</h1><p>在使用 Core Graphics 的时候，你并不是直接在视图中绘画，而是使用一个叫 <strong>Graphics Context（图形上下文）</strong>的东西，它是系统渲染图形与把图形显示在视图中的中间层。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-077fb51fe0aae885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Core Graphics 使用一个叫「Painter’s Model（画家模式）」的模式，你可以想像成自己拿着笔，唰唰地在画布上绘图样子。你需要放置一个路径，然后去填充它，你没办法去改变已经布置好的像素们，但你可以在它们之上继续画图。</p><p>这个「上下文」非常重要，因为他决定了你最终得到的效果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-8be0aad94ef83a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h1><p>要使用 Core Graphics 绘制一个路径，你需要定义一个 <strong>Path（路径）</strong>，也就是 <code>CGPathRef</code> 和可变的 <code>CGMutablePathRef</code>。</p><p>路径准备好以后，把它添加到图形上下文里，就可以根据路径和绘制属性渲染出你要的图形了。</p><h2 id="为饼图…绘制一个路径"><a href="#为饼图…绘制一个路径" class="headerlink" title="为饼图…绘制一个路径"></a>为饼图…绘制一个路径</h2><p>条形图的基本元素是圆角矩形，所以我们从这里开始入手。</p><p>打开 <strong>GraphView.swift</strong>，把这个扩展添加在文件底部类定义以外的地方：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - 用于绘制的 extension</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">GraphView</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">drawRoundedRect</span><span class="params">(rect: CGRect, inContext context: CGContext?,</span></span></span><br><span class="line"><span class="function"><span class="params">                       radius: CGFloat, borderColor: CGColor, fillColor: CGColor)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> path = <span class="type">CGMutablePath</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    path.move( to: <span class="type">CGPoint</span>(x:  rect.midX, y:rect.minY ))</span><br><span class="line">    path.addArc( tangent1End: <span class="type">CGPoint</span>(x: rect.maxX, y: rect.minY ), </span><br><span class="line">                 tangent2End: <span class="type">CGPoint</span>(x: rect.maxX, y: rect.maxY), radius: radius)</span><br><span class="line">    path.addArc( tangent1End: <span class="type">CGPoint</span>(x: rect.maxX, y: rect.maxY ), </span><br><span class="line">                 tangent2End: <span class="type">CGPoint</span>(x: rect.minX, y: rect.maxY), radius: radius)</span><br><span class="line">    path.addArc( tangent1End: <span class="type">CGPoint</span>(x: rect.minX, y: rect.maxY ), </span><br><span class="line">                 tangent2End: <span class="type">CGPoint</span>(x: rect.minX, y: rect.minY), radius: radius)</span><br><span class="line">    path.addArc( tangent1End: <span class="type">CGPoint</span>(x: rect.minX, y: rect.minY ), </span><br><span class="line">                 tangent2End: <span class="type">CGPoint</span>(x: rect.maxX, y: rect.minY), radius: radius)</span><br><span class="line">    path.closeSubpath()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    context?.setLineWidth(<span class="number">1.0</span>)</span><br><span class="line">    context?.setFillColor(fillColor)</span><br><span class="line">    context?.setStrokeColor(borderColor)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    context?.addPath(path)</span><br><span class="line">    context?.drawPath(using: .fillStroke)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太长不看🙄️：以上<strong>就</strong>是绘制一个圆角矩形的方法，用人类能理解的语言解释一遍就是：</p><ol><li>创建一个可以改变的路径；</li><li>一步一步勾勒出一个圆角矩形：<ul><li>移动到矩形底边的中点，这里将是我们的起点；</li><li>使用 <code>addArc(tangent1End:tangent2End:radius)</code> 方法绘制右下角的线段，这个方法会绘制出底部的水平线以及右下角的圆角；</li><li>添加右边的线段和右上角的圆角；</li><li>添加顶部的线段和左上角的圆角；</li><li>添加左边的线段和左下角的圆角；</li><li>闭合路径，也就是从上一步的重点连接到起点；</li></ul></li><li>设置绘制属性：线宽、填充颜色和边框颜色；</li><li>把路径添加到图形上下文，并使用 <code>.fillStroke</code> 参数绘制着个路径，这个参数将会告诉 Core Graphics 这条路径需要填充颜色并绘制边框。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-11f0c635e8e2e781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="计算位置"><a href="#计算位置" class="headerlink" title="计算位置"></a>计算位置</h2><p>使用 Core Graphics 进行绘制的过程其实就是计算各个视觉元素在视图中位置的过程。所以我们需要关心的就是把不同的元素放置在哪，以及当视图的大小发生变化时它们该如何应对。</p><p>我们准备这样布局我们的视图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-c03336233ad3ca43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>打开 <strong>GraphView.swift</strong> 并添加这个扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - 用于计算的 extension</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">GraphView</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pieChartRectangle</span><span class="params">()</span></span> -&gt; <span class="type">CGRect</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> width = bounds.size.width * <span class="type">Constants</span>.pieChartWidthPercentage - <span class="number">2</span> * <span class="type">Constants</span>.marginSize</span><br><span class="line">    <span class="keyword">let</span> height = bounds.size.height - <span class="number">2</span> * <span class="type">Constants</span>.marginSize</span><br><span class="line">    <span class="keyword">let</span> diameter = <span class="built_in">max</span>(<span class="built_in">min</span>(width, height), <span class="type">Constants</span>.pieChartMinRadius)</span><br><span class="line">    <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="type">Constants</span>.marginSize,</span><br><span class="line">                      y: bounds.midY - diameter / <span class="number">2.0</span>,</span><br><span class="line">                      width: diameter, height: diameter)</span><br><span class="line">    <span class="keyword">return</span> rect</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">barChartRectangle</span><span class="params">()</span></span> -&gt; <span class="type">CGRect</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pieChartRect = pieChartRectangle()</span><br><span class="line">    <span class="keyword">let</span> width = bounds.size.width - pieChartRect.maxX - <span class="number">2</span> * <span class="type">Constants</span>.marginSize</span><br><span class="line">    <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: pieChartRect.maxX + <span class="type">Constants</span>.marginSize,</span><br><span class="line">                      y: pieChartRect.midY + <span class="type">Constants</span>.marginSize,</span><br><span class="line">                      width: width, height: barHeight)</span><br><span class="line">    <span class="keyword">return</span> rect</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">barChartLegendRectangle</span><span class="params">()</span></span> -&gt; <span class="type">CGRect</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> barchartRect = barChartRectangle()</span><br><span class="line">    <span class="keyword">let</span> rect = barchartRect.offsetBy(dx: <span class="number">0.0</span>, dy: -(barchartRect.size.height + <span class="type">Constants</span>.marginSize))</span><br><span class="line">    <span class="keyword">return</span> rect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码做了这些必要的计算：</p><ol><li>从计算饼图的位置开始入手，它将会垂直居中，并占据视图 1/3 的宽度；</li><li>计算条形图的位置，它将会占据 2/3 的宽度，并处于视图中部偏上的位置；</li><li>根据饼图的最小 Y 值和边距来计算图例的位置。</li></ol><p>现在我们来把把它绘制到你的视图中去，在 <code>GraphView</code> 的用于绘制的扩展中加入：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drawBarGraphInContext</span><span class="params">(context: CGContext?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> barChartRect = barChartRectangle()</span><br><span class="line">  drawRoundedRect(rect: barChartRect, inContext: context,</span><br><span class="line">                  radius: <span class="type">Constants</span>.barChartCornerRadius,</span><br><span class="line">                  borderColor: barChartAvailableLineColor.cgColor,</span><br><span class="line">                  fillColor: barChartAvailableFillColor.cgColor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要一个 Helper 方法来绘制条形图，它会绘制一个圆角矩形，并使用画笔颜色和填充颜色在空白处绘制图形，你可以在 <strong>NSColor+DiskInfo</strong> 扩展中找到这个些颜色。</p><p>把 <code>draw(_:)</code> 方法里的所有代码替换成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.draw(dirtyRect)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">let</span> context = <span class="type">NSGraphicsContext</span>.current()?.cgContext</span><br><span class="line">drawBarGraphInContext(context: context)</span><br></pre></td></tr></table></figure><p>这段代码会真正地把图形绘制到视图中去。首先，通过调用 <code>NSGraphicsContext.current()</code>，我们获取到了当前视图的图形上下文，然后我们调用刚刚编写的方法绘制出了条形图。</p><p>编译并运行，你可以看到条形图已经就位了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-0d2de8a91a09b0bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在，打开 <strong>Main.storyboard</strong> 并选中 <strong>View Controller Scene</strong>， 你会看到这个：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-b066eae14cf2949c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Interface Builder 为你实时渲染了预览。你可以试着去修改一下颜色，它也会实时响应你的修改，是不是很棒棒呀😄～</p><h1 id="剪切一部分区域（也就是蒙版）"><a href="#剪切一部分区域（也就是蒙版）" class="headerlink" title="剪切一部分区域（也就是蒙版）"></a>剪切一部分区域（也就是蒙版）</h1><p>现在我们来制作文件分布图，也就是这个家伙：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-81d4bc8182f1d863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>先暂停一下下，我们来理理思路。显而易见的是，每种文件都有自己的专属颜色，我们的 app 只需要根据这种文件占硬盘空间大小的百分比来计算每个方块的宽度，然后用对应的颜色把它绘制出来。</p><p>你需要绘制一个不规则的图形，比如一个!@#¥%%。然而，我们可以通过一个叫 <strong>clipping areas（蒙板）</strong> 的技术来避免编写重复代码。</p><blockquote><p>👆这一段的第一句实在没看懂，求指正：You could create a special shape, such as a filled rectangle with two lines at bottom and top of the rectangle。</p></blockquote><p>你可以把蒙版想象成「在一张纸上剪了个窟窿」，你只能透过这个窟窿看到部分的图形。这个「窟窿」就叫做「Clipping Mask（剪切蒙版）」，你需要在 Core Graphics 里定义它。</p><p>在这个条形图的例子里，你需要为每种文件分类创建一个完整的圆角矩形，然后通过剪切蒙版来使它们只显示正确的部分：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-a87e7ca09027a440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>理论说完了，我们来动手吧～</p><p>开支绘制之前，你需要为选中的硬盘设置 <code>fileDistribution</code>。打开 <strong>Main.storyboard</strong>，我们来创建一个 Outlet 连接。</p><p>在项目导航器里按住 <strong>Option⌥ 键</strong>的同时点击 <strong>ViewController.swift</strong>，使它显示在右半边的<strong>协助编辑器</strong>里，然后按住 <strong>Control⌃ 键</strong>的同时把 Graph View 拖动到 View Controller 的代码里。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-bfc8259a9457f83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在弹出的小气泡里，把这个 Outlet 命名为 <code>graphView</code>，并点击 <strong>Connect</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-a1d8f29e9ccf8ff1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>打开 <strong>ViewController.swift</strong> 并把这行代码添加到 <code>showVolumeInfo(_:)</code> 的末尾：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graphView.fileDistribution = volume.fileDistribution</span><br></pre></td></tr></table></figure><p>这行代码设置了 <code>fileDistribution</code> 的值，从而让 Graph View 能获取各类文件占的百分比。</p><p>打开 <strong>GraphView.swift</strong>，把这些代码添加到 <code>drawBarGraphInContext(context:)</code> 的末尾来绘制条形图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fileTypes = fileDistribution?.distribution, <span class="keyword">let</span> capacity = fileDistribution?.capacity, capacity &gt; <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> clipRect = barChartRect</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">for</span> (index, fileType) <span class="keyword">in</span> fileTypes.enumerated() &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> fileTypeInfo = fileType.fileTypeInfo</span><br><span class="line">    <span class="keyword">let</span> clipWidth = floor(barChartRect.width * <span class="type">CGFloat</span>(fileTypeInfo.percent))</span><br><span class="line">    clipRect.size.width = clipWidth</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    context?.saveGState()</span><br><span class="line">    context?.clip(to: clipRect)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fileTypeColors = colorsForFileType(fileType: fileType)</span><br><span class="line">    drawRoundedRect(rect: barChartRect, inContext: context,</span><br><span class="line">                    radius: <span class="type">Constants</span>.barChartCornerRadius,</span><br><span class="line">                    borderColor: fileTypeColors.strokeColor.cgColor,</span><br><span class="line">                    fillColor: fileTypeColors.fillColor.cgColor)</span><br><span class="line">    context?.restoreGState()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    clipRect.origin.x = clipRect.maxX</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码做了这些事儿：</p><ol><li>先确保了 Graph View 拥有一个有效的 <code>fileDistribution</code>；</li><li>遍历 <code>fileDistribution</code> 里的每一种文件类型；</li><li>根据文件的占比计算蒙版的大小；</li><li>存储图形上下文的状态，设置蒙版的大小，用文件类型对应的颜色绘制圆角矩形，并恢复图形上下文的状态；</li><li>把剪切蒙版的 <strong>x</strong> 移动到正确的位置。</li></ol><p>你可能会奇怪：为什么要先存储，再恢复图形上下文？还记得「painter’s model」吗？你添加到图形上下文里的所有东西都会被保存在上下文中，就像你画在纸上的画，会一直在那里。</p><p>如果你添加了多个剪切蒙版，事实上你是只创建了一个剪切蒙版，并应用到所有矩形上。要避免这种情况，你需要在添加新的剪切蒙版之前存储上下文的状态，等你使用完了这个蒙版，再把它恢复出来，再处理新的蒙版。</p><p>此时，<strong>Xcode</strong> 会弹出一个警告，因为 <code>index</code> 从没被使用过。别担心，它的待会儿就会派上用场。</p><p>编译并运行，或者直接打开 <strong>Main.storyboard</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-53339621371d124f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>哈哈，DiskInfo 功能似乎已经渐渐完善了呢～除了图例，这个条形图已经基本完工了👍。</p><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><p>在自定义视图里绘制文本特别简单，你需要为这个文本的各种属性创建一个字典，包含了字体、尺寸、颜色和对齐，把它传入 <code>String</code> 的 <code>draw(in:withAttributes:)</code> 方法。这些属性将会在我们计算矩形大小和位置的时候派上用场。</p><p>打开 <strong>GraphView.swift</strong>，把这个属性添加到类的定义里：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> bytesFormatter = <span class="type">ByteCountFormatter</span>()</span><br></pre></td></tr></table></figure><p>这将会创建一个 <strong>ByteCountFormatter</strong>。它会帮我们完成「把字节转化成人话」这个高深而繁重的工作。</p><p>现在，在 <code>drawBarGraphInContext(context:)</code> 方法的 <code>for (index,fileType) in fileTypes.enumerated()</code> 循环里加入这些代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> legendRectWidth = (barChartRect.size.width / <span class="type">CGFloat</span>(fileTypes.<span class="built_in">count</span>))</span><br><span class="line"><span class="keyword">let</span> legendOriginX = barChartRect.origin.x + floor(<span class="type">CGFloat</span>(index) * legendRectWidth)</span><br><span class="line"><span class="keyword">let</span> legendOriginY = barChartRect.minY - <span class="number">2</span> * <span class="type">Constants</span>.marginSize</span><br><span class="line"><span class="keyword">let</span> legendSquareRect = <span class="type">CGRect</span>(x: legendOriginX, y: legendOriginY,</span><br><span class="line">                              width: <span class="type">Constants</span>.barChartLegendSquareSize,</span><br><span class="line">                              height: <span class="type">Constants</span>.barChartLegendSquareSize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> legendSquarePath = <span class="type">CGMutablePath</span>()</span><br><span class="line">legendSquarePath.addRect( legendSquareRect )</span><br><span class="line">context?.addPath(legendSquarePath)</span><br><span class="line">context?.setFillColor(fileTypeColors.fillColor.cgColor)</span><br><span class="line">context?.setStrokeColor(fileTypeColors.strokeColor.cgColor)</span><br><span class="line">context?.drawPath(using: .fillStroke)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> paragraphStyle = <span class="type">NSMutableParagraphStyle</span>()</span><br><span class="line">paragraphStyle.lineBreakMode = .byTruncatingTail</span><br><span class="line">paragraphStyle.alignment = .<span class="keyword">left</span></span><br><span class="line"><span class="keyword">let</span> nameTextAttributes = [</span><br><span class="line">  <span class="type">NSFontAttributeName</span>: <span class="type">NSFont</span>.barChartLegendNameFont,</span><br><span class="line">  <span class="type">NSParagraphStyleAttributeName</span>: paragraphStyle]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> nameTextSize = fileType.name.size(withAttributes: nameTextAttributes)</span><br><span class="line"><span class="keyword">let</span> legendTextOriginX = legendSquareRect.maxX + <span class="type">Constants</span>.legendTextMargin</span><br><span class="line"><span class="keyword">let</span> legendTextOriginY = legendOriginY - <span class="number">2</span> * <span class="type">Constants</span>.pieChartBorderWidth</span><br><span class="line"><span class="keyword">let</span> legendNameRect = <span class="type">CGRect</span>(x: legendTextOriginX, y: legendTextOriginY,</span><br><span class="line">                            width: legendRectWidth - legendSquareRect.size.width - <span class="number">2</span> *</span><br><span class="line">                              <span class="type">Constants</span>.legendTextMargin,</span><br><span class="line">                            height: nameTextSize.height)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">fileType.name.draw(<span class="keyword">in</span>: legendNameRect, withAttributes: nameTextAttributes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> bytesText = bytesFormatter.string(fromByteCount: fileTypeInfo.bytes)</span><br><span class="line"><span class="keyword">let</span> bytesTextAttributes = [</span><br><span class="line">  <span class="type">NSFontAttributeName</span>: <span class="type">NSFont</span>.barChartLegendSizeTextFont,</span><br><span class="line">  <span class="type">NSParagraphStyleAttributeName</span>: paragraphStyle,</span><br><span class="line">  <span class="type">NSForegroundColorAttributeName</span>: <span class="type">NSColor</span>.secondaryLabelColor]</span><br><span class="line"><span class="keyword">let</span> bytesTextSize = bytesText.size(withAttributes: bytesTextAttributes)</span><br><span class="line"><span class="keyword">let</span> bytesTextRect = legendNameRect.offsetBy(dx: <span class="number">0.0</span>, dy: -bytesTextSize.height)</span><br><span class="line">bytesText.draw(<span class="keyword">in</span>: bytesTextRect, withAttributes: bytesTextAttributes)</span><br></pre></td></tr></table></figure><p>看起来这一大堆代码还挺唬人的，其实很简单：</p><ol><li>你已经很熟悉这一段代码了：计算图例的彩色方块的位置，为它创建一条路径，并用对应的颜色填充；</li><li>创建一个字典，包含了两个属性：字体和 <code>NSMutableParagraphStyle</code>。后者会定义这些文本会怎样在给定的矩形里被绘制出来。在这个例子中，文本会显示为左对齐，且若文本超出了矩形范围，系统会在他的末尾加上省略号；</li><li>计算用于绘制文本的矩形的位置和大小；</li><li>调用 <code>draw(in:withAttributes:)</code>，绘制文本；</li><li>使用 <code>bytesFormatter</code> 获取文本，并设置「文件大小」的文本的属性。这和之前唯一的区别是：这个文本用 <code>NSFontAttributeName</code> 设置了一个不同的颜色。</li></ol><p>编译并运行，或者前往 <strong>Main.storyboard</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-bf60da1d58848b16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>热烈祝贺条形图杀青成功！你现在可以调整一下窗口的大小，看看图例里的文本时如何给自己加上省略号来适应狭小的空间的。</p><p>给自己鼓个掌吧👏～</p><h1 id="Cocoa-Drawing"><a href="#Cocoa-Drawing" class="headerlink" title="Cocoa Drawing"></a>Cocoa Drawing</h1><p><strong>macOS</strong> 还提供了使用 <strong>AppKit</strong> 的框架来进行绘制的选项。它将会提供更高层的抽象绘图法。它使用各种类来代替 <strong>C 语言</strong>的函数，它还包含了许多 Helper 方法来更轻松地应对常见绘图任务。在两个框架中，图形上下文是一样的。如果你对 Core Graphics 很熟悉的话，你应该能很轻松地掌握 Cocoa Drawing。</p><p>和 Core Graphics 一样，你需要创建并绘制路径，但在 Cocoa Drawing，我们使用 <code>NSBezierPath</code>，它和 <code>CGPathRef</code> 是一样的。</p><p>我们要绘制的饼图是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-e246d4795e5dec1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>你需要分三步来绘制它：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-bda1ff3ab8d8e064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><ol><li>创建一条圆形的路径，用于显示总硬盘空间，然后用定义好的颜色绘制它；</li><li>为已用空间创建一条路径，并绘制它；</li><li>为已用空间的路径绘制一个渐变填充。</li></ol><p>打开 <strong>GraphView.swift</strong>，把这个方法添加到用于绘制的 extension 里：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drawPieChart</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> fileDistribution = fileDistribution <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> rect = pieChartRectangle()</span><br><span class="line">  <span class="keyword">let</span> circle = <span class="type">NSBezierPath</span>(ovalIn: rect)</span><br><span class="line">  pieChartAvailableFillColor.setFill()</span><br><span class="line">  pieChartAvailableLineColor.setStroke()</span><br><span class="line">  circle.stroke()</span><br><span class="line">  circle.fill()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">let</span> path = <span class="type">NSBezierPath</span>()</span><br><span class="line">  <span class="keyword">let</span> center = <span class="type">CGPoint</span>(x: rect.midX, y: rect.midY)</span><br><span class="line">  <span class="keyword">let</span> usedPercent = <span class="type">Double</span>(fileDistribution.capacity - fileDistribution.available) /</span><br><span class="line">    <span class="type">Double</span>(fileDistribution.capacity)</span><br><span class="line">  <span class="keyword">let</span> endAngle = <span class="type">CGFloat</span>(<span class="number">360</span> * usedPercent)</span><br><span class="line">  <span class="keyword">let</span> radius = rect.size.width / <span class="number">2.0</span></span><br><span class="line">  path.move(to: center)</span><br><span class="line">  path.line(to: <span class="type">CGPoint</span>(x: rect.maxX, y: center.y))</span><br><span class="line">  path.appendArc(withCenter: center, radius: radius,</span><br><span class="line">                                         startAngle: <span class="number">0</span>, endAngle: endAngle)</span><br><span class="line">  path.close()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  pieChartUsedLineColor.setStroke()</span><br><span class="line">  path.stroke()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分析一下这段代码：</p><ol><li>用 <code>init(ovalIn:)</code> 构造方法创建一条圆形的路径，设置它的填充颜色和笔触颜色，然后绘制这条路径；</li><li>为已用空间创建一条路径：<ul><li>根据已用空间计算扇形的角度；</li><li>移动到大圆的圆心；</li><li>添加一条从圆心到圆的右顶点的线段；</li><li>根据之前计算的角度添加一条圆弧；</li><li>闭合图形，也就是从圆弧的终点连接到圆心；</li></ul></li><li>调用 <code>stroke()</code> 方法，设置笔触颜色；</li></ol><p>你应该能发现这段代码和之前的区别：</p><ul><li>代码中没有提到过图形上下文，因为我们调用的方法会自动获取当前的上下文，在这个例子中，就是视图自己的图形上下文；</li><li>角是以角度制计算，而不是弧度制。<strong>CGFloat+Radians.swift</strong> 扩展了 CGFloat 类来进行了自动转换。</li></ul><p>现在把这行代码添加到 <code>draw(_:)</code> 方法中来绘制饼图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawPieChart()</span><br></pre></td></tr></table></figure><p>编译并运行：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-5169614dde1ef08a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>进展不错！</p><h2 id="绘制渐变"><a href="#绘制渐变" class="headerlink" title="绘制渐变"></a>绘制渐变</h2><p><strong>Cocoa Drawing</strong> 使用 <code>NSGradient</code> 来绘制渐变。</p><p>你需要在已使用的扇形里绘制渐变，该怎么实现呢……🤔？</p><p>没错，用剪切蒙版啊！</p><p>你已经创建了一条路径来绘制已用空间的扇形，在我们绘制渐变之前，先来把它用作剪切蒙版。</p><p>把这些代码添加到 <code>drawPieChart()</code> 方法中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> gradient = <span class="type">NSGradient</span>(starting: pieChartGradientStartColor,</span><br><span class="line">                             ending: pieChartGradientEndColor) &#123;</span><br><span class="line">  gradient.draw(<span class="keyword">in</span>: path, angle: <span class="type">Constants</span>.pieChartGradientAngle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行代码会试着去创建一个两种颜色构成的渐变。如果创建成功了，就会调用 <code>draw(in:angle:)</code> 方法来绘制它。在大括号里，这个方法会设置蒙版，并在蒙版区域内绘制渐变。是不是特别棒～</p><p>编译并运行：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-27ddddbb77a21564.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="练习-挑战：绘制饼图的图例"><a href="#练习-挑战：绘制饼图的图例" class="headerlink" title="练习/挑战：绘制饼图的图例"></a>练习/挑战：绘制饼图的图例</h1><p>现在我们的自定义视图已经越来越完美了，但还有一个待办事项：绘制饼图的图例，也就是其内部的文字说明。</p><p>你已经知道该怎么去做了，准备好接受挑战了嘛💪？</p><p>一些小提示：</p><ol><li>使用 <code>bytesFormatter</code> 来获取硬盘的可用空间（<code>fileDistribution.available</code> 属性）和总空间（<code>fileDistribution.capacity</code> 属性）；</li><li>计算文本的位置，确保你的文本显示在各个扇形的中央；</li><li>在计算好的位置用以下属性绘制文本：<ul><li>Font：<code>NSFont.pieChartLegendFont</code>；</li><li>Used space text color：<code>NSColor.pieChartUsedSpaceTextColor</code>；</li><li>Available space text color：<code>NSColor.pieChartAvailableSpaceTextColor</code>。  </li></ul></li></ol><h1 id="答案：绘制图例"><a href="#答案：绘制图例" class="headerlink" title="答案：绘制图例"></a>答案：绘制图例</h1><p>把这些代码添加到 <code>drawPieChart()</code> 方法中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> usedMidAngle = endAngle / <span class="number">2.0</span></span><br><span class="line"><span class="keyword">let</span> availableMidAngle = (<span class="number">360.0</span> - endAngle) / <span class="number">2.0</span></span><br><span class="line"><span class="keyword">let</span> halfRadius = radius / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> usedSpaceText = bytesFormatter.string(fromByteCount: fileDistribution.capacity)</span><br><span class="line"><span class="keyword">let</span> usedSpaceTextAttributes = [</span><br><span class="line">  <span class="type">NSFontAttributeName</span>: <span class="type">NSFont</span>.pieChartLegendFont,</span><br><span class="line">  <span class="type">NSForegroundColorAttributeName</span>: <span class="type">NSColor</span>.pieChartUsedSpaceTextColor]</span><br><span class="line"><span class="keyword">let</span> usedSpaceTextSize = usedSpaceText.size(withAttributes: usedSpaceTextAttributes)</span><br><span class="line"><span class="keyword">let</span> xPos = rect.midX + <span class="type">CGFloat</span>(cos(usedMidAngle.radians)) *</span><br><span class="line">  halfRadius - (usedSpaceTextSize.width / <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> yPos = rect.midY + <span class="type">CGFloat</span>(sin(usedMidAngle.radians)) *</span><br><span class="line">  halfRadius - (usedSpaceTextSize.height / <span class="number">2.0</span>)</span><br><span class="line">usedSpaceText.draw(at: <span class="type">CGPoint</span>(x: xPos, y: yPos),</span><br><span class="line">                   withAttributes: usedSpaceTextAttributes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> availableSpaceText = bytesFormatter.string(fromByteCount: fileDistribution.available)</span><br><span class="line"><span class="keyword">let</span> availableSpaceTextAttributes = [</span><br><span class="line">  <span class="type">NSFontAttributeName</span>: <span class="type">NSFont</span>.pieChartLegendFont,</span><br><span class="line">  <span class="type">NSForegroundColorAttributeName</span>: <span class="type">NSColor</span>.pieChartAvailableSpaceTextColor]</span><br><span class="line"><span class="keyword">let</span> availableSpaceTextSize = availableSpaceText.size(withAttributes: availableSpaceTextAttributes)</span><br><span class="line"><span class="keyword">let</span> availableXPos = rect.midX + cos(-availableMidAngle.radians) *</span><br><span class="line">  halfRadius - (availableSpaceTextSize.width / <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> availableYPos = rect.midY + sin(-availableMidAngle.radians) *</span><br><span class="line">  halfRadius - (availableSpaceTextSize.height / <span class="number">2.0</span>)</span><br><span class="line">availableSpaceText.draw(at: <span class="type">CGPoint</span>(x: availableXPos, y: availableYPos),</span><br><span class="line">                        withAttributes: availableSpaceTextAttributes)</span><br></pre></td></tr></table></figure><p>代码含义：</p><ol><li>计算两个区域的角度；</li><li>创建已用空间的文本的属性，并计算其 <em>x</em> 和 <em>y</em>，然后绘制它；</li><li>创建总空间的文本的属性，并计算其 <em>x</em> 和 <em>y</em>，然后绘制它；</li></ol><p>现在，编译并运行你的 app，好好欣赏一下你的杰出作品：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-2b67c2e23ffc4526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>恭喜你！你使用 Core Graphics 和 Cocoa Drawing 创建了一个美丽的 app！</p><h1 id="接下来该做啥？"><a href="#接下来该做啥？" class="headerlink" title="接下来该做啥？"></a>接下来该做啥？</h1><p>你可以<a href="https://koenig-media.raywenderlich.com/uploads/2016/06/DiskInfo-Final.zip" target="_blank" rel="noopener">点击这里</a>下载完整的工程文件。</p><p>这个 macOS Core Graphics 教程覆盖了 macOS 中用于绘制自定义视图的不同框架的基本知识：</p><ul><li>如何使用 Core Graphics 和 Cocoa Drawing 创建和绘制路径；</li><li>如何剪切一个区域；</li><li>如何绘制文本串；</li><li>如何绘制渐变。</li></ul><p>之后的日子里，当你需要创建一些整洁、优美的用户界面的时候，你应该能自信地拿出 Core Graphics 和 Cocoa Drawing 挥洒创意了。</p><p>如果你还想继续深入，可以参考这些资源：</p><ul><li>Apple 的 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Introduction to Cocoa Drawing Guide</a></li><li>Apple 的 <a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html" target="_blank" rel="noopener">Quartz 2D Programming Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.raywenderlich.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raywenderlich.com&lt;/a&gt; 的 &lt;a href=&quot;https://www.r
      
    
    </summary>
    
    
      <category term="翻译" scheme="https://sr2k.top/blog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ray Wenderlich" scheme="https://sr2k.top/blog/tags/Ray-Wenderlich/"/>
    
      <category term="macOS" scheme="https://sr2k.top/blog/tags/macOS/"/>
    
      <category term="Swift" scheme="https://sr2k.top/blog/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】NSCollectionView 入门教程</title>
    <link href="https://sr2k.top/blog/2017/09/24/%E8%AF%91-NSCollectionView%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://sr2k.top/blog/2017/09/24/译-NSCollectionView入门教程/</id>
    <published>2017-09-24T14:34:11.000Z</published>
    <updated>2019-07-19T05:03:34.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://www.raywenderlich.com/" target="_blank" rel="noopener">raywenderlich.com</a> 的 <a href="https://www.raywenderlich.com/145978/nscollectionview-tutorial" target="_blank" rel="noopener">NSCollectionView Tutorial</a>，已咨询对方网站，可至多翻译 10 篇文章。<br>希望各位有英语阅读能力的话，还是<del>先打赏</del>然后去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。<br>综上，此翻译版本仅供参考，<strong>谢绝转载</strong>。</p></blockquote><p><strong>更新信息：</strong> 此 NSCollectionView 教程已由 Gabriel Miro 更新至 Xcode 8 和 Swift 3.</p><p>Collection View 是现实一系列相同类型数据的最佳方式。Mac 中自带的 Finder 和 Photos 就是使用了它：通过一个 Collection View 来展示所有的文件和图片。</p><p><code>NSCollectionView</code> 最早在 OS X 10.5 被推出，它可以非常方便地布局一组具有相同大小的 item，并把它们展示在一个可以滑动的 Scroll View 中。</p><p>在 OS X 10.11 El Capitan 中，参照 iOS 上的 <code>UICollectionView</code>，<code>NSCollectionView</code> 被全面进行了升级。</p><p>macOS 10.12 Sierra 则给予了它「收起分区」（就像 Finder 里那样）和「固定标题」两项新功能，使得它和 iOS 的差距进一步减小了。</p><p>在这个 NSCollectionView 的入门教程中，你将会创造一个叫 <strong>SlideMagic</strong> 的 app，它是一个只属于你的网格状的图片浏览 app。</p><p>这个教程假定你已经基本了解过了 macOS app 的开发，如果你还不曾了解过，raywenderlich.com 上提供了很多很棒的 <a href="http://www.raywenderlich.com/category/macos" target="_blank" rel="noopener">macOS 开发教程</a>，你可以先去看看那些。</p><blockquote><p>当然还有<a href="http://www.jianshu.com/p/a3f16178a213" target="_blank" rel="noopener">我自己翻的《零基础 macOS 应用开发教程》</a>系列</p></blockquote><h1 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h1><p>你将会编写的 <strong>SlidesMagic</strong> app 是一个简单的图片浏览器，它很酷，但是，可别因为它太酷了而一不小心在把玩的时候把自己 Mac 上的照片删了哦😛～</p><p>这个 app 会从获取一个文件夹里的所有图片，然后用一个极其优雅的 Collection View 来把它们显示出来。完成了的 app 长这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-6db9bff0a7b673ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p><a href="https://koenig-media.raywenderlich.com/uploads/2016/10/SlidesMagic8V2-Starter.zip" target="_blank" rel="noopener">下载这个项目的起步代码</a>，编译并运行:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-213e3900e938a253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>此时，这个 app 看起来只是一个空荡荡的窗口，但这些起步代码包含了一些「隐藏功能」，这是后面使它成为一个图片浏览器的基础。</p><p><strong>SlidesMagic</strong> 启动的时候，会自动加载系统中 <strong>Desktop Pictures</strong> 目录下的所有图片，在 Xcode 的控制台输出中，我们可以看到这些文件的名字。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-283174b11475b7cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>控制台中输出的列表表明，起步代码中 Model 的加载逻辑代码已经可以正常工作了，你可以在这个 app 的 <strong>File</strong> → <strong>Open Another Folder…</strong> 菜单中打开另一个目录。</p><h2 id="起步代码"><a href="#起步代码" class="headerlink" title="起步代码"></a>起步代码</h2><p>起步代码提供了一些与 Collection Views 无直接关联的代码。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-ef6b2cfd384dd183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><ul><li><strong>ImageFile.swift</strong>: 用于描述一个图片文件</li><li><strong>ImageDirectoryLoader.swift</strong>: 用来把图片从硬盘中加载出来的 Helper 类</li></ul><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>这个 app 拥有两个主要的 Controller：</p><ul><li><strong>WindowController.swift</strong>：<ul><li><code>windowDidLoad()</code>：在左半边的屏幕上设置主窗口的大小；</li><li><code>openAnotherFolder(_:)</code>：提供一个标准的「打开」对话框来供用户选择文件夹；</li></ul></li><li><strong>ViewController.swift</strong>：<ul><li><code>viewDidLoad()</code> 打开 Desktop Pictures 目录作为默认目录。</li></ul></li></ul><h1 id="Collection-View-幕后探秘"><a href="#Collection-View-幕后探秘" class="headerlink" title="Collection View 幕后探秘"></a>Collection View 幕后探秘</h1><p><code>NSCollectionView</code> 是今天的主角，它将会在几个关键的组成部分的帮助下，显示许多 item。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><code>NSCollectionViewLayout</code>：明确了 Collection View 的布局方式，它是一个抽象的类，所有用来表示 CollectionView 布局的实类都继承自它。</p><p><code>NSCollectionViewFlowLayout</code>：提供了一个灵活的网格状的布局。对于绝大多数 app，这种布局方式都适用。</p><p><code>NSCollectionViewGridLayout</code>：为了兼容 OS X 10.11 和以前的版本所保留的布局方式，对于新创建的 app 不推荐使用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-cc118c34a1553151.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>Section 和 <code>IndexPath</code></strong>：前者允许你把 item 分成若干个 section（分区），每个 section 包含了一组有序的 item。每个 item 都和一个索引相关联，这个索引是一个由一对整数（section，item）构成的 <code>IndexPath</code> 实例。默认情况下，当你不需要给 item 分区时，这个 Collection View 仍然会拥有一个 section。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-bd89941692bf5bba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="Collection-View-Item"><a href="#Collection-View-Item" class="headerlink" title="Collection View Item"></a>Collection View Item</h3><p>就像其他许多 <strong>Cocoa</strong> 框架一样，Collection View 中的 item 也遵守着 <strong>MVC</strong> 设计模式。</p><p><strong>Model 和 View</strong>：这个 item 的内容来自 Model 的数据对象。每个单独的对象都通过在 Collection View 中创建自己的 View 来把自己显示出来。这些 View 的结构由一个单独的 nib 文件（文件扩展名是 .xib）来定义。</p><p><strong>Controller</strong>：上面提到的 nib 文件是一个由 <strong>NSCollectionViewItem</strong> 管理的 <code>NSViewController</code> 的子类。它负责与 Model 对象进行通信并控制 Collection View 的显示。通常情况下，你会编写一个 <code>NSCollectionViewItem</code> 的子类。当你需要不同类型的 item 的时候，你需要为每个分支定义一个不同的子类，并创建一个 nib。</p><h2 id="额外的-View"><a href="#额外的-View" class="headerlink" title="额外的 View"></a>额外的 View</h2><p>要在 Collection View 中显示不同于普通 item 额外的信息，你需要额外的 item。</p><p>最直观的例子就是分区的标题和脚注。</p><h2 id="Collection-View-的数据源和代理（Data-Source-and-Delegates）"><a href="#Collection-View-的数据源和代理（Data-Source-and-Delegates）" class="headerlink" title="Collection View 的数据源和代理（Data Source and Delegates）"></a>Collection View 的数据源和代理（Data Source and Delegates）</h2><ul><li><code>NSCollectionViewDataSource</code>：用 item 和额外的 item 来填充 Collection View。</li><li><code>NSCollectionViewDelegate</code>：处理拖放相关的事件，以及选中状态和高亮。</li><li><code>NSCollectionViewDelegateFlowLayout</code>：允许你自定义你的网格视图。</li></ul><blockquote><p><strong>注意</strong>：填充一个 Collection View 的方法有二：数据源和 Cocoa 绑定。这个教程将会使用数据源。</p></blockquote><h1 id="创建-Collection-View"><a href="#创建-Collection-View" class="headerlink" title="创建 Collection View"></a>创建 Collection View</h1><p>打开 <strong>Main.storyboard</strong>。前往<strong>控件库</strong>，向 <strong>View Controller Scene</strong> 中拖动一个 <strong>Collection View</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-a96ea28b4e1256e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p><strong>注意</strong>：你或许注意到了，<strong>Interface Builder</strong> 为我们添加了三个 View，而不是一个。这是因为 <strong>Collection View</strong> 是嵌入在一个 <strong>Scroll View</strong> 中的，而后者又自带一个 <strong>Clip View</strong> 子视图。这仨视图各不相同，因此当本教程需要你选择 <strong>Collection View</strong> 的时候，切记不要错选了 <strong>Scroll View</strong> 或 <strong>Clip View</strong>。</p></blockquote><p>调整 <strong>Bordered Scroll View</strong> 的大小，使它填满它的父视图的所有空间。然后选择 Xcode 菜单栏上的 <strong>Editor</strong> → <strong>Resolve Auto Layout Issues</strong> → <strong>Add Missing Constraints</strong> 来添加 <strong>Auto Layout</strong> 约束条件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-6fe7039d2d1a1b21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>你需要在 <strong>ViewController</strong> 中添加一个 Outlet 来访问界面上的 Collection View。打开 <strong>ViewController.swift</strong>，在 <code>ViewController</code> 类的定义中添加以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">NSCollectionView!</span></span><br></pre></td></tr></table></figure><p>打开 <strong>Main.storyboard</strong>，并选择 <strong>View Controller Scene</strong> 中的 <strong>View Controller</strong>。</p><p>打开<strong>连接检查器</strong>，在 <strong>Outlets</strong> 部分中找到 <strong>collectionView</strong>，<strong>拖动</strong>它旁边的小圆圈到画布中的 Collection View 上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-705deb60d6892d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="调整-Collection-View-的布局"><a href="#调整-Collection-View-的布局" class="headerlink" title="调整 Collection View 的布局"></a>调整 Collection View 的布局</h2><p>你现在有两种选择：在 <strong>Interface Builder</strong> 中设置好主要的布局属性，或者在代码中手动编写。</p><p>在 SlidesMagic 这个项目中，我们选择手动编写代码。</p><p>打开 <strong>ViewController.swift</strong>，把这些方法添加到 <code>ViewController</code> 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">configureCollectionView</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> flowLayout = <span class="type">NSCollectionViewFlowLayout</span>()</span><br><span class="line">  flowLayout.itemSize = <span class="type">NSSize</span>(width: <span class="number">160.0</span>, height: <span class="number">140.0</span>)</span><br><span class="line">  flowLayout.sectionInset = <span class="type">EdgeInsets</span>(top: <span class="number">10.0</span>, <span class="keyword">left</span>: <span class="number">20.0</span>, bottom: <span class="number">10.0</span>, <span class="keyword">right</span>: <span class="number">20.0</span>)</span><br><span class="line">  flowLayout.minimumInteritemSpacing = <span class="number">20.0</span></span><br><span class="line">  flowLayout.minimumLineSpacing = <span class="number">20.0</span></span><br><span class="line">  collectionView.collectionViewLayout = flowLayout</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  view.wantsLayer = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  collectionView.layer?.backgroundColor = <span class="type">NSColor</span>.black.cgColor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码的作用是：</p><ol><li>创建一个 <code>NSCollectionViewFlowLayout</code>，配置它的基本属性，并设置 <code>NSCollectionView</code> 的 <code>collectionViewLayout</code>；</li><li>一般情况下，<code>NSCollectionView</code> 是基于层的，所以你需要把它的父视图的 <code>wantsLayer</code> 设置为 <code>true</code>；</li><li>把 Collection View 的背景颜色设置为黑色。</li></ol><p>你需要在试图加载完成时调用这个方法，所以在 <code>viewDidLoad()</code> 方法的最后插入：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configureCollectionView()</span><br></pre></td></tr></table></figure><p>编译并运行：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-b9359a0cde32671d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>此时，你的 Collection View 已经拥有了一个黑色的背景，并配置好了布局。</p><h1 id="创建一个-Collection-View-Item"><a href="#创建一个-Collection-View-Item" class="headerlink" title="创建一个 Collection View Item"></a>创建一个 Collection View Item</h1><p>先在你需要创建一个 <code>NSCollectionViewItem</code> 的子类并把 Model 里的数据们显示出来。</p><p>点击 Xcode 菜单栏上的 <strong>File</strong> → <strong>New</strong> → <strong>File…</strong>，选择 <strong>macOS</strong> → <strong>Source</strong> → <strong>Cocoa Class</strong> 并点击 <strong>Next</strong>。</p><p>把 <strong>Class</strong> 填写 <strong>CollectionViewItem</strong>，<strong>Subclass of</strong> 填写 <code>NSCollectionViewItem</code>，并勾选 <strong>Also create XIB for user interface</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-7edf2b2db9985f31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>点击 <strong>Next</strong>，然后在对话框中的 <strong>Group</strong> 中选择 <strong>Controllers</strong>，并点击 <strong>Create</strong>。</p><p>打开 <strong>CollectionViewItem.swift</strong>，把里边的内容全部替换为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionViewItem</span>: <span class="title">NSCollectionViewItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> imageFile: <span class="type">ImageFile?</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> isViewLoaded <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> imageFile = imageFile &#123;</span><br><span class="line">        imageView?.image = imageFile.thumbnail</span><br><span class="line">        textField?.stringValue = imageFile.fileName</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        imageView?.image = <span class="literal">nil</span></span><br><span class="line">        textField?.stringValue = <span class="string">""</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    view.wantsLayer = <span class="literal">true</span></span><br><span class="line">    view.layer?.backgroundColor = <span class="type">NSColor</span>.lightGray.cgColor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码的功能是：</p><ol><li>定义了 <code>imageFile</code> 属性，用来访问需要展示的 Model 对象。当你为 <code>imageFile</code> 属性赋值时，它的 <code>didSet</code> 属性观察器会设置这个 item 的 Image 和 Label；</li><li>改变此 item 的 View 的背景颜色。</li></ol><h1 id="向-View-中添加-Control"><a href="#向-View-中添加-Control" class="headerlink" title="向 View 中添加 Control"></a>向 View 中添加 Control</h1><p>你在 <strong>CollectionViewItem.swift</strong> 时勾选了「Also create a XIB（同时创建一个 XIB）」，为了更清楚地整理文件，把 <strong>CollectionViewItem.xib</strong> 拖动到 <strong>Main.storyboard</strong> 下方的 <strong>Resources</strong> 分组中。</p><p>Nib 文件中的 <strong>View</strong> 就是每个 item 所显示出来的根视图，你需要添加一个 Image View 来显示图片，以及一个 Label 来显示文件名。</p><p>打开 <strong>CollectionViewItem.xib</strong>，添加一个 <code>NSImageView</code>：</p><ol><li>从<strong>控件库</strong>中拖动一个 <strong>Image View</strong> 到画布上的 <strong>View</strong> 中；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-da794ce70a3f8239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>在 <strong>Auto Layout</strong> 工具栏中点击 <strong>Pin</strong> 按钮来设置它的约束条件；</li><li>设置它的 <strong>top</strong>、<strong>leading</strong> 和 <strong>trailing</strong> 约束为 0，<strong>bottom</strong> 为 30。点击 <strong>Update Frames: Items of New Constraints</strong> 然后点击 <strong>Add 4 Constraints</strong>。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-2cebd9643e49bae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol><p>再来添加一个 Label：</p><ol><li>从<strong>控件库</strong>中拖动一个 <strong>Label</strong> 到画布上的 <strong>Image View</strong> 的下方；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-8662823f27453bff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>在 <strong>Auto Layout</strong> 工具栏中点击 <strong>Pin</strong> 按钮，设置它的 <strong>top</strong>、<strong>bottom</strong>、<strong>leading</strong> 和 <strong>trailing</strong> 约束都为 0。点击 <strong>Update Frames: Items of New Constraints</strong> 然后点击 <strong>Add 4 Constraints</strong>。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-3589ffea0a0ecce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol><p>选中 <strong>Label</strong>，在<strong>属性检查器</strong>中设置如下属性：</p><ol><li>设置 <strong>Alignment</strong> 为 <strong>center</strong></li><li>设置 <strong>Text Color</strong> 为 <strong>white</strong></li><li>设置 <strong>Line Break</strong> 为 <strong>Truncate Tail</strong><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-dd778a91d505a2e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol><h1 id="向-Nib-中添加-CollectionViewItem-并连接-Outlets"><a href="#向-Nib-中添加-CollectionViewItem-并连接-Outlets" class="headerlink" title="向 Nib 中添加 CollectionViewItem 并连接 Outlets"></a>向 Nib 中添加 CollectionViewItem 并连接 Outlets</h1><p>尽管 Nib 文件的 <strong>File’s Owner</strong> 现在是 <code>CollectionViewItem</code>，它还只是一个占位符。当 Nib 文件被实例化时，它还会需要一个「真正的」<code>NSCollectionViewItem</code> 的实例。</p><p>从<strong>控件库</strong>中拖动一个 <strong>Collection View Item</strong> 到<strong>文档大纲</strong>中，选中它，在 <strong>身份检查器</strong>中把它的 <strong>Class</strong> 设置为 <code>CollectionViewItem</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-865306100dff432a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在 xib 中，你需要把 View 的层次关系连接到 <strong>CollectionViewItem</strong> 的 Outlet 中，在 <strong>CollectionViewItem.xib</strong> 中：</p><ol><li>选中 <strong>Collection View Item</strong> 并前往 <strong>Connections Inspector</strong>；</li><li>把 <code>view</code> 的 outlet 拖动到<strong>文档大纲</strong>中的 <strong>View</strong> 上；</li><li>用同样的方法，把 <code>imageView</code> 和 <code>textField</code> 的 outlet 连接到<strong>文档大纲</strong>中的 <strong>Image View</strong> 和 <strong>Label</strong> 中。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-111e8db6987f691b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol><h1 id="填充-Collection-View"><a href="#填充-Collection-View" class="headerlink" title="填充 Collection View"></a>填充 Collection View</h1><p>你需要实现 Collection View 的数据源协议，说人话就是：</p><ol><li>Collection 中有几个分区？</li><li>每个分区分别有多少个 item？</li><li>某个索引路径（Index Path）对应的是哪个 Item？</li></ol><p>打开 <strong>ViewController.swift</strong> 并在文件的末尾添加这些扩展代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> : <span class="title">NSCollectionViewDataSource</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> collectionView: NSCollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> imageDirectoryLoader.numberOfSections</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: NSCollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> imageDirectoryLoader.numberOfItemsInSection(section)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> itemForRepresentedObjectAtcollectionView: NSCollectionView, itemForRepresentedObjectAt indexPath: IndexPath)</span></span> -&gt; <span class="type">NSCollectionViewItem</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">let</span> item = collectionView.makeItem(withIdentifier: <span class="string">"CollectionViewItem"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> collectionViewItem = item <span class="keyword">as</span>? <span class="type">CollectionViewItem</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> item&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">let</span> imageFile = imageDirectoryLoader.imageFileForIndexPath(indexPath)</span><br><span class="line">    collectionViewItem.imageFile = imageFile</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果你的 app 不需要用到分区，那么你可以删除这个方法，因为一个分区就够了；</li><li>这是两个 <code>NSCollectionViewDataSource</code> 协议必须实现的方法之一，在这个方法中你需要返回某个分区容纳的 item 的数量；</li><li>另一个必须实现的方法，这个方法会针对某个 <code>indexPath</code> 返回一个 item；</li><li>这个方法会从 nib 中实例化一个 item，这个 item 的名字是 <code>identifier</code> 参数，它会根据所需要的 item 的类型来试图重复使用一个 item，如果没有 item 可供重复使用，它会新建一个 item；</li><li>根据 <code>IndexPath</code> 获取 Model 对象，设置 Image 和 Label 的内容。</li></ol><blockquote><p><strong>注意</strong>: Collection View 具有一项能力：循环使用已经生成了的 Item，以此来减轻数据源过大时的内存压力。从界面上移出去的 item 就是被重复使用的 item。</p></blockquote><h1 id="设置数据源"><a href="#设置数据源" class="headerlink" title="设置数据源"></a>设置数据源</h1><p>接下来我发需要定义数据源：</p><p>打开 <strong>Main.storyboard</strong>，选中 Collection View。</p><p>打开<strong>连接检查器</strong>，在 <strong>Outlets</strong> 部分中找到 <strong>dataSource</strong>，<strong>拖动</strong>它旁边的小圆圈到<strong>文档大纲</strong>里的 <strong>View Controller</strong> 上。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-7fb81eeed145f612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>编译并运行，你的 Collection View 现在应该能显示 <strong>Desktop Pictures</strong> 目录中的图片了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-1422559e2aea84ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>哈哈哈，折腾了半天都是值得的✌️～</p><h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><p>如果你还看不见任何图片，你可能遗漏了一些小细节：</p><ol><li>你在<strong>连接检查器</strong>中正确地设置了所有的连接吗？</li><li>你设置 <code>dataSource</code> 的 Outlet 了吗？</li><li>你在<strong>身份检查器</strong>中应用正确的自定义类了吗？</li><li>你添加顶层的 <code>NSCollectionViewItem</code>，并把它的类设置为 <code>CollectionViewItem</code> 了吗？</li><li><code>makeItemWithIdentifier</code> 中的 <code>identifier</code> 参数的值和 nib 的名字一样吗？</li></ol><h1 id="Model-发生改变时重新加载-Item-们"><a href="#Model-发生改变时重新加载-Item-们" class="headerlink" title="Model 发生改变时重新加载 Item 们"></a>Model 发生改变时重新加载 Item 们</h1><p>要显示另一个目录中的图片，你可以在 app 的菜单栏上点击 <strong>File</strong> → <strong>Open Another Folder…</strong>，然后选择一个存有 <strong>JPG</strong> 或 <strong>PNG</strong> 格式的图片的目录。</p><p>但时此时窗口中的东西似乎什么变化都没有，还是显示着 <strong>Desktop Pictures</strong> 目录中的图片。尽管 Xcode 里的控制台中已经打印出了新目录里的文件名称。</p><p>你需要调用 Collection View 的 <code>reloadData()</code> 方法来刷新它的 item。</p><p>打开 <strong>ViewController.swift</strong> 并把这些代码添加到 <code>loadDataForNewFolderWithUrl(_:)</code> 方法中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collectionView.reloadData()</span><br></pre></td></tr></table></figure><p>编译并运行，现在你应该能看到窗口中已经能显示正确的照片了。</p><h1 id="添加分区"><a href="#添加分区" class="headerlink" title="添加分区"></a>添加分区</h1><p>SlidesMagic app 现在已经可以做一些很神奇的事儿了，但我们要更进一步 —— 为 Collection View 加入分区。</p><p>首先，你需要在主视图的最底部加入一个复选框，来允许你切换是否启用分组。</p><p>打开 <strong>Main.storyboard</strong>，然后在<strong>文档大纲</strong>中选中 Scroll View 的约束条件，在<strong>尺寸检查器</strong>中吧它的 <strong>Constant</strong> 修改为 30.</p><p>这会把 Collection View 抬高一些些，腾出地方来放置复选框。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-b811bef73ed6329e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在，从<strong>控件库</strong>中拖动一个 <strong>Check Box Button</strong>到画布中 Collection View 下方的空间里，选中它，在<strong>属性检查器</strong>中把它的 <strong>Title</strong> 设置为 <strong>Show Sections</strong>，然后把 <strong>State</strong> 设置为 <strong>Off</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-14190a9187e4912b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>接下来，点击 <strong>Pin</strong> 按钮更新它的 <strong>Auto Layout</strong> 约束条件：<strong>Top</strong> 设置为 8，<strong>Leading</strong> 设置为 20。然后点击 <strong>Update Frames: Items of New Constraints</strong> 和 <strong>Add 2 Constraints</strong></p><p>编译并运行，现在 app 的底部看起来应该是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-a2538c0d623bc2e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当你点击这个复选框的时候，你的 app 需要改变 Collection View 的外观。</p><p>打开 <strong>ViewController.swift</strong> 在 <code>ViewController</code> 类的最后添加这些代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showHideSections</span><span class="params">(sender: NSButton)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> show = sender.state</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  imageDirectoryLoader.singleSectionMode = (show == <span class="type">NSOffState</span>)</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  imageDirectoryLoader.setupDataForUrls(<span class="literal">nil</span>)</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  collectionView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码会：</p><ol><li>根据复选框的状态切换单一分组/多个分组；</li><li>根据当前选择的模式来调整 Model，此时传递的 <code>nil</code> 参数表示跳过图像加载 —— 毕竟图片还是那些图片，只是布局发生了改变；</li><li>Model 发生了改变，所以需要刷新数据。</li></ol><p>如果你好奇图片是按照是按照什么规则进行分组的，在 <code>ImageDirectoryLoader</code> 中找到 <code>sectionLengthArray</code>，这个数组里的数字设置了各个分组的里最多可以容纳多少个 item。这个数组是随机生成的，只是用来用作演示。</p><p>现在，打开 <strong>Main.storyboard</strong>。在<strong>文档大纲</strong>中<strong>按住 Control⌃ 键的同时</strong>把 <strong>Show Sections</strong> 拖动到 <strong>View Controller</strong> 上。在弹出的黑色窗口中点击 <strong>showHideSections:</strong>。你可以在<strong>连接检查器</strong>里查看你是否连接成功了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-6656f84c5d2c2726.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>编译并运行，勾选 <strong>Show Sections</strong> 来查看布局的变化。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-15e1753a88dfc587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>为了更好地区分各个分区，打开 <strong>ViewController.swift</strong>，编辑 <code>configureCollectionView()</code> 方法里的 <code>sectionInset</code> 属性。</p><p>把这一行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowLayout.sectionInset = <span class="type">EdgeInsets</span>(top: <span class="number">10.0</span>, <span class="keyword">left</span>: <span class="number">20.0</span>, bottom: <span class="number">10.0</span>, <span class="keyword">right</span>: <span class="number">20.0</span>)</span><br></pre></td></tr></table></figure><p>替换成这个：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowLayout.sectionInset = <span class="type">EdgeInsets</span>(top: <span class="number">30.0</span>, <span class="keyword">left</span>: <span class="number">20.0</span>, bottom: <span class="number">30.0</span>, <span class="keyword">right</span>: <span class="number">20.0</span>)</span><br></pre></td></tr></table></figure><p>编译并运行，勾选 <strong>Show Sections</strong>，可以看到各个分区之间已经有了分隔。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-fb004f710558b192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="添加分区标题"><a href="#添加分区标题" class="headerlink" title="添加分区标题"></a>添加分区标题</h1><p>另一种区分各个分区边界的方法是为每个分区添加一个标题或脚注。</p><p>你需要一个自定义的 <code>NSView</code> 类，并实现相应的数据源方法来为 Collection View 添加一个标题</p><p>要创建一个标题，在 Xcode 的菜单栏点击 <strong>File</strong> → <strong>New</strong> → <strong>File…</strong>。选择 <strong>macOS</strong> → <strong>User Interface</strong> → <strong>View</strong>，并点击 <strong>Next</strong>。</p><p>文件名输入 <strong>HeaderView.xib</strong>，<strong>Group</strong> 选择 <strong>Resources</strong>。</p><p>点击 <strong>Create</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-d7f8fd4c5b749b7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>打开 <strong>HeaderView.xib</strong> 并选中 <strong>Custom View</strong>。在<strong>尺寸检查器</strong>中把 <strong>Width</strong> 设置为 500，<strong>Height</strong> 设置为 40。</p><p>从 <strong>Object Library</strong> 拖动一个 Label 到 <strong>Custom View</strong> 的左半边。打开<strong>属性检查器</strong>，设置它的 <strong>Title</strong> 为 <strong>Section Number</strong>，设置 <strong>Font Size</strong> 为 <strong>16</strong>。</p><p>再拖动一个 Label 到 <strong>Custom View</strong> 的右半边。设置它的 <strong>Title</strong> 为 <strong>Image Count</strong>，设置 <strong>Alignment</strong> 为 <strong>Right</strong>。</p><p>选中 <strong>Section Number</strong> Label，点击 <strong>Pin</strong> 按钮，设置它的 <strong>Top</strong> 约束为 12，<strong>Leading</strong> 约束为 20。点击 <strong>Update Frames: Items of New Constraints</strong> 和 <strong>Add 2 Constraints</strong>。</p><p>接下来，设置 <strong>Image Count</strong> Label 的 <strong>Top</strong> 约束为 11，<strong>Trailing</strong> 约束为 20，别忘了点击 <strong>Update Frames: Items of New Constraints</strong> 和 <strong>Add 2 Constraints</strong>。</p><p>现在我们的标题应该看起来像这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-219024e618e0e957.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在我们的标题 UI 已经准备好了，我们还需要为它创建一个子类。</p><p>在 Xcode 的菜单栏点击 <strong>File</strong> → <strong>New</strong> → <strong>File…</strong>。选择 <strong>macOS</strong> → <strong>Source</strong> → <strong>Cocoa Class</strong>，并点击 <strong>Next</strong>。把它的类名设置为 <code>HeaderView</code>，并让它继承自 <code>NSView</code>，点击 <strong>Next</strong>，并在 <strong>Group</strong> 中选择 <strong>Views</strong>。点击 <strong>Create</strong>。</p><p>打开 <strong>HeaderView.swift</strong> 然后把里边的所有内容替换为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> sectionTitle: <span class="type">NSTextField!</span></span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageCount: <span class="type">NSTextField!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> dirtyRect: NSRect)</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.draw(dirtyRect)</span><br><span class="line">  <span class="type">NSColor</span>(calibratedWhite: <span class="number">0.8</span> , alpha: <span class="number">0.8</span>).<span class="keyword">set</span>()</span><br><span class="line">  <span class="type">NSRectFillUsingOperation</span>(dirtyRect, <span class="type">NSCompositingOperation</span>.sourceOver)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码做了这些事儿：</p><ol><li>设置你需要用来连接 nib 元素的 outlet；</li><li>绘制一个灰色的背景。</li></ol><p>要把 outlet 连接至 Label，打开 <strong>HeaderView.xib</strong> 并选中 <strong>Custom View</strong>。在 <strong>Identity Inspector</strong> 中把 <strong>Class</strong> 设置为 <strong>HeaderView</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-7293eacf2ad306dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在<strong>文档大纲</strong>视图中，按住 <strong>Control⌃ 键</strong>的同时点击 <strong>Header View</strong>。在弹出的黑色窗口中，拖动 <strong>imageCount</strong> 到 <strong>Images Count</strong> 上来连接 outlet。 </p><p>对第二个 Label 进行同样的操作，拖动 <strong>sectionTitle</strong> 到画布中的 <strong>Section Number</strong> Label 上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-68e5abf430d026b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="实现数据源和代理方法"><a href="#实现数据源和代理方法" class="headerlink" title="实现数据源和代理方法"></a>实现数据源和代理方法</h2><p>你的标题已经完全准备好上战场了，你需要实现 <code>collectionView(_:viewForSupplementaryElementOfKind:at:)</code>，把这个标题视图传递给 Collection View：</p><p>打开 <strong>ViewController.swift</strong> 并把这些方法添加到 <code>NSCollectionViewDataSource</code> extension 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: NSCollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath)</span></span> -&gt; <span class="type">NSView</span> &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> view = collectionView.makeSupplementaryView(ofKind: <span class="type">NSCollectionElementKindSectionHeader</span>, withIdentifier: <span class="string">"HeaderView"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">HeaderView</span></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  view.sectionTitle.stringValue = <span class="string">"Section \(indexPath.section)"</span></span><br><span class="line">  <span class="keyword">let</span> numberOfItemsInSection = imageDirectoryLoader.numberOfItemsInSection(indexPath.section)</span><br><span class="line">  view.imageCount.stringValue = <span class="string">"\(numberOfItemsInSection) image files"</span></span><br><span class="line">  <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collection View 会在它需要数据源的时候调用这个方法，并为每个分区设置标题。这个方法做了这些：</p><ol><li>调用 <code>makeSupplementaryViewOfKind(_:withIdentifier:for:)</code> 来从 nib 文件实例化一个名字是 <code>withIdentifier</code> 的 <code>HeaderView</code> 对象；</li><li>设置各个 Label 的值。</li></ol><p>在 <strong>ViewController.swift</strong> 的最后，添加这个 <code>NSCollectionViewDelegateFlowLayout</code> 扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> : <span class="title">NSCollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: NSCollectionView, layout collectionViewLayout: NSCollectionViewLayout, referenceSizeForHeaderInSection section: Int)</span></span> -&gt; <span class="type">NSSize</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> imageDirectoryLoader.singleSectionMode ? <span class="type">NSZeroSize</span> : <span class="type">NSSize</span>(width: <span class="number">1000</span>, height: <span class="number">40</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法其实是不是必须的，但当你需要设置标题的时候就必须写上了，因为 Flow Layout（流式布局）的代理需要你提供各个分区的标题的大小。</p><p>如果没有实现这个方法，你将看不到标题，因为它们的尺寸都是 0。此外，它还会忽略你指定的宽度，而是把标题的宽度设置为 Collection View 的宽度。</p><p>在这个例子中，当 Collection View 只有一个分区的时候，这个方法返回的标题尺寸是 0，否则他会返回 40.</p><p>对于使用了 <code>NSCollectionViewDelegateFlowLayout</code> 的 Collection View，你需要把 <code>ViewController</code> 连接到 <code>NSCollectionView</code> 的 <code>delegate</code>。</p><p>打开 <strong>Main.storyboard</strong> 并选中 Collection View。打开<strong>连接检查器</strong>，在 <strong>Outlets</strong> 部分中找到 <strong>delegate</strong>。<strong>拖动</strong>他旁边的小圆点到<strong>文档大纲</strong>中的 View Controller 上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-e295106e936e58cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>编译并运行，勾选 <strong>Show Sections</strong>，可以看到一个个标题把分区区分开来：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-d7c86df41a0aac39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="固定标题"><a href="#固定标题" class="headerlink" title="固定标题"></a>固定标题</h1><p>macOS 10.12 中的 <code>NSCollectionViewFlowLayout</code> 新加入了两个属性：<code>sectionHeadersPinToVisibleBounds</code> 和 <code>sectionFootersPinToVisibleBounds</code>。</p><p>当 <code>sectionHeadersPinToVisibleBounds</code> 设置为 <code>true</code>，最上端的分区的标题将会固定在顶端，而不会移出界面以外。当你继续向下滚动时，下一个标题会把它顶走。这种效果一般被称为「sticky headers（固定标题）」或「floating headers（浮动标题）」。</p><p>把 <code>sectionFootersPinToVisibleBounds</code> 设置为 <code>true</code> 则会把脚注固定在底部。</p><p>打开 <strong>ViewController.swift</strong>，在 <code>configureCollectionView()</code> 方法的底部加入这个方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowLayout.sectionHeadersPinToVisibleBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>编译并运行，勾选 <strong>Show Sections</strong> 并向下滚动一些，你可以看到第一个区域已经有一些图片被移出屏幕了，但标题还是固定在顶部：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-93f6bc53d834485e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p><strong>注意</strong>：如果你的 app 需要支持 OS X 10.11 或更老的版本，你需要通过重写 <code>layoutAttributesForElements(in:)</code> 方法来「手动」实现固定标题。你可以查看[Advanced Collection Views in OS X Tutorial]这篇教程（我正在翻译～）。</p></blockquote><h1 id="Collection-View-的选择功能"><a href="#Collection-View-的选择功能" class="headerlink" title="Collection View 的选择功能"></a>Collection View 的选择功能</h1><p>为了显示一个 item 的被选中状态，你需要设置一个白色的边框，没有被选中的项目将不会显示这个边框。</p><p>首先，你需要让我们的 Collection View 支持选中。打开 <strong>Main.storyboard</strong>，选中 <strong>Collection View</strong> 并在<strong>属性检查器</strong>里，勾选 <strong>Selectable</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-c413394c21316342.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>勾选 <strong>Selectable</strong> 开启了选择功能，意味着你可以通过点击一个 item 来选中它。如果你点击另一个 item，将会取消选择之前的那个 item 并选中新的 item。</p><p>当你选中一个 item：</p><ol><li>它的 <code>IndexPath</code> 会被添加到 <code>NSCollectionView</code> 的 <code>selectionIndexPaths</code> 属性；</li><li>它的 <code>isSelected</code> 属性会被设置为 <code>true</code>。</li></ol><p>打开 <strong>CollectionViewItem.swift</strong>。在 <code>viewDidLoad()</code> 方法的最后追加：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 </span></span><br><span class="line">view.layer?.borderColor = <span class="type">NSColor</span>.white.cgColor </span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line">view.layer?.borderWidth = <span class="number">0.0</span></span><br></pre></td></tr></table></figure><p>这段代码：</p><ol><li>设置了一个白色的边框；</li><li>把 <code>borderWidth</code> 设置为 <code>0.0</code> 来确保边框不可见 —— 也就是没被选中。</li></ol><p>要在每次 <code>isSelected</code> 被设置时改变 <code>borderWidth</code>，我们需要把这些代码添加到 <code>CollectionViewItem</code> 类中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> isSelected: <span class="type">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">didSet</span> &#123;</span><br><span class="line">     view.layer?.borderWidth = isSelected ? <span class="number">5.0</span> : <span class="number">0.0</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>每次 <code>isSelected</code> 发生了改变，<code>didSet</code> 将会根据新的值来设置边框的宽度。</p><p>编译并运行。点击一个项目来选中它，你将会看见它周围出现了边框。哈哈哈，神奇✨！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f84ecab7bba30633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="下一步该做些啥？"><a href="#下一步该做些啥？" class="headerlink" title="下一步该做些啥？"></a>下一步该做些啥？</h1><p><a href="https://koenig-media.raywenderlich.com/uploads/2016/10/SlidesMagic8V3-Final.zip" target="_blank" rel="noopener">点击这里</a>下载最终完成了的 <strong>SlideMagic</strong>。</p><p>在这个 NSCollectionView 入门教程中，你了解了如何创建你的第一个 Collection View，了解了错综复杂的数据源 API 和如何处理分区。至此你已经学到了很多，但其实这仅仅是个开始，Collection View 还有很多功能等待你去发掘。这里有很多值得去探索的东西：</p><ul><li>通过 Cocoa 的数据绑定构建「免数据源」的 Collection View</li><li>不同类型的 Item</li><li>追加和移除 Item</li><li>自定义布局</li><li>拖放手势（Drag and drop）</li><li>动画</li><li>修改 <code>NSCollectionViewFlowLayout</code></li><li>收起某个分区（macOS 10.12 Sierra 的新功能）</li></ul><p>你可以在我们的《NSCollectionView 进阶教程》中了解更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.raywenderlich.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raywenderlich.com&lt;/a&gt; 的 &lt;a href=&quot;https://www.r
      
    
    </summary>
    
    
      <category term="翻译" scheme="https://sr2k.top/blog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ray Wenderlich" scheme="https://sr2k.top/blog/tags/Ray-Wenderlich/"/>
    
      <category term="macOS" scheme="https://sr2k.top/blog/tags/macOS/"/>
    
      <category term="Swift" scheme="https://sr2k.top/blog/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】 零基础 macOS 应用开发（三）</title>
    <link href="https://sr2k.top/blog/2017/09/23/%E8%AF%91-%E9%9B%B6%E5%9F%BA%E7%A1%80macOS%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%913/"/>
    <id>https://sr2k.top/blog/2017/09/23/译-零基础macOS应用开发3/</id>
    <published>2017-09-22T19:54:25.000Z</published>
    <updated>2019-07-19T05:03:34.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://www.raywenderlich.com/151741/macos-development-beginners-part-1" target="_blank" rel="noopener">raywenderlich.com 的 macOS 开发经典入门教程</a> ，已咨询对方网站，可至多翻译 10 篇文章。<br>希望各位有英语阅读能力的话，还是<del>先打赏然后</del>去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。<br>综上，此翻译版本仅供参考，<strong>谢绝转载</strong>。 </p></blockquote><p>欢迎回到我们的零基础 macOS 应用开发教程的最后一部分（共三部分）！</p><p>在第一部分中，你已经学会了如何安装 Xcode 和如何创建一个示例 app；在第二部分中你为一个更加复杂的 app 创建了 UI，但因为你还没有编写任何代码，所以它还不能工作。在这个部分中，你将会编写所有 Swift 代码并让你的 app 真正活起来！</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>如果你还没有完成第二部分，或你希望从一个更加纯净的情况继续学习，你可以下载<a href="https://koenig-media.raywenderlich.com/uploads/2017/01/EggTimer-Part2-3.zip" target="_blank" rel="noopener">第二部分中已经完成了 UI 布局的工程文件</a>。打开你下载的或你跟着第二部分完成的工程文件，并运行一下它，确认一下是否所有的 UI 都能正确显示，打开偏好设置窗口看看它是否能正常显示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-08b68c653acde683.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="沙盒机制"><a href="#沙盒机制" class="headerlink" title="沙盒机制"></a>沙盒机制</h1><p>在你开始编写代码之前，请花一些时间来了解一下 macOS 的沙盒机制。如果你是一个 iOS 开发者，你已经了解了这个概念，如果你不曾了解过，继续往下阅读。</p><p>一个沙盒化了的 app 拥有自己独立的存储空间，沙盒会禁止你的 app 访问另一个 app 创建的文件以及其他的许可和限制。对于 iOS app，使用沙盒是必须的，而对于 macOS app，这只是一个可选项；但如果你希望通过 Mac App Store 进行分发和销售，你的 app 必须沙盒化，由于沙盒带来的诸多限制，你的 app 可能会出现一些问题。</p><p>要为你的 app 启用沙盒，在 <strong>Project Navigator（项目导航器）</strong>中选择项目文件，也就是文件列表里最顶上的蓝色图标。在 <strong>Targets</strong> 列表中选择 <strong>EggTimer</strong>(其实 Targets 列表里也只有一个项目可以选择)，然后在上方的标签中点击 <strong>Capabilities（功能）</strong>标签，点击 <strong>App Sandbox（应用沙盒）</strong>那一栏的开关，这个视图将会展开并显示你的 app 可以申请的许多权限。这个例子中的 app 不需要任何特殊的权限，因此它们都不需要打开。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-a963c427566b4d64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="管理你的文件"><a href="#管理你的文件" class="headerlink" title="管理你的文件"></a>管理你的文件</h1><p>看一眼你的 <strong>Project Navigator（项目导航器）</strong>，所有的文件都堆在一起，缺乏组织，这个 app 不会有很多文件，但把文件整理的井井有条始终都会是个好习惯，也能帮助我们更快速地定位到你需要的文件，这一点对于大型项目尤其有用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-31a03fd62646fa8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>按住 Shift 的同时分别点击两个 View Controller 文件，把他们同时选中，右键点击并选择 <strong>New Group from selection（用所选项目创建新的分组）</strong>，给新建的分组起名为 <strong>View Controllers</strong>。</p><p>这个项目将会包含一些 Model 文件，所以右键点击 <strong>EggTimer</strong> 分组，选择 <strong>New Group<em>（新建分组）</em>，把这个分组命名为 </strong>Model**。</p><p>最后，选中 <strong>Info.plist</strong> 和 <strong>EggTimer.entitlements</strong>，把它们扔掉一个叫 <strong>Supporting Files</strong> 的文件夹里。</p><p>拖动分组和文件调整他们的顺序，直到你的项目看起来像这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-75542da7b8b457c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>这个 app 将会应用 MVC 模式：Model View Controller（模型 - 视图 - 控制器）。</p><blockquote><p>译者注：请参见 <a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC 设计模式的维基百科词条</a>，以及<a href="http://www.jianshu.com/p/add73330d106" target="_blank" rel="noopener">这篇简书文章</a>。<br>以及下文会经常出现的名词，下文就不再翻译啦～<br><strong>Model</strong>：模型<br><strong>View</strong>：视图<br><strong>Controller</strong>：控制器<br><strong>Delegate</strong> and <strong>Protocol</strong>：代理与协议</p></blockquote><p>我们要给 app 创建的第一个 Model 对象名叫 <code>EggTimer</code>。这个类将会拥有一些关于计时器的开始时间、倒计时的时长和以及过去的时间的属性。还有一个叫做 <code>Timer</code> 的对象，每过一秒它都会被激活，并更新自己的状态，并用自己的方法来开始、暂停、恢复或把 <code>EggTimer</code> 归零。</p><p><code>EggTimer</code> Model 类还会保存数据并执行动作，但它不能用来显示数据。Controller（在这个项目中就是 <code>ViewController</code>）则能与 <code>EggTimer</code>（也就是 Model）通信，它拥有一个 <code>View</code> 并用它来显示数据。</p><p>为了能和 <code>ViewController</code> 通信，<code>EggTimer</code> 使用一个代理协议（Delegate Protocol），每当某些数据发生改变时，<code>EggTimer</code> 向它的 <code>delegate</code> 发送一条消息，<code>ViewController</code> 则让自己去担任 <code>EggTimer</code> 的这个所谓的 <code>delegate</code>，所以它能接收到这条消息，并把新的数据显示在界面上。</p><h1 id="编写-EggTimer-类"><a href="#编写-EggTimer-类" class="headerlink" title="编写 EggTimer 类"></a>编写 EggTimer 类</h1><p>在<strong>项目导航器</strong>中选中 <strong>Model</strong> 分组，并点击 Xcode 菜单栏上的 <strong>File</strong> → <strong>New</strong> → <strong>File…</strong>，选择 <strong>macOS</strong> → <strong>Swift File</strong>，并点击 <strong>Next</strong>，给这个文件起名为 <strong>EggTimer.swift</strong> 并点击 <strong>Create</strong> 来创建它。</p><p>在这个文件中加入以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggTimer</span> </span>&#123; </span><br><span class="line"><span class="keyword">var</span> timer: <span class="type">Timer?</span> = <span class="literal">nil</span> </span><br><span class="line"><span class="keyword">var</span> startTime: <span class="type">Date?</span> </span><br><span class="line"><span class="keyword">var</span> duration: <span class="type">TimeInterval</span> = <span class="number">360</span> <span class="comment">// 默认的计时时间是 6 分钟</span></span><br><span class="line"><span class="keyword">var</span> elapsedTime: <span class="type">TimeInterval</span> = <span class="number">0</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 <code>EggTimer</code> 类和它的属性们就设置好了。<code>TimeInterval</code> 其实就是 <code>Double</code> 类型，但一般我们在表示秒数时都会使用它而不是 Double。</p><p>第二件事是在类中添加两个计算属性（Computed Properties），这两个属性是用来决定 <code>EggTimer</code> 属性的捷径。将以下代码写在刚刚添加的属性之后：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isStopped: <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> timer == <span class="literal">nil</span> &amp;&amp; elapsedTime == <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isPaused: <span class="type">Bool</span> &#123; </span><br><span class="line"><span class="keyword">return</span> timer == <span class="literal">nil</span> &amp;&amp; elapsedTime &gt; <span class="number">0</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>EggTimer.swift</strong> 文件 <code>EggTimer</code> 类以外的地方添加代理协议的定义 —— 我更喜欢把代理协议写在文件顶部 import 部分的后边。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">EggTimerProtocol</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeRemainingOnTimer</span><span class="params">(<span class="number">_</span> timer: EggTimer, timeRemaining: TimeInterval)</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerHasFinished</span><span class="params">(<span class="number">_</span> timer: EggTimer)</span></span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以理解为：这个协议制定了一份合同，任何宣布遵守 <code>EggTimerProtocol</code> 协议（也就是签订了这份合同）的对象都需要实现这两个方法。</p><p>现在你定义了一个协议，<code>EggTimer</code> 可以通过定义一个 <code>delegate</code>（代理）属性来履行这份协议，这个属性的类型可以是任何类型（Any）。<code>EggTimer</code> 并不知道也不关心代理的类型是什么，因为很明显既然这个代理源自 <code>EggTimerProtocol</code> 协议，它拥有这两个方法。</p><p>将这些代码属性添加到 <code>EggTimer</code> 类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">EggTimerProtocol?</span></span><br></pre></td></tr></table></figure><p>让 <code>EggTimer</code> 的 timer 对象开始运行会导致一个方法每秒钟被调用一次，继续添加以下代码来定义这个方法，<code>dynamic</code> 关键字是让 <code>Timer</code> 能发现它的关键。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">timerAction</span><span class="params">()</span></span> &#123; </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> startTime = startTime <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line">elapsedTime = -startTime.timeIntervalSinceNow </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> secondsRemaining = (duration - elapsedTime).rounded() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> secondsRemaining &lt;= <span class="number">0</span> &#123; </span><br><span class="line">resetTimer() </span><br><span class="line">delegate?.timerHasFinished(<span class="keyword">self</span>) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">delegate?.timeRemainingOnTimer(<span class="keyword">self</span>, timeRemaining: secondsRemaining) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…所以这些代码到底是在做些什么？</p><ol><li><code>startTime</code> 是个可选的 <code>Date</code>，当它是 <code>nil</code> 时，timer 将无法运行，所以这时什么都不会发生；</li><li>重新计算 <code>elapsedTime</code> 属性，<code>startTime</code> 比当前的时间还要早，所以 <strong>timeIntervalSinceNow</strong> 会产生一个负值，这个负值会使得 <code>elapsedTime</code> 成为一个正值；</li><li>计算 timer 的剩余时间，并进行取整；</li><li>如果 timer 已经结束，就把它重设，并告知 <code>delegate</code> 计时结束了；否则，告诉 <code>delegate</code> 计时器还剩多少秒。另外，由于 <code>delegate</code> 是一个可选值，所以需要用 <code>?</code> 来进行解包，也就是说，如果 <code>delegate</code> 还没有被赋值，除了那些方法不会被调用，没有别的坏事会发生。</li></ol><p>你会看到 Xcode 提示我们出现了一些错误，不过当我们完成了 <code>EggTimer</code> 类的代码之后，它们就会消失了，这是因为我们还没有添加用于开始计时、暂停计时、恢复计时和重启计时器的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTimer</span><span class="params">()</span></span> &#123; </span><br><span class="line">startTime = <span class="type">Date</span>() </span><br><span class="line">elapsedTime = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">timer = <span class="type">Timer</span>.scheduledTimer(timeInterval: <span class="number">1</span>,</span><br><span class="line"> target: <span class="keyword">self</span>, selector: #selector(timerAction), </span><br><span class="line"> userInfo: <span class="literal">nil</span>,</span><br><span class="line"> repeats: <span class="literal">true</span>) </span><br><span class="line">timerAction() </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resumeTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">startTime = <span class="type">Date</span>(timeIntervalSinceNow: -elapsedTime) </span><br><span class="line">timer = <span class="type">Timer</span>.scheduledTimer(timeInterval: <span class="number">1</span>, </span><br><span class="line"> target: <span class="keyword">self</span>, </span><br><span class="line"> selector: #selector(timerAction), </span><br><span class="line"> userInfo: <span class="literal">nil</span>, </span><br><span class="line"> repeats: <span class="literal">true</span>) </span><br><span class="line">timerAction() </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTimer</span><span class="params">()</span></span> &#123; </span><br><span class="line"><span class="comment">// really just pauses the timer </span></span><br><span class="line">timer?.invalidate() </span><br><span class="line">timer = <span class="literal">nil</span> </span><br><span class="line">timerAction() </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetTimer</span><span class="params">()</span></span> &#123; </span><br><span class="line"><span class="comment">// 停止计时器 &amp; 重设所有属性</span></span><br><span class="line">timer?.invalidate() </span><br><span class="line">timer = <span class="literal">nil</span> </span><br><span class="line">startTime = <span class="literal">nil</span> </span><br><span class="line">duration = <span class="number">360</span> </span><br><span class="line">elapsedTime = <span class="number">0</span> </span><br><span class="line">timerAction() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码是做什么的？</p><ol><li>通过调用 <code>Date()</code> 方法 <code>startTimer</code> 设置开始时间为当前时间，然后它会设置一个一直重复运行的 <code>Timer</code>；</li><li><code>resumeTimer</code> 是计时器已经暂停并需要继续时会被调用的方法，它还会根据已经过去的时间重新设置开始时间；</li><li><code>stopTimer</code> 会停止重复运行的 timer；</li><li><code>resetTimer</code> 会停止 timer，并把相关属性恢复原始设置。</li></ol><p>以上的这些方法都会调用 <code>timerAction</code>，所以一旦它们被调用，界面上显示的内容都会被更新。</p><h1 id="ViewController"><a href="#ViewController" class="headerlink" title="ViewController"></a>ViewController</h1><p>现在 <code>EggTimer</code> 对象已经业已正常运转了，我们该回到 <strong>ViewController.swift</strong> 中让数据的变化能及时反映到界面上了。</p><p><code>ViewController</code> 已经拥有了 <code>@IBOutlet</code> 属性，但现在你需要让它拥有一个类型为 <code>EggTimer</code> 的属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eggTimer = <span class="type">EggTimer</span>()</span><br></pre></td></tr></table></figure><p>将 <code>viewDidLoad</code> 方法中的注释行替换成这一行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eggTimer.delegate = <span class="keyword">self</span></span><br></pre></td></tr></table></figure><p>写完上面的代码以后会出现一个错误，因为 <code>ViewController</code> 还没有遵从 <code>EggTimerProtocol</code> 协议。当我们要让一个类遵从某个协议时，如果我们单独创建一个 Extension（扩展）来盛放协议需要的方法，你的代码将会看起来整洁许多。在 <code>ViewController</code> 类以外的地方输入以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">EggTimerProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeRemainingOnTimer</span><span class="params">(<span class="number">_</span> timer: EggTimer, timeRemaining: TimeInterval)</span></span> &#123;</span><br><span class="line">updateDisplay(<span class="keyword">for</span>: timeRemaining)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerHasFinished</span><span class="params">(<span class="number">_</span> timer: EggTimer)</span></span> &#123;</span><br><span class="line">updateDisplay(<span class="keyword">for</span>: <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们还需要为 <code>ViewController</code> 添加另一个 Extension，用来盛放关于屏幕显示的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - 显示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateDisplay</span><span class="params">(<span class="keyword">for</span> timeRemaining: TimeInterval)</span></span> &#123;</span><br><span class="line">timeLeftField.stringValue = textToDisplay(<span class="keyword">for</span>: timeRemaining)</span><br><span class="line">eggImageView.image = imageToDisplay(<span class="keyword">for</span>: timeRemaining)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">textToDisplay</span><span class="params">(<span class="keyword">for</span> timeRemaining: TimeInterval)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"><span class="keyword">if</span> timeRemaining == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Done!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> minutesRemaining = floor(timeRemaining / <span class="number">60</span>)</span><br><span class="line"><span class="keyword">let</span> secondsRemaining = timeRemaining - (minutesRemaining * <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> secondsDisplay = <span class="type">String</span>(format: <span class="string">"%02d"</span>, <span class="type">Int</span>(secondsRemaining))</span><br><span class="line"><span class="keyword">let</span> timeRemainingDisplay = <span class="string">"\(Int(minutesRemaining)):\(secondsDisplay)"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> timeRemainingDisplay</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">imageToDisplay</span><span class="params">(<span class="keyword">for</span> timeRemaining: TimeInterval)</span></span> -&gt; <span class="type">NSImage?</span> &#123;</span><br><span class="line"><span class="keyword">let</span> percentageComplete = <span class="number">100</span> - (timeRemaining / <span class="number">360</span> * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> eggTimer.isStopped &#123;</span><br><span class="line"><span class="keyword">let</span> stoppedImageName = (timeRemaining == <span class="number">0</span>) ? <span class="string">"100"</span> : <span class="string">"stopped"</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">NSImage</span>(named: stoppedImageName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> imageName: <span class="type">String</span></span><br><span class="line"><span class="keyword">switch</span> percentageComplete &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> ..&lt; <span class="number">25</span>:</span><br><span class="line">imageName = <span class="string">"0"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">25</span> ..&lt; <span class="number">50</span>:</span><br><span class="line">imageName = <span class="string">"25"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">50</span> ..&lt; <span class="number">75</span>:</span><br><span class="line">imageName = <span class="string">"50"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">75</span> ..&lt; <span class="number">100</span>:</span><br><span class="line">imageName = <span class="string">"75"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">imageName = <span class="string">"100"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="type">NSImage</span>(named: imageName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateDisplay</code> 使用一个 Private 方法来根据剩余的时间来获取文本和图像，并将它们显示在界面上的 Text Field 和 Image View 中。</p><p><code>textToDisplay</code> 把剩余的时间格式化成「分：秒」的格式。<code>imageToDisplay</code> 计算出鸡蛋有多熟的百分比，然后选择合适的图片来显示在界面上。</p><p>所以 <code>ViewController</code> 用一个 <code>EggTimer</code> 对象的方法来接收 <code>EggTimer</code> 传来的数据并显示在屏幕上，但是界面上的按钮还没有任何实质性的代码。在第二部分中，你已经为按钮设置了 <code>@IBAction</code>。</p><p>这里是这些 IBAction 的方法，你可以用它们来替代之前的 IBAction。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">startButtonClicked</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> eggTimer.isPaused &#123;</span><br><span class="line">eggTimer.resumeTimer()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">eggTimer.duration = <span class="number">360</span></span><br><span class="line">eggTimer.startTimer()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">stopButtonClicked</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">eggTimer.stopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">resetButtonClicked</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">eggTimer.resetTimer()</span><br><span class="line">updateDisplay(<span class="keyword">for</span>: <span class="number">360</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的三个 IBAction 将会调用你之前添加的 <code>EggTimer</code> 方法。</p><p>现在编译并运行你的 app，并点击 <strong>Start</strong> 按钮。你还可以用 <strong>Timer</strong> 菜单来控制这个 app，试着去用键盘快捷键来操作你的 app。</p><p>现在我们还需要完善一些功能：Stop 和 Reset 按钮始终是被禁用的，而且你只可以定 6 分钟的时。</p><p>如果你有足够的耐心，你将会看到鸡蛋的颜色随着时间渐渐改变，并在完成时显示一个「DONE！」。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-5c5c7e7bcdaab0df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="按钮和菜单"><a href="#按钮和菜单" class="headerlink" title="按钮和菜单"></a>按钮和菜单</h1><p>界面上的按钮以及菜单里的菜单项应该随着 timer 的状态自动启用或禁用。</p><p>把这个方法添加到 <code>ViewController</code> 中盛放用于显示相关方法的 Extension 扩展中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configureButtonsAndMenus</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> enableStart: <span class="type">Bool</span></span><br><span class="line"><span class="keyword">let</span> enableStop:  <span class="type">Bool</span></span><br><span class="line"><span class="keyword">let</span> enableReset: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> eggTimer.isStopped &#123;</span><br><span class="line">enableStart = <span class="literal">true</span></span><br><span class="line">enableStop  = <span class="literal">false</span></span><br><span class="line">enableReset = <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> eggTimer.isPaused &#123;</span><br><span class="line">enableStart = <span class="literal">true</span></span><br><span class="line">enableStop  = <span class="literal">false</span></span><br><span class="line">enableReset = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">enableStart = <span class="literal">false</span></span><br><span class="line">enableStop  = <span class="literal">true</span></span><br><span class="line">enableReset = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startButton.isEnabled = enableStart</span><br><span class="line">stopButton.isEnabled  = enableStop</span><br><span class="line">resetButton.isEnabled = enableReset</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> appDel = <span class="type">NSApplication</span>.shared().delegate <span class="keyword">as</span>? <span class="type">AppDelegate</span> &#123;</span><br><span class="line">appDel.enableMenus(start: enableStart, stop: enableStop, reset: enableReset)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法使用 <code>EggTimer</code> 的状态（还记得你添加到 <code>EggTimer</code> 里的计算属性吗）来计算出哪个按钮应该启用。</p><p>在第二部分中，你创立了一个 Timer menu item 作为 <code>AppDelegate</code> 的属性，所以我们应该在 <code>AppDelegate</code> 中来编辑这些代码。</p><p>切换到 <strong>AppDelegate.swift</strong>，在其中添加这个方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enableMenus</span><span class="params">(start: Bool, stop: Bool, reset: Bool)</span></span> &#123;</span><br><span class="line">startTimerMenuItem.isEnabled = start</span><br><span class="line">stopTimerMenuItem.isEnabled  = stop</span><br><span class="line">resetTimerMenuItem.isEnabled = reset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让你的你的 app 能在初次启动时自动配置按钮的启用状态，在 <code>applicationDidFinishLaunching</code> 方法中添加这些代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableMenus(start: <span class="literal">true</span>, stop: <span class="literal">false</span>, reset: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>每当用户按下了任何一个按钮或菜单项的时候，<code>EggTimer</code> 的状态会发生改变，按钮或菜单项的状态也需要随之更新。返回到 <em>ViewController.swift</em> 中并把这一行添加到三个按钮的 IBAction 方法中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configureButtonsAndMenus()</span><br></pre></td></tr></table></figure><p>再次编译并运行你的 app，你可以看到按钮们如预期地启用和禁用了。点击菜单里的菜单项试试，它们应该拥有和按钮一样的功能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-cad654f61e1616ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="偏好设置窗口"><a href="#偏好设置窗口" class="headerlink" title="偏好设置窗口"></a>偏好设置窗口</h1><p>这个 app 还有一个很重要的问题：如果你希望煮鸡蛋的时间不是 6 分钟呢？</p><p>在第二部分中，你已经设计好了一个偏好设置窗口来允许用户来选择需要的倒计时时间，这个窗口是由 <code>PrefsViewController</code> 控制的，但它还需要一个 Model 对象来处理和查询数据。</p><p>用户的设置可以通过一个叫 <code>UserDefaults</code> 的东西来存储，它会在你 app 的沙盒容器中的 Preferences 文件夹中用键值对来存储零碎的小数据。</p><p>在 <strong>Project Navigator（项目导航器）</strong> 中，右键点击 <strong>Model</strong> 分组，并选择 Xcode 菜单上的 <strong>New File…</strong>，选择 <strong>macOS</strong> → <strong>Swift File</strong>，然后点击 <strong>Next</strong>，把文件起名为 <strong>Preferences.swift</strong> 并点击 <strong>Create</strong>。把这些代码添加到 <strong>Preferences.swift</strong> 文件中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Preferences</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> selectedTime: <span class="type">TimeInterval</span> &#123;</span><br><span class="line"><span class="keyword">get</span> &#123;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> savedTime = <span class="type">UserDefaults</span>.standard.double(forKey: <span class="string">"selectedTime"</span>)</span><br><span class="line"><span class="keyword">if</span> savedTime &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> savedTime</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">360</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span> &#123;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: <span class="string">"selectedTime"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这些代码又干了些啥？</p><ol><li>定义了一个名叫 <code>selectedTime</code> 的 <code>TimeInterval</code> 计算属性；</li><li>当别的代码请求访问这个变量的值的时候时，<code>UserDefaults</code> 的单例将会去查找键「selectedTime」对应的 <code>Double</code> 值；如果这个值从没被定义过，<code>UserDefaults</code> 将会返回 0；但如果存在这个值，且它大于 0，就将这个值返回，并设置为 <code>selectedTime</code>；</li><li>如果 <code>selectedTime</code> 还没有被定义过，就使用默认值 360（6 分钟）；</li><li>只要 <code>selectedTime</code> 的值发生了改变，把新的值用键「selectedTime」存入 <code>UserDefaults</code>。</li></ol><p>通过使用 getter 和 setter，<code>UserDefaults</code> 的数据存储将能够自动进行。</p><p>现在切换回 <strong>PrefsViewController.swift</strong>，我们需要把用户修改的设置内容在界面上显示出来。</p><p>第一步，在 IBOutlet 之下添加这些代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefs = <span class="type">Preferences</span>()</span><br></pre></td></tr></table></figure><p>这一步中你创建了一个 <code>Preferences</code> 的实例，所以你现在可以自由访问 <code>selectedTime</code> 计算变量了。</p><p>接下来，添加这些方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showExistingPrefs</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> selectedTimeInMinutes = <span class="type">Int</span>(prefs.selectedTime) / <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">presetsPopup.selectItem(withTitle: <span class="string">"Custom"</span>)</span><br><span class="line">customSlider.isEnabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> presetsPopup.itemArray &#123;</span><br><span class="line"><span class="keyword">if</span> item.tag == selectedTimeInMinutes &#123;</span><br><span class="line">presetsPopup.select(item)</span><br><span class="line">customSlider.isEnabled = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">customSlider.integerValue = selectedTimeInMinutes</span><br><span class="line">showSliderValueAsText()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showSliderValueAsText</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> newTimerDuration = customSlider.integerValue</span><br><span class="line"><span class="keyword">let</span> minutesDescription = (newTimerDuration == <span class="number">1</span>) ? <span class="string">"minute"</span> : <span class="string">"minutes"</span></span><br><span class="line">customTextField.stringValue = <span class="string">"\(newTimerDuration) \(minutesDescription)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像是很大一坨代码🙄️…所以我们一点一点来看：</p><ol><li>访问 <code>prefs</code> 对象的 <code>selectedTime</code> 属性，并把它转化成整数的分钟数；</li><li>把默认的计时时间设置为「Custom」，以防止没有找到人寰预设的数据；</li><li>遍历 <code>presetsPopup</code> 里的菜单项并检查他们的 tag，还记得在第二部分中你把每个项目的 tag 都设置成了各自选项的分钟数了吗？如果找到了用户选择的菜单项，就把这个菜单项启用，并跳出这个循环；</li><li>设置滑动条的数值，并调用 <code>showSliderValueAsText</code> 方法；</li><li><code>showSliderValueAsText</code> 把数字加上「minute」或「minutes」并将它显示在界面上的 Text Field 中。</li></ol><p>现在，把这行代码添加到 <code>viewDidLoad</code> 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showExistingPrefs()</span><br></pre></td></tr></table></figure><p>在 View 加载的时候，会调用这个方法，把用户的设置加载到界面上，在 MVC 模式中，<code>Preferences</code> Model 完全不知道它伫立的数据会怎样被显示出来 —— 界面显示是 <code>PrefsViewController</code> 的事儿。</p><p>所以，尽管现在你的 app 已经可以显示用户设置的时间了，然而偏好设置里的下拉框还是不能工作，你需要为它编写一个方法来让它能存储新的的设置，并告诉所有相关对象数据发生了改变。</p><p>在 <code>EggTimer</code> 对象中，你使用了 delegate 模式来把数据传递到需要它的地方，这一次，你需要通过发送一个 <code>Notification</code>（通知）来告诉大家数据改变了（其实用 delegate 还是可以的，这里只是为了演示 Notification 的用法）。任何对象在表明自己对这个通知感兴趣之后，都可以接收到这个通知，并在接收时采取行动。</p><p>在 <code>PrefsViewController</code> 中添加以下方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveNewPrefs</span><span class="params">()</span></span> &#123;</span><br><span class="line">prefs.selectedTime = customSlider.doubleValue * <span class="number">60</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: <span class="type">Notification</span>.<span class="type">Name</span>(rawValue: <span class="string">"PrefsChanged"</span>),</span><br><span class="line">                                object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法将会获取 customSlider 滑动条的数值，并转化成分钟数，赋值予 <code>selectedTime</code>，因为我们之前编写的 setter，它会自动使用 <code>UserDefaults</code> 来存储新的数据。然后 <code>NotificationCenter</code>（通知中心）会将一个名叫「PrefsChanged」通知发送出去。</p><p>接下来，我们来让 <code>ViewController</code> 能够接收到这个 <code>Notification</code>，并采取行动：</p><p>在 <code>PrefsViewController</code> 中要编写的最后一部分代码是为第二部分中你添加的 <code>@IBAction</code> 们添加真正的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">popupValueChanged</span><span class="params">(<span class="number">_</span> sender: NSPopUpButton)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> sender.selectedItem?.title == <span class="string">"Custom"</span> &#123;</span><br><span class="line">customSlider.isEnabled = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newTimerDuration = sender.selectedTag()</span><br><span class="line">customSlider.integerValue = newTimerDuration</span><br><span class="line">showSliderValueAsText()</span><br><span class="line">customSlider.isEnabled = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">sliderValueChanged</span><span class="params">(<span class="number">_</span> sender: NSSlider)</span></span> &#123;</span><br><span class="line">showSliderValueAsText()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">cancelButtonClicked</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">view.window?.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">okButtonClicked</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">saveNewPrefs()</span><br><span class="line">view.window?.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当用户在下拉框中选择了一个新的菜单项，这段代码会检测这个项是不是 Custom：<ul><li>如果是的，就启用滑动条，并直接终止这个方法；</li><li>如果不是，就通过这个项的 tag 来获取用户选择的计时时间；</li></ul></li><li>每当滑动条的数据更新时，更新界面上的文本；</li><li>点击 Cancel 按钮会把窗口关闭，且不会存储数据；</li><li>点击 OK 按钮会先调用 <code>saveNewPrefs</code>，然后关闭这个窗口。</li></ol><p>编译并运行你的 app，前往 <strong>Preferences</strong>，试着在下拉框中选择不同的选项，观察一下滑动条和文本有没有根据你的选择而正确显示。选择 Custom 选项，然后自己选择一个时间，点击 <strong>OK</strong>，然后再次前往 <strong>Preferences</strong>，看看你刚刚选择的时间是不是还能正常显示。</p><p>现在试着退出你的 app 并重新打开它，返回 <strong>Preferences</strong>，看看你的 app 是否保存了你的设置。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-cfea9ce49a01ee81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="让用户的设置生效"><a href="#让用户的设置生效" class="headerlink" title="让用户的设置生效"></a>让用户的设置生效</h1><p>现在偏好设置窗口看起来还不错了 —— 它可以存储并读取用户的设置，但当你回到主窗口，你看到的时间会还是 6 分钟！ ☹️</p><p>所以你需要编辑 <strong>ViewController.swift</strong>，让它能使用存储了的数据，并侦听关于数据变化了的通知，从而及时更新或重设 Timer。</p><p>把这个 Extension 添加到 <strong>ViewController.swift</strong> 中类定义以外的部分 —— 这样一来我们的代码会被分成若干个承担不同职能的部分，看起来会更整洁。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - 设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupPrefs</span><span class="params">()</span></span> &#123;</span><br><span class="line">updateDisplay(<span class="keyword">for</span>: prefs.selectedTime)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> notificationName = <span class="type">Notification</span>.<span class="type">Name</span>(rawValue: <span class="string">"PrefsChanged"</span>)</span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: notificationName,</span><br><span class="line">   object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123;</span><br><span class="line">(notification) <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>.updateFromPrefs()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateFromPrefs</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">self</span>.eggTimer.duration = <span class="keyword">self</span>.prefs.selectedTime</span><br><span class="line"><span class="keyword">self</span>.resetButtonClicked(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码会报错，因为 <code>ViewController</code> 内部还没有一个叫做 <code>prefs</code> 的对象。在 <code>ViewController</code> 类的定义中（也就是你定义 <code>eggTimer</code> 的地方），添加这行代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefs = <span class="type">Preferences</span>()</span><br></pre></td></tr></table></figure><p>现在 <code>PrefsViewController</code> 和 <code>ViewController</code> 内部都有了一个 prefs 属性 —— 这是个问题吗？不！原因如下：</p><ol><li><code>Preferences</code> 是一个 struct（结构体），所以它是一个数据型的对象而非一个关系型的对象。每一个 View Controller 都可以拥有一份它的副本；</li><li><code>Preferences</code> 结构体是使用了 <code>UserDefaults</code> 的单例，所以这俩副本其实是在调用同一个 <code>UserDefaults</code>，因此拿到的数据也是完全一样的。</li></ol><p>在 ViewController 最后的 <code>viewDidLoad</code> 方法中，添加这一行代码，它会设置好自己和 <code>Preferences</code> 的连接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setupPrefs()</span><br></pre></td></tr></table></figure><p>现在还有最后的一系列步骤需要做。之前我们把默认的时间，也就是 360 秒，直接写进了代码里（也就是硬编码，hard-coded），现在因为 <code>ViewController</code> 已经可以访问 <code>Preferences</code> 了，你需要修改一下这种写法。</p><p>在 <strong>ViewController.swift</strong> 中找到「360」（你应该能找到 3 个 360），并把它们修改成 <code>prefs.selectedTime</code>。</p><p>编译并运行你的 app，如果你之前修改过设置里的计时时间，你选择的时间现在应该能正常显示在界面上了。前往 <strong>Preferences</strong>，选择另一时间，点击 <strong>OK</strong> —— 因为 <code>ViewController</code> 接收到了通知，你新选择的时间应该马上就能显示出来了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-ea3e30e4e2da720e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>启动计时器，然后前往 <strong>Preferences</strong>，在主窗口中，倒计时还在继续，修改一个时间然后点击 <strong>OK</strong>，计时器应用了新的时间，但是也停止并重设了倒计时。我觉得这没什么问题，但是如果能添加一个提示，询问用户是否真的希望停止计时，这样会不会更好呢？</p><p>在 ViewController 中负责处理设置的 Extension 中，添加这些代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkForResetAfterPrefsChange</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> eggTimer.isStopped || eggTimer.isPaused &#123;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">updateFromPrefs()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> alert = <span class="type">NSAlert</span>()</span><br><span class="line">alert.messageText = <span class="string">"Reset timer with the new settings?"</span></span><br><span class="line">alert.informativeText = <span class="string">"This will stop your current timer!"</span></span><br><span class="line">alert.alertStyle = .warning</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">alert.addButton(withTitle: <span class="string">"Reset"</span>)</span><br><span class="line">alert.addButton(withTitle: <span class="string">"Cancel"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> response = alert.runModal()</span><br><span class="line"><span class="keyword">if</span> response == <span class="type">NSAlertFirstButtonReturn</span> &#123;</span><br><span class="line"><span class="keyword">self</span>.updateFromPrefs()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这些代码是干啥的？</p><ol><li>如果计时器已经停止或暂停了，不做任何操作直接修改时间；</li><li>创建一个 <code>NSAlert</code>，它是一个用来显示一个对话框的类，并设置它的文字和样子；</li><li>添加两个按钮：Reset 和 Cancel，它们将会根据你添加的顺序从右往左显示在对话框中，且右边的将会是默认选项；</li><li>把警告以一个模态的窗口显示出来，并等待用户的选择，如果用户点击了第一个按钮（Reset），就重设计时器。</li></ol><p>在 <code>setupPrefs</code> 方法中，把 <code>self.updateFromPrefs()</code> 这一行改成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.checkForResetAfterPrefsChange()</span><br></pre></td></tr></table></figure><p>编译并运行你的 app，开始计时，前往 <strong>Preferences</strong>，修改一下时间，然后点击 <strong>OK</strong>，你将会看见一个对话框询问你是否要重设时间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-129ab28735fa7b83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h1><p>现在这个 app 中唯一未完成的功能就是音效了。如果没有「叮～～」的一声的话，煮蛋计时器还能叫做煮蛋计时器吗？</p><p>在第二部分中，你已经下载了一个包含了所有资产的文件夹，其中的内容绝大多数都是图片，你也已经用过它们了，但是其实这里面还有一个音效文件：<strong>ding.mp3</strong>。如果你找不到这个文件了，你可以单独下载<a href="https://koenig-media.raywenderlich.com/uploads/2017/02/ding.mp3.zip" target="_blank" rel="noopener">这个音效文件</a>。</p><p>把 <strong>ding.mp3</strong> 拖动到 <strong>Project Navigator（项目导航器）</strong>中的 <strong>EggTimer</strong> 分组下方 —— 看起来就放在 <strong>Main.storyboard</strong> 下边是一个不错的想法。勾选 <strong>Copy items if needed（如果需要的话把文件拷贝到项目中）</strong>，在 <strong>Add to targets（添加到目标中）</strong> 中勾选 EggTimer，然后点击 <strong>Finish</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-83a5759cff376d34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>你需要一个叫 <code>AVFoundation</code> 的库来播放声音。当代理告诉 <code>ViewController</code> 计时器结束了的时候，<code>ViewController</code> 就会负责播放这个音效，所以我们切换到 <strong>ViewController.swift</strong> 中，在最顶部你会看到这个文件引用了 <code>Cocoa</code> 库（<code>import Cocoa</code>）。</p><p>在那一行引用的下方，添加：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AVFoundation</span><br></pre></td></tr></table></figure><p><code>ViewController</code> 需用一个 <code>AVAudioPlayer</code> 来播放声音，所以我们为它添加一个属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> soundPlayer: <span class="type">AVAudioPlayer?</span></span><br></pre></td></tr></table></figure><p>我们应该为 <code>ViewController</code> 新建一个单独的 Extension 来处理和声音相关的方法，所以在 <strong>ViewController.swift</strong> 类定义以外的地方添加：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - 声音</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareSound</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> audioFileUrl = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"ding"</span>,</span><br><span class="line"> withExtension: <span class="string">"mp3"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">soundPlayer = <span class="keyword">try</span> <span class="type">AVAudioPlayer</span>(contentsOf: audioFileUrl)</span><br><span class="line">soundPlayer?.prepareToPlay()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Sound player not available: \(error)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">playSound</span><span class="params">()</span></span> &#123;</span><br><span class="line">soundPlayer?.play()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>prepareSound</code> 方法会负责处理绝大多数的事情 —— 它会先检查 ding.mp3 是否存在于 app 的包中，如果这个文件存在，它就会试图去用这个文件的 URL 来实例化一个 <code>AVAudioPlayer</code>，并准备好它以备播放。这将会预先加载这个音频文件，所以一旦需要，就可以立即播放。</p><p>如果 <code>soundPlayer</code> 存在，<code>playSound</code> 会调用它的 <code>play()</code> 方法；但如果 <code>prepareSound</code> 运行失败了，<code>soundPlayer</code> 将会为空（nil），因此它什么也不会做。</p><p>声音文件只在 Start 按钮被点击时需要被准备，所以把这行代码插入到 <code>startButtonClicked</code> 方法的最后：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepareSound()</span><br></pre></td></tr></table></figure><p>在 <strong>EggTimerProtocol</strong> Extension 的 <strong>timerHasFinished</strong> 方法中，追加这行代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">playSound()</span><br></pre></td></tr></table></figure><p>编译并运行之，选择一个短一点的时间并开始计时，一声清脆的「叮🔔」会在计时结束的时候响起。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-34ba46713c905890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="现在该做些什么？"><a href="#现在该做些什么？" class="headerlink" title="现在该做些什么？"></a>现在该做些什么？</h1><p>你可以<a href="https://koenig-media.raywenderlich.com/uploads/2017/02/EggTimer-Final2.zip" target="_blank" rel="noopener">下载这个项目的源代码</a>。</p><p>在这个 macOS 开发教程中，你已经掌握了开发 macOS app 的基本技能，但真正要学习的还有很多！</p><p>Apple 编写了许多很棒的<a href="https://developer.apple.com/library/content/navigation/#section=Platforms&amp;topic=macOS" target="_blank" rel="noopener">文档</a>，他们覆盖了 macOS 开发的方方面面。</p><p>我同时强烈建议你去看看我们（原作者）的网站 <a href="https://www.raywenderlich.com/category/macos" target="_blank" rel="noopener">raywenderlich.com</a> 上的其他 macOS 教程。</p><p>如果你还有任何问题，欢迎在<a href="https://www.raywenderlich.com/151748/macos-development-beginners-part-3" target="_blank" rel="noopener">原文下方</a>参与讨论！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.raywenderlich.com/151741/macos-development-beginners-part-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raywe
      
    
    </summary>
    
    
      <category term="翻译" scheme="https://sr2k.top/blog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ray Wenderlich" scheme="https://sr2k.top/blog/tags/Ray-Wenderlich/"/>
    
      <category term="macOS" scheme="https://sr2k.top/blog/tags/macOS/"/>
    
      <category term="Swift" scheme="https://sr2k.top/blog/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】 零基础 macOS 应用开发（二）</title>
    <link href="https://sr2k.top/blog/2017/09/22/%E8%AF%91-%E9%9B%B6%E5%9F%BA%E7%A1%80macOS%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%912/"/>
    <id>https://sr2k.top/blog/2017/09/22/译-零基础macOS应用开发2/</id>
    <published>2017-09-21T20:39:26.000Z</published>
    <updated>2019-07-19T05:03:34.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://www.raywenderlich.com/151741/macos-development-beginners-part-1" target="_blank" rel="noopener">raywenderlich.com 的 macOS 开发经典入门教程</a> ，已咨询对方网站，可至多翻译 10 篇文章。<br>还是<del>先打赏然后</del>去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。<br>综上，此翻译版本仅供参考，<strong>谢绝转载</strong>。 </p></blockquote><p>欢迎回到我们的零基础 macOS 应用开发教程的第二部分（共三部分）！</p><p>在第一部分（<a href="https://www.raywenderlich.com/151741/macos-development-beginners-part-1" target="_blank" rel="noopener">原文</a> / <a href="http://www.jianshu.com/p/a3f16178a213" target="_blank" rel="noopener">译文</a>），你了解了如何安装 Xcode、如何创建一个新的 app、添加 UI、连接代码与 UI、运行 app、调试 app，以及寻求帮助。如果你对上述内容还有任何不确定之处，再回去浏览一遍第一部分吧。</p><p>在这一部分，你将会创建一个界面更加复杂的 app。你将会学到如何应对可调整大小的窗口，以及设计第二个页面——偏好设置页面，并让你的 app 能跳转到这个新创建的页面。</p><h1 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h1><p>和第一部分一样，打开 Xcode 并在欢迎页面点击 <strong>Create a new Xcode project</strong>，或选择 <strong>File</strong> 菜单中的 <strong>New Project…</strong>。接下来在 <strong>macOS</strong> 下的 <strong>Application</strong> 标签页中选择 <strong>Cocoa Application</strong>，并点击 <strong>Next</strong>，把你的 app 命名为 <strong>EggTimer</strong>，确保 Language 选项为 <strong>Swift</strong> 以及 <strong>Use Storyboards</strong> 被选中。点击 <strong>Next</strong> 然后找一个合适的地方存储这个项目。</p><p>编译并运行你的 app 来确保一切正常。</p><h1 id="EggTimer-App"><a href="#EggTimer-App" class="headerlink" title="EggTimer App"></a>EggTimer App</h1><p>你将会开发的 app 叫做 <strong>EggTimer</strong>，它能帮助用户倒计时，并显示剩余的时间。App 的界面上会有一个鸡蛋的图标，随着时间的临近，鸡蛋会被慢慢煮熟；当你的鸡蛋煮熟时，还会有一个提示音。App 内还有一个页面会显示此 app 的偏好设置。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-08716dfcefbc0d2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在 <strong>Project Navigator（项目导航器）</strong>中打开 <strong>Main.storyboard</strong>，正如第一部分所说的，你已经拥有了三个场景：</p><ul><li><strong>Application Scene（应用场景）</strong>包含了只要 app 运行着就会显示的菜单栏。</li><li><strong>Window Controller（窗口控制器）</strong>是定义了 app 窗口有怎样行为（怎么调整大小、窗口怎么出现、app 是否会记住上次调整的大小和位置等等）的部分；其实一个 Window Controller 可以管理多个窗口，但如果它们的属性不同，你就需要多个 Windows Controller 了。</li><li><strong>View Controller</strong> 则显示了窗口中的用户界面——也就是你对 UI 进行布局的地方。</li></ul><p>你注意到了吗？有一个箭头指向了 <strong>Window Controller</strong>，这表明它是 app 启动时的 initial display（初始页面）。你可以在 <strong>Document Outline（文档大纲）</strong>中选择 <strong>Window Controller</strong>，然后在 <strong>Attributes Inspector（属性检查器）</strong>中查看这个设置。取消勾选 <strong>Is Initial Controller（用作首要控制器）</strong>后，箭头就消失了。因为你需要它来作为首要的控制器，请把这个选项勾选上。</p><h1 id="Window-Controller（窗口控制器）"><a href="#Window-Controller（窗口控制器）" class="headerlink" title="Window Controller（窗口控制器）"></a>Window Controller（窗口控制器）</h1><p>在你开始着手 UI 前，请确保你已经在 <strong>Project Navigator（项目导航器）</strong>中选择了 <strong>Main.storyboard</strong>。点击来选择其中的 window（窗口）。在可视化编辑器中，Window Controller显示了「View Controller」这行字，因为它包含着一个 View Controller（视图控制器）。在这个 app 中，我们不希望用户将窗口调整到 346 × 471 像素以下，这两个数值也将会是 app 启动时窗口的默认大小。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-19c468e3d35e28ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在 <strong>Utilities（工具集）</strong>面板中前往 <strong>Size Inspector（尺寸检查器）</strong>，设置 <strong>Content Size Width（内容宽度）</strong>和 <strong>Content Size Height（内容高度）</strong>分别为 346；勾选 <strong>Minimum Content Size（最小内容尺寸）</strong>的复选框，并确保其数值与内容尺寸相同。现在，在可视化编辑器里的 Window Controller 的尺寸应该已经发生了变化，因此可能会盖住其他元素，你可能需要重新排列一下它们。</p><p>虽然不是必须的，但当你把 View Controller 和承放它的 Window Controller 调整到一样的大小后，后续操作会直观很多。点击并选中 <strong>View Controller</strong>，在 <strong>Size Inspector（尺寸检查器）</strong>中设置 Width 和 Height 分别为 346 和 471。如果需要的话，重新排列一下界面上的各个元素防止它们重叠。现在可视化编辑器里的 Window Controller 和 View Controller 都有着一样的尺寸了。</p><p>选中 WindowController 里的 Window，在 <strong>Attributes Inspector（属性检查器）</strong>中把它的名字更改为 <strong>Egg Timer</strong>，设置 <strong>Autosave name</strong> 为 <strong>EggTimerMainWindow</strong>，这样用户上次调整的窗口的尺寸和大小在 app 下次启动时就都会被记住了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-c7d85f2f0d6d0904.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果你是一个 iOS 开发者，你应该已经处理过不同设备、屏幕尺寸、屏幕旋转方向下的适配问题了。在 macOS 开发过程中，你必须处理无限多种窗口尺寸和长宽比，因此我在这里把窗口的默认尺寸调整成了这么一个奇怪的数字。不过好消息是，Auto Layout 帮助你解决了这个问题。</p><h1 id="布局-UI（一）"><a href="#布局-UI（一）" class="headerlink" title="布局 UI（一）"></a>布局 UI（一）</h1><p>基本的 UI 包含了两个 Stack View（堆叠视图）：第一部分包含显示剩余时间的 Label 和鸡蛋的图标。第二个则在底部包含三个按钮，我们先来制作按钮：</p><ul><li>在 Object Library（控件库）中搜索「Button」</li><li>向 View Controller 中拖动一个 Gradient button</li><li>使用 Attributes Inspector（属性检查器）删除它的图像，并把它 Title 设置为 Start</li><li>把字体改成 System 24  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-4ae1393f269f082a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>把按钮拖大一些让文字能显示完全</li><li>选中 Start 按钮，按下 <strong>Command⌘ + D</strong> 两次来复制两份</li><li>把新复制的按钮向右拖动一些，并把他们的 Title 改成 Stop 和 Reset</li><li>同时选中三个按钮，然后点击菜单栏上的 <strong>Editor</strong> → <strong>Embed In</strong> → <strong>Stack View</strong>  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f6aea6afee6f6ab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><p>为了让按钮填满整个 Stack View，选择新创建的 <strong>Stack View</strong>，然后在 <strong>Attributes Inspector（属性检查器）</strong>里做出如下更改：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-2b2511e23d04a185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>Distribution（分配）: Fill Equally（均分填满）</li><li>Spacing（间距）: 0</li></ul><p>在可视化编辑器的底部点击 <strong>Add New Constraints（添加新的约束条件）</strong>，设置左边、右边、底部和高度如上图所示。将 <strong>Update Frames</strong> 设置为 <strong>Items of New Constraints</strong>，然后点击 <strong>Apply 4 Constraints（应用四条约束）</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f85403067df43c12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Stack View 现在已经放置好了，但这些按钮似乎比 Stack View 矮了一些，在 <strong>Document Outline（文档大纲）</strong> 中，按住 Control⌃ 键的同时拖动 <strong>Start</strong> 按钮到 <strong>Stack View</strong> 上，并选择  <strong>Equal Heights（高度等同）</strong>。对另外两个按钮进行同样的操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-ab9ac2de341eaff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在，包含了按钮的 Stack View 已经完全是我们想要的样子了。</p><p>编译并运行你的 app，尝试着改变窗口的大小，这些按钮会紧紧地贴在窗口的底部，并自动填满整个窗口的宽度。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-74146b94cd847984.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最后一步，在 <strong>Attributes Inspector（属性检查器）</strong>中取消选中 <strong>Enabled</strong> 来禁用 Stop 按钮和 Reset 按钮，在计时开始前，这两个按钮不应该被启用。</p><h1 id="布局-UI（二）"><a href="#布局-UI（二）" class="headerlink" title="布局 UI（二）"></a>布局 UI（二）</h1><p>第二个 Stack View 包含剩余的时间以及鸡蛋的图片。向 View Controller 拖入一个 Label，把它的 <strong>Title（标题）</strong>设置为 6:00 并把 <strong>Alignment（对齐）</strong>设置为 center（居中）。默认的字体（San Francisco）会自动调整字符的间距——这意味着：随着倒计时的时间的变化，数字会来回跳跃——这会很烦人。</p><p>把字体改成 <strong>Helvetica Neue</strong> 来避免这样，然后把 Size（字体大小）设置为 <strong>100</strong>。这会使文字超出 Label 的范围，所以调整 Label 的大小直到你可以看到完整的文字。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-3ebc934ae850da45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在我们需要添加一张图片，在 <strong>Object Library（控件库）</strong>的搜索框中输入「image」，这会过滤出很多长得很像的控件，你需要的是 <strong>Image View</strong>，将它拖动到 <strong>View Controller</strong> 中剩余时间 Label 的下方。</p><p>下载<a href="https://koenig-media.raywenderlich.com/uploads/2017/01/EggTimerAssets-1.zip" target="_blank" rel="noopener">这个工程需要的资源文件</a>（一些图片和一个声音文件），解压碎并打开 <strong>Egg Images</strong> 文件夹。回到 Xcode，在 <strong>Project Navigator（项目导航器）</strong>中点击 <strong>Assets.xcassets</strong>。</p><p>把这六个图片拖动到 Assets Library（资产库）中，然后它们就可以在你的 app 中使用了。因为图片的文件名中带有「@2x」，它们会被自动分配到各个图像资产的 @2x 区域。</p><blockquote><p><strong>译注</strong>：关于 @2x 请自行搜索 Mac/iOS 的 HiDPI适应</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-97b495f9dec58409.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>前往 <strong>Main.storyboard</strong>，选中你刚刚添加的 <strong>Image View</strong>，在 <strong>Attributes Inspector（属性检查器）</strong>中点击 <strong>Image（图像）</strong>下拉框，在这个下拉框中你可以看到很多内置的图片以及你刚刚添加的图片，选中 <strong>stopped</strong>。</p><p>现在我们来制作第二个 Stack View：选中显示剩余时间的 Label 和刚刚调整好的 Image View，在菜单栏上点击 <strong>Editor</strong> → <strong>Embed In</strong> → <strong>Stack View</strong>。然后我们来调整一下这个 Stack View，使它填满剩余的空间。点击可视化编辑器底部的 <strong>Add New Constrains（添加新的约束）</strong>，然后添加下图所示的约束条件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-615f609fb882c324.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>正我们所需要的，Stack View 填满了剩下的空间，但这个 Image View 太小了，选中它，将它左右两您的约束按照下图设置为 <strong>User Standard Value（使用标准值）</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-39834cef032ced63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在 <strong>Attributes Inspector（属性检查器）</strong>中，设置 <strong>Scaling（缩放）</strong> 为 <strong>Proportionally Up or Down（等比放大或缩小）</strong>。</p><p>编译并运行 app，调整窗口的大小，看看 UI 元素是否如预期地自动地适应了窗口尺寸。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-5ea6f7acd31b9674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="连接-UI-和代码"><a href="#连接-UI-和代码" class="headerlink" title="连接 UI 和代码"></a>连接 UI 和代码</h1><p>在第一部分（<a href="https://www.raywenderlich.com/151741/macos-development-beginners-part-1" target="_blank" rel="noopener">原文</a> / <a href="http://www.jianshu.com/p/a3f16178a213" target="_blank" rel="noopener">译文</a>）中，你已经知道了你需要使用 <code>@IBOutlets</code> 和 <code>@IBActions</code> 来连接你的 UI 和代码。在这个例子中，你需要为以下元素设置 <code>@IBOutlets</code>：</p><ul><li>剩余时间的 Label</li><li>显示鸡蛋的 Image View</li><li>三个按钮</li></ul><p>此外，这三个按钮还需要 <code>@IBAction</code> 来响应用户的点击操作。在 <strong>Project Navigator（项目导航器）</strong>中，先选中 <strong>Main.storyboard</strong>，再按住 Option⌥，点击 <strong>ViewController.swift</strong>，这样就可以在 <strong>Assistant Editor（辅助编辑器，即左右分栏）</strong>中打开它了。如果你的屏幕空间不足，点击右上角的按钮来隐藏 <strong>Utilities（工具集）</strong> 和 <strong>Navigator（导航器）</strong> 面板。</p><p>和第一部分一样，选中剩余时间的 Label，按住 Control⌃ 键的同时拖动它到 <code>ViewController</code> 类中，将名称设置为 <code>timeLeftField</code>，对鸡蛋的 Image View 进行一样的操作，它的名字设置为 <code>eggImageView</code>。然后是三个按钮，他们的名字分别设置成 <code>startButton</code>、<code>stopButton</code> 和 <code>resetButton</code>。</p><p>这三个按钮还需要 <code>@IBAction</code>，按住 Control⌃ 并拖动 Start 按钮到代码中，但这次在弹出窗口中将 <strong>Connection</strong> 设置为 <strong>Action</strong>，并把它的名字设置为 <code>startButtonClicked</code>，对另外两个按钮重复以上动作，为它们添加名为 <code>stopButtonClicked</code> 和 <code>resetButtonClicked</code> 的 @IBAction。</p><p>如果你和我一样也经常忘了把 Connection 修改为 Action 的话，你会得到 <code>@IBOutlets</code> 而不是 <code>@IBAction</code>，如果你要删除这些多余的 <code>@IBOutlet</code>，先把这一行代码删除，再转到 <strong>Utilities（工具集）</strong>里的 <strong>Connections Inspector（连接检查器）</strong>，你会看到 <strong>Referencing Outlets</strong> 部分里有两个项目，点击错误连接旁的 <strong>×</strong> 来删除它，然后重新连接你的 <code>@IBAction</code>（这一次别忘了修改 Action 哦😛）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-13272c42cf46d1e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p><code>ViewController</code> 里的代码现在看起来应该像这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-6b623748347d67e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在第三部分中，你将会给这些动作添加代码，现在我们关闭 <strong>Assistant Editor（辅助编辑器）</strong>，如果你刚刚隐藏了 <strong>Navigator（导航器）</strong> 和 <strong>Utilities（工具集）</strong>，重新打开它们。</p><h1 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h1><p>在 <strong>Main.storyboard</strong>，在 <strong>Application Scene（应用场景）</strong> 中点击 <strong>menu bar（菜单栏）</strong>，Xcode 提供的模版已经内置了一些默认的按钮，但是在这个 app 中，很多按钮都派不上用场，最简单的办法来浏览菜单里的项目是使用 <strong>Document Outline（文档大纲）</strong>，点击左侧的小三角来显示 <strong>View</strong> 菜单和里边的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-2c9bae3bcd38361d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>菜单栏的结构是由一些 Menus（菜单）和 Menu Items（菜单项目）组成的，切换到 <strong>Utilities（工具集）</strong>里的 <strong>Identity Inspector（身份检查器）</strong>，这样你就能看到，当你点击各个菜单项目的时候，真正触发的东西是什么了。<strong>Main Menu</strong> 是 <code>NSMenu</code> 的实例，它包含了 <code>NSMenuItem</code> 组成的数组：View 菜单就是这个数组的一个成员。</p><p>View 菜单包含一个子菜单（<code>NSMenu</code>），里面包含了它自己的 <code>NSMenuItems</code>，值得注意的是，<code>Separator</code>（分割线）是 <code>NSMenuItem</code> 的特殊形式。</p><p>我们要做的第一件事是删除这个 app 里不需要的菜单项，在 <strong>Document Outline（文档大纲）</strong>中选中 <strong>File</strong> 菜单，按下键盘上的 <strong>Delete⌫</strong> 键把它删掉。如果你是在 <strong>Visual Editor（可视化编辑器）</strong>中选中它并删除的话，你会把 <strong>File</strong> 菜单里的菜单项都删掉，然后只剩下一个空空如也的菜单，如果你不小心这样做了，选中那个空白然后再次按下 <strong>Delete⌫</strong> 来移除它。</p><blockquote><p>这段话的后半段没有看太明白，望各位指正，原文是： If you select it in the <strong>Visual Editor</strong> and delete, you will only have deleted the menu inside the <strong>File</strong> menu item, so you will be left with a space in the menu bar. If this happens, select the space and press <strong>Delete</strong> again to remove it. </p></blockquote><p>继续删除其他的 Menu，直到你只剩下了 EggTimer、Window 和 Help 菜单。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f513732e08e2b756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在你需要添加一个新的菜单来模拟三个按钮的操作，在 <strong>Object Library（控件库）</strong> 中搜索 「menu」，请注意，菜单栏中的每一个项目（如 File、Help ）都是 Menu Item，点击它之后打开的才是 Menu，拖动一个 <strong>Menu Item</strong> 到菜单栏中 <strong>Egg Timer</strong> 和 <strong>Window</strong> 之间的地方，它会显示成一个蓝色的方框，这是因为它内部还没有一个带有标题的 Menu。</p><p>现在想那个蓝色的方框拖入一个 <strong>Menu</strong>，如果你觉得那个方框太小拖不准的话，你也可以拖到 <strong>Document Outline（文档大纲）</strong>里我们刚刚创建的 <strong>Item</strong> 的下方。新的 Menu 还没有标题，但他已经有了三个菜单项。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-34421f6271f65999.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>选中 Menu（不是 item），切换到 <strong>Attributes Inspector（属性检查器）</strong>并把 Title（标题）设置为 <strong>Timer</strong>，选中 <strong>Item 1</strong>，双击它（或在属性检查器里）把他的标题改为 <strong>Start</strong>。</p><p>在 <strong>Attributes Inspector（属性检查器）</strong>中点击 <strong>Key Equivalent（快捷键）</strong>，然后按下 <strong>Command⌘ + S</strong> 来设置快捷键。通常情况下 Command⌘ + S 是保存的快捷键，但是你已经删除了 File 菜单，这样的设置并不会有冲突，但在一般情况下我们还是不要复用常见快捷键的比较好。</p><p>用同样的方法把第二、三个 item 的标题分别设置为设置为 <strong>Stop</strong> 和 <strong>Reset</strong>，快捷键分别为 <strong>Command⌘ + X</strong> 和 <strong>Command⌘ + R</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-18b590d315a6d327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在可视化编辑器中 Menu Bar 的上方，你能看到三个按钮，切换到 <strong>Identity Inspector（身份检查器）</strong>，然后依次点击这三个按钮，你可以看到，他们分别连接着 <strong>Application</strong>、<strong>First Responder</strong>、和 <strong>AppDelegate</strong>。First Responder 通常就是当前处于最前端的 View Controller，它可以从 Menu Item 那里接收动作。</p><p>按住 Option⌥ 的同时点击 <strong>ViewController.swift</strong>，然后在你刚刚为按钮们添加的 <code>@IBAction</code> 的下方添加以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - IBActions - menus</span></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">startTimerMenuItemSelected</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;<span class="number">_</span></span><br><span class="line">startButtonClicked(sender)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">stopTimerMenuItemSelected</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">stopButtonClicked(sender)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">resetTimerMenuItemSelected</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">resetButtonClicked(sender)</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>这些方法会在菜单项被点击时被调用，然后它们会去调用界面上那三个按钮的 IBAction 方法。其实，你可以让 Menu Item 直接调用按钮的方法（即把 Menu Item 的 IBAction 也拖到之前定义的按钮的 IBAction 上），但在这里我选择这种方式，因为这样的话，调试时这一系列事件会更加清晰明了。现在保存文件并退出 Assistant Editor（协助编辑器）。</p><p>按住 Control⌃ 键的同时，把 <strong>Start</strong> 菜单项拖动到象征着 <strong>First Responder</strong> 的橙色立方体上，一个包含了很多选项的窗口会弹出来，在键盘上输入「sta」来快速滚动到我们所需要的 <strong>startTimerMenuItemSelected</strong> 并选择它。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-36c02651cd888ae9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>用同样的方法把 <strong>Stop</strong> 菜单项和 <strong>Reset</strong> 菜单项分别连接至 <code>stopTimerMenuItemSelected</code> 和 <code>resetTimerMenuItemSelected</code>。现在当 EggTimer 窗口处于最前端时，点击菜单上的按钮将会调用这些方法。</p><p>但是还有一个问题：这三个按钮在同一时刻并非同时都是可用的，而且菜单栏上的按钮需要体现出他们是否可用。这个功能无法在 <code>ViewController</code> 里实现，因为它不会一直处于 First Responder 的状态，所以我们需要转战 <code>AppDelegate</code>。</p><p>打开 <strong>Main.storyboard</strong> 并确保这几个 Menu 都处于可见状态，在 <strong>Project Navigator（项目导航器）</strong>中按住 Option⌥ 键的同时点击 <strong>AppDelegate.swift</strong>，按住 Control⌃ 键的同时把 <strong>Start</strong> 菜单项拖动到 <code>AppDelegate</code> 中，创建一个名为 <code>startTimerMenuItem</code> 的 IBOutlet。</p><p>用同样的方法为另外两个菜单项创建名为 <code>stopTimerMenuItem</code> 的 <code>resetTimerMenuItem</code> IBOutlet。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-5ab7401f4b92e6cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在第三部分中你将了解到如何用代码来根据需要启用和禁用这些菜单项，但是现在你需要做的是关闭自动启用与禁用，因为在一般情况下，app 会检测当前的 First Responder 是否包含了 menu item 所连接的 action（一般就是 IBAction），如果没有，就会将他们禁用。在这个 app 中，我们希望自己来控制这件事情，所以选中 <strong>Timer</strong> 菜单项，在 <strong>Attributes Inspector（属性检查器）</strong> 中取消选中 <strong>Auto Enables Item（自动启用项目）</strong>。</p><h1 id="偏好设置窗口"><a href="#偏好设置窗口" class="headerlink" title="偏好设置窗口"></a>偏好设置窗口</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-d57913491417e0ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在 EggTimer app 的主界面已经看起来很好了，但他还需要一个偏好设置窗口来让用户选择他们想把鸡蛋煮多熟。</p><p>偏好设置界面将会显示在一个单独的窗口中，且拥有它自己的 Window Controller。这是因为尽管在一个 Window Controller 中显示多个 View Controller 是完全可行的，但它们会共享这个 Window Controller 的所有属性，而偏好设置窗口的默认大小与主窗口不一样，而且不可以调整大小。</p><p>打开 <strong>Main.storyboard</strong>，如果 Assistant Editor（辅助编辑器）还处于打开状态，把它关闭。在 <strong>Objects Library（控件库）</strong>中搜索「window」，向 <strong>Visual Editor（可视化编辑器）</strong>中拖入一个 <strong>Window Controller</strong>，Xcode 会自动为你创建一个 <strong>View Controller</strong> 来盛放需要现实的内容。重新排列一下窗口中的内容以便你能更清楚地看清所有内容，并让你新创建的 Window Controller 更靠近菜单栏。</p><p>打开菜单栏上的 <strong>EggTimer</strong> 菜单，按住 Control⌃ 键的同时拖动  <strong>Preferences…</strong> 菜单项到我们新创建的 Window Controller 上，这将会创建一个 Segue（转场），也就是说用户点击 <strong>Preferences…</strong> 时，这个 Window Controller 就会把我们新创建的 View Controller 给显示出来。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-38281070aa691081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>偏好设置面板需要显示一个新的 View Controller，所以你需要为它创建一个新的 View Controller 类。在 <strong>Project Navigator（项目导航器）</strong>中，选中已经存在了的 <strong>ViewController.swift</strong> 文件，这会确保新建的文件存储在与之相同的组中（Xcode 用 Group 来管理文件），然后在 Xcode 的菜单上点击 <strong>File</strong> → <strong>New</strong> → <strong>File…</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-9d4f11612ef000b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>选择 <strong>macOS</strong> → <strong>Cocoa Class</strong> 然后点击 <strong>Next</strong>，设置类名为 <code>PrefsViewController</code>，父类为 <code>NSViewController</code>，语言选择 <strong>Swift</strong>，不要勾选 <strong>Also create XIB file for user interface（同时为 UI 创建 XIB 文件）</strong>，然后点击 <strong>Next</strong> 和 <strong>Create</strong> 来保存文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-b8c33ef95a870bf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>回到 <strong>Main.storyboard</strong>，选中我们新创建的 View Controller，请确保你选择的是 View Controller 而不是它的 View，在 <strong>Document Outline（文档大纲）</strong>里选择会更容易些。在 <strong>Identity Inspector（身份检查器）</strong>中，把它的 Class 设置为 <code>PrefsViewController</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f8c00a8af7e5cced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>选择偏好设置窗口里的 Window Controller，前往 <strong>Attributes Inspector（属性检查器）</strong>把它的标题设置为 <strong> Preferences</strong>。Autosave Name 保持留空，这样每次窗口出现的时候都会出现在桌面的中央。取消选中 <strong>Minimize</strong> 和 <strong>Resize</strong> 复选框，这样窗口的大小就是固定的了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f7c1891dd5a4b659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>前往 <strong>Size Inspector（属性检查器）</strong>，把 <strong>Content Size</strong> 设置为宽 416 高 214。在 <strong>Initial Position（默认位置）</strong> 下方的两个下拉框中分别选择 <strong>Center Horizontally</strong> 和 <strong>Center Vertically</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-2f67ec6ea8e6e5bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>选中 <strong>View</strong> 中的 <strong>PrefsViewController</strong>，在 <strong>Size Inspector（尺寸检查器）</strong>中把它的宽和高分别设置为 416 和 214。</p><p><code>PrefsViewController</code> 需要显示一个用来选择时间的下拉框和一个用来选择时间的滑块，它们都包含各自的 Label 用于显示标题，还有两个按钮：Cancel 和 OK，以及一个用于显示当前选择时间的 Label。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-118f4b02dadb21be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>拖动以下控件到 View Controller 中并按下表设置它们的属性：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Label</strong></td><td>设置 title 为「Preset Egg Timings:」</td></tr><tr><td><strong>Pop Up Button</strong></td><td></td></tr><tr><td><strong>Label</strong></td><td>设置 title 为「Custom Egg Timing:」</td></tr><tr><td><strong>Label</strong></td><td>设置 title 为 「6 minutes」</td></tr><tr><td><strong>Horizontal Slider</strong></td><td></td></tr><tr><td><strong>Push Button</strong></td><td>设置 title 为 「Cancel」</td></tr><tr><td><strong>Push Button</strong></td><td>设置 title 为「OK」</td></tr></tbody></table><p>因为这个窗口不能调整大小，控件们会按照你的布局进行显示，所以我们不需要给它设置 Auto-layout 约束条件。把界面上的元素排列好，Xcode 自动会用蓝色的参考线来帮助你进行对齐。将显示「6 minutes」的 Label 的右边拖动到几乎与边界持平，因为它可能需要显示更多内容。双击 <strong>Pop Up Button</strong>，你会看到三个子项，把他们的标题分别设置为：</p><ul><li>For runny soft-boiled eggs (barely set whites): 3 minutes</li><li>For slightly runny soft-boiled eggs: 4 minutes</li><li>For custardy yet firm soft-boiled eggs: 6 minutes</li></ul><p>再从 <strong> Objects Library（控件库）</strong>中拖动两个 <strong>Menu Item</strong>、一个 <strong>Separator Menu Item</strong> 和另一个 <strong>Menu Item</strong> 到下拉框中，如果你觉得直接拖动它们到界面上有点难度的话，也可以拖动到 <strong>Document Outline（文档大纲）</strong>的相应位置。</p><p>给刚刚拖入的三个子项分别设置标题：</p><ul><li>For firm yet still creamy hard-boiled eggs: 10 minutes</li><li>For very firm hard-boiled eggs: 15 minutes</li><li>Custom</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-a18bf7365a1fb3e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我其实一点都不知道怎么煮鸡蛋，所以我从 <a href="http://www.thekitchn.com/how-to-boil-eggs-perfectly-every-time-cooking-lessons-from-the-kitchn-202415" target="_blank" rel="noopener">The Kitchn</a> 找到了以上的时间和描述。</p><p>选中下拉框本体（而不是那几个子项），把它的 <strong>Selected Item（已选中项目）</strong>设置为那个「6 minute」的选项。</p><p>现在你需要让你的 app 知道用户在下拉框中到底选择了哪个子项，依次选中下拉菜单中的每一个自子项，在 <strong>Attributes Inspector（属性检查器）</strong>中设置它们的 Tag 分别为对应的分钟数：3、4、6、10、15（Custom 子项设置为 0）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-168ccf7361b49bc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>现在选择 <strong>Slider</strong>，在 <strong>Attributes Inspector（属性检查器）</strong>中将 <strong>Tick marks（刻度数）</strong> 设置为 25，<strong>Minimum Valve</strong> 设置为 1，<strong>Maximum Valve</strong> 设置为 25，并勾选 <strong>Only stop on tick marks（只能选择刻度）</strong>，你需要将滑块向下移动一些来适应新出现的刻度。因为只有当用户在下拉框种选择了 <strong>Custom</strong> 的时候才会启用，所以我们还需要取消选择 <strong>Enabled</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-250dc7eb52fcc9ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="连接偏好设置里的元素和代码"><a href="#连接偏好设置里的元素和代码" class="headerlink" title="连接偏好设置里的元素和代码"></a>连接偏好设置里的元素和代码</h1><p>在 <strong>Project Navigator（项目导航器）</strong>中按住 Option⌥ 键的同时点击 <strong>PrefsViewController</strong>，如果你需要更多空间的话隐藏掉侧边面板。你需要为下拉框、滑动条和显示“6 minutes”的 Label 添加 <code>@IBOutlet</code>。把它们依次拖动到 <code>PrefsViewController.swift</code> 中，并给这些 IBOutlet 分别起名： </p><ul><li>Popup: <code>presetsPopup</code></li><li>Slider: <code>customSlider</code></li><li>Label: <code>customTextField</code></li></ul><p>接下来，按住 Control⌃ 键的同时拖动以下项目来创建 <code>@IBAction</code>（别忘了把 <strong>Connection</strong> 改成 <strong>Action</strong> 哦～）：</p><ul><li>Popup: <code>popupValueChanged</code></li><li>Slider: <code>sliderValueChanged</code></li><li>Cancel button: <code>cancelButtonClicked</code></li><li>OK button: <code>okButtonClicked</code></li></ul><p>现在你的代码看起来应该像这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-fd6157d641407125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>至此，偏好设置面板窗口的布局就已经完成了，编译并运行你的 app 并在 <strong>EggTimer</strong> 菜单中选择 <strong>Preferences</strong> 菜单，检查一下打开的偏好设置窗口，然后点击红色的关闭按钮来关闭这个窗口。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-5f2525c0145a1a43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="App-图标"><a href="#App-图标" class="headerlink" title="App 图标"></a>App 图标</h1><p>UI 部分还剩一步：为你的 app 添加图标。你之前已经下载了一个包含了这个 app 所需要的所有文件的资产文件夹，而且已经添加了一些图片到 Assets.xcassets 中，现在我们需要打开这个文件夹并找到 <strong>egg-icon.png</strong> 文件。</p><p>在 <strong>Project Navigator（项目导航器）</strong>中选择 <strong>Assests.xcassets</strong>，点击 <strong>AppIcon</strong> 并拖动 <strong>egg-icon.png</strong> 到 <strong>Mac 256pt 1x</strong> 的方框中。正如第一部分所说的，在真正的产品中你需要提供所有尺寸的图标，但在这个 app 中，一个图标就足够了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-e432e5e3eb797654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>编译并运行你的 app，看看新的图标有没有出现在 Dock 中，如果没有，你可能需要在 Xcode 的 <strong>Product</strong> 菜单中点击 <strong>Clean</strong>，然后再试一次。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f55108ac9559467e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.raywenderlich.com/151741/macos-development-beginners-part-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raywe
      
    
    </summary>
    
    
      <category term="翻译" scheme="https://sr2k.top/blog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ray Wenderlich" scheme="https://sr2k.top/blog/tags/Ray-Wenderlich/"/>
    
      <category term="macOS" scheme="https://sr2k.top/blog/tags/macOS/"/>
    
      <category term="Swift" scheme="https://sr2k.top/blog/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】 零基础 macOS 应用开发（一）</title>
    <link href="https://sr2k.top/blog/2017/09/17/%E8%AF%91-%E9%9B%B6%E5%9F%BA%E7%A1%80macOS%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%911/"/>
    <id>https://sr2k.top/blog/2017/09/17/译-零基础macOS应用开发1/</id>
    <published>2017-09-17T10:51:26.000Z</published>
    <updated>2019-07-19T05:03:34.685Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://www.raywenderlich.com/151741/macos-development-beginners-part-1" target="_blank" rel="noopener">raywenderlich.com 的 macOS 开发经典入门教程</a>，已咨询对方网站，可至多翻译 10 篇文章。<br>希望各位有英语阅读能力的话，还是<del>先打赏然后</del>去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。</p></blockquote><p>你想要学习开发你自己的 macOS app 吗？</p><p>有一个好消息要告诉你！在这个教程中你将会发现，Apple 让开发 macOS app 这件事变得无比简单。你将会学习到如何去创建你的第一个 macOS app——即使你是一个完全的小白。</p><ul><li>在第一部分中，你将学会如何获取 macOS 开发所需要的工具们。然后，通过创建一个简单的「Hello, World!」app，你将会粗略地认识 Xcode——如何运行一个 app、编辑代码、设计 UI 以及调试你的代码。</li><li>在第二、三部分中，你将会创建一个复杂的多的「Egg Timer」app，并了解一个 macOS app 的各个组成部分——从一个 app 是如何启动的，到 UI 是如何被构建的，一直到处理交互。</li></ul><p>所以你还在等什么呢？桌面级 app 的世界正在等着你！</p><blockquote><p><strong>注意：</strong>关于如何开始学习这个系列，这里有一些提示：</p><ul><li>如果你从未学习过 Swift，这个系列涉及了一些 Swift 知识，所以请先看看我们的 <a href="https://www.raywenderlich.com/category/swift" target="_blank" rel="noopener">Swift 教程</a>。</li><li>如果你已经有过 iOS 的开发经验，第一部分的内容则可以看作一个复习。保险起见，请快速地浏览一下这些内容，然后直接跳转到下一个部分。</li><li>这个课程是为完全的小白而准备的——你不需要拥有任何 iOS 或 macOS 开发经验！</li></ul></blockquote><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>要成为一个 macOS 开发者，你需要两个东西：</p><ol><li>一台运行着 macOS Sierra 的 Mac：macOS 操作系统只能在苹果电脑上运行，因此无论是开发还是运行 macOS app，你都需要一台 Mac。</li><li>Xcode：这是创建 macOS app 的 IDE（集成开发环境）。稍后你将学会如何在 Mac 上安装它。</li></ol><p>当你完成 app 的开发，希望将它上传至 App Store 进行销售时，你需要一个 Apple 的开发者账户。但直到你已经准备好让你的 app 飞向整片世界的蓝天，这都不是一个硬性要求。甚至你已经决定发布你的 app，也只有在你准备通过 Mac App Store 进行销售时才会需要一个开发者账户。如果你已经是一个 iOS 开发者，那你已经搞定了一切——Apple 已经将各种开发者账户融合为一个，因此你只需要一个账户就可以为各种 Apple 设备分发 app。</p><p>不同于有些其他平台，为 macOS 开发 app 只需要一个工具：Xcode。Xcode 这个 IDE 包含了创建 macOS、iOS、watchOS 和 tvOS app 时所需要的一切。</p><p>如果你还没有安装好 Xcode，点击你 Mac 左上角的 Apple 图标，并选择 <strong>App Store</strong> 来打开 App Store。即便 Xcode 是免费的，你仍需要一个 App Store 的账户来下载 Xcode。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-e82075190fa370a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在请搜索 Xcode，然后点击<strong>获取</strong>按钮来开始下载。当它下载并安装好（这可能得花点时间，它不是个小软件）之后，你可以在 <strong>应用程序</strong>文件夹中打开它。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-1352711309fe2cd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>遵循长久以来学习一门新编程语言或平台的传统，你将会学习如何为 macOS 开发一个「Hello World!」app。</p><p>如果 Xcode 现在还没打开，请打开它。你会看到一个「Welcome to Xcode」的窗口。如果你没有看到这个窗口。点击 <strong>Window</strong> 菜单中的 <strong>Welcome to Xcode</strong>。</p><p>点击 <strong>Create a new Xcode project</strong> 并在接下来的对话框中，在顶部的标签中选择 <strong>macOS</strong>，然后在 <strong>Application</strong> 部分中选择 <strong>Cocoa Application</strong>，并点击 <strong>Next</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-4247ae116c5942d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>给你的 app你取个名字——<strong>Hello World</strong>，并确保 <strong>Language</strong> 设置为 <strong>Swift</strong>，以及 <strong>Use Storyboards</strong> 被勾选。其他选项全部取消勾选。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-0b8c71ba1aa3d4c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>点击 <strong>Next</strong> 和 <strong>Create</strong> 来保存你的新项目。</p><h1 id="运行你的-app"><a href="#运行你的-app" class="headerlink" title="运行你的 app"></a>运行你的 app</h1><p>Xcode 已经为你的 app 应用了一个基础的模版，并添加了其运行所需要的所有文件。因此，什么都不用做而直接运行它其实还挺有趣的。</p><p>点击工具栏上的 <strong>播放按钮️</strong> 或使用键盘快捷键 <strong>⌘R</strong> 来运行你的 app。Xcode 现在会将所有的代码编译成机器语言，将 app 运行所需要的所有资源文件打包，然后运行它。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-9eacc5f13d7eaaf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p><strong>注意：</strong>当你第一次在 Xcode 中运行一个 app 的时候，你可能会被询问是否要 <strong>Enable Developer Mode on this Mac（在这台 Mac 上启用开发者模式）</strong>，请放心地点击 <strong>Enable</strong>，这可能会要求你输入 Mac 的开机密码。开发者模式允许 Xcode 附加调试器到你的 app 的进程——这对于开发一个 app 来说极其有用！</p></blockquote><p>你现在应该能看到一个空白的窗口了，但请不要灰心——你现在已经能做到这些了：</p><ul><li>这个窗口可以调整大小、最小化和全屏；</li><li>这个 app 拥有已经拥有了一套完整的菜单选项，这其中有很多都已经可以正常使用而不用你做任何事情。</li><li>Dock 栏上的 app 图标也拥有了常见的菜单。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-e0c710c4703481ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是现在是时候来把这个空空的屏幕变得更有趣了，所以请退出这个 app 并返回到 Xcode。</p><h1 id="Xcode-的界面"><a href="#Xcode-的界面" class="headerlink" title="Xcode 的界面"></a>Xcode 的界面</h1><p>Xcode 将许多功能融合在同一个窗口中，因此许多东西并不能同时显示出来。要想成为一个 Xcode 高手，你需要知道你需要的功能在哪里，以及如何打开它们。</p><p>当你在 Xcode 里打开一个新的工程，你已经拥有了一个带有工具栏和三个主要面板的窗口。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-86776d3b5504b44a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>左边的窗口是 <strong>Navigator（导航器）</strong>，在这个面板的顶部有八个标签将它分成了八个部分。你所最常用到的是第一个——<strong>Project（项目）</strong>——它列出了项目中所有的文件，你可以点击这些文件来编辑它们。</p><p>中间的面板是 <strong>Editor（编辑器）</strong>，这里会显示你在 <strong>Project Navigator（项目导航器）</strong>里选择的文件。</p><p>右侧的面板是 <strong>Utilities（工具集）</strong>面板，这里显示的内容会会随着你在 <strong>Editor</strong> 里进行的操作而变化。</p><h1 id="添加-UI"><a href="#添加-UI" class="headerlink" title="添加 UI"></a>添加 UI</h1><p>你可以使用 Storyboard 来设计 app 的 UI（用户交互界面）。你的 app 已经有了一个 storyboard，所以在 <strong>Project Navigator（工程导航器）</strong> 中点击 <strong>Main.stroyboard</strong> 来将之显示在编辑器中。</p><p>你的屏幕自动切换了，是不是很神奇！在编辑器中，你现在可以看到文档的线框图，以及可视化的 UI 编辑器。</p><p>看一看你可视化编辑器中的东西。这儿有三个主要的区域，每一个都有着一个文本占位符：</p><ul><li><strong>Application Scene</strong>：顶部的菜单栏；</li><li><strong>Window Controller Scene</strong>：配置窗口会有怎样的表现；</li><li><strong>View Controller Scene</strong>：放置 UI 控件的地方。</li></ul><p>在 <strong>Utilities</strong> 面板里，你将会看见上半部分有八个标签页，而下半部分有四个标签页<br>下半部分的区域呈现了你可以插入到你的项目里的东西。现在你需要插入 UI 控件，所以点击第三个图标 <strong>Object Library</strong>。</p><p>在底部的过滤器（输入框）中，输入「text」，然后找到并拖动一个 <strong>Text Field</strong> 到你的 <strong>View Controller Scene</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-7bb8e8a9ba23fbab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在搜索「button」并拖动一个 <strong>Push Button</strong> 到 <strong>View Controller Scene</strong> 中。最后，再添加一个 <strong>Label</strong>。</p><p>现在，点击<strong>播放按钮️</strong>或按下 <strong>⌘R</strong> 来编译并运行你的 app，你就能看到这三个 UI 元素了。试着在输入框中打些字——它现在已经支持所有标准的键盘快捷键了：复制、粘贴、剪切、撤销、重做…但是界面上的按钮还是什么都做不了，文本也只显示了一个「Label」，所以现在我们该把它们连接起来。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-1d03dc6fde4e0fcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="配置-UI"><a href="#配置-UI" class="headerlink" title="配置 UI"></a>配置 UI</h1><p>返回 <strong>Main.storyboard</strong> 并点击界面上的 Button，在右侧的 <strong>Utilities</strong> 面板中，点击第四个标签页 <strong>Attributes Inspector</strong>。</p><p>把按钮的标题改为「Say Hello」，此时的按钮可能不够宽，所以请点击菜单栏上的 <strong>Editor</strong>，然后点击 <strong>Size to Fit Content</strong>。（如果 Size to Fit Content 选项不可用，先点击空白处取消选中这个按钮，再重新选择它，然后再试一次）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-809c555b71a331f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在点击并选中 Text Field。在这个 app 中，用户将在这里输入他们的名字，当他们点击按钮时，app 会显示「Hello」+他们的名字。为了提示用户，我们在 <strong>Attributes Inspector</strong> 中为输入框中添加一个占位符。</p><p>把输入框稍微拖大一些，以便能放下一些较长的名字，然后把按钮拖动到它的右边。当你在 <strong>View Controller Scene</strong> 中拖动元素时，会出现一些蓝色的虚线来帮助你根据 Apple’s Human Interface Guidelines（Apple 人机交互指南）对齐并放置元素。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-9dd6729b3c989e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>把 Label 放置在输入框的下方。因为这个 Label 十分重要，我们把它的字体改大一些，选中这个 Label，在 <strong>Attributes Inspector</strong> 中把 <strong>Font</strong> 更改为 <strong>System Regular 30</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-4b5f1a07bdc7cff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>不如来些更刺激的吧！把文字的颜色改成红色。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-1bb391c64ee5700a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>你不知道用户的名字会有多长，所以我们需要重新调整输入框的大小，以适应字体的高度，并把宽度调整为和窗口的宽度差不多。</p><p>编译并运行你的 app 来检查一下你的 UI 设置是否生效了。一旦你觉得 Label 中的文字效果令你满意，把 Label 的 <strong>Title</strong> 删除，这样一来就清空了 Label 里的文字。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-5bda3bf99a4a06b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="连接-UI-与代码"><a href="#连接-UI-与代码" class="headerlink" title="连接 UI 与代码"></a>连接 UI 与代码</h1><p>你的 app 现在无法按照你预期的那样工作，你仍需要添加代码来让你的代码能与 UI 通讯。为了建立这种联系，你需要使用 Xcode 的 <strong>Assistant Editor</strong>，先在导航器中选中 <strong>Main.storyboard</strong>，按住 Option⌥ 键的同时点击 <strong>ViewController.swift</strong>，这个操作将会在不关闭之前打开的文件的情况下，为 ViewController.swift 打开第二个编辑器面板。</p><p>现在屏幕上的东西可能看起来有些拥挤（当然这也取决于你的显示器尺寸），所以点击工具栏最右上方的按钮来隐藏 Utilities 面板。如果你的显示器空间还是不够，把 Navigator 面板也一并隐藏了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-63a7464df5d8e17f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>选中输入框，按住 Control⌃ 键的同时把文本框拖动到 <code>class ViewController : NSViewController {</code> 和   <code>override func viewDidLoad() {</code> 之间的那一行，松开鼠标时会弹出一个小窗口，在「name」中输入 <code>nameField</code>，然后点击 <strong>Connect</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-09098b371d0e4b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>对 Label 做同样的事情，并把它命名为 <code>helloLabel</code>。<br>看一看 Xcode 自动生成的代码，你将会看见它们都以 <code>@IBOutlet</code> 开头，这是「Interface Builder Outlet」的缩写，也就是告诉 Storyboard 编辑器这些对象的名称是如何与视觉元素关联起来的。</p><p>对于那个按钮，代码中不需要给它起名字，但它需要知道用户何时点击了这个按钮。与 <code>@IBOutlet</code> 不同，这种连接叫做 <code>@IBAction</code>。</p><p>和先前一样，选中按钮，按住 Control⌃ 键的同时把文本框拖动到 <strong>ViewController.swift</strong> 中。这一次把 <strong>Connection</strong> 选项设置为 <strong>Action</strong>，并把 <strong>name</strong> 设置为 <code>sayButtonClicked</code>。这将会创建一个按钮被电击时会调用的一个方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-a1dcd7e8ada4cb90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在万事俱备，只差代码了！点击右侧编辑器面板右上角的「×」关闭 <strong>Assistant Editor</strong>，回到 <strong>ViewController.swift</strong>。如果你隐藏了 <strong>Navigator</strong>，点击右上角的按钮或按下 <strong>⌘1</strong> 来直接跳转到 <strong>Project Navigator</strong>。</p><p>把如下代码输入到 <code>sayButtonClicked</code> 方法中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = nameField.stringValue</span><br><span class="line"><span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">name = <span class="string">"World"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Hello \(name)!"</span></span><br><span class="line">helloLabel.stringValue = greeting</span><br></pre></td></tr></table></figure><p>在删除了顶部自动生成的版权信息后，完成了的 <strong>ViewController.swift</strong> 中的代码看起来应该像下边截图中的一样。行号左边的小气泡表明这是一个 UI 与代码的连接点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-232d57854832c0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在编译并运行你的 app。</p><p>什么也要不输入，并点击 <strong>Say Hello</strong> 按钮，你将会看到「Hello World!」；而输入了你的名字之后再点击，就能看到你专属的问候语了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-796ee8240876fbd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>有时，我们开发者会犯错——相信我，真的会的。当我们犯了错，就需要调试我们的代码。Xcode 允许我们在代码的任意一处暂停，然后一行一行地运行代码，让你检查每一行运行后各个变量的值，以此来找到错误。</p><p>在  <strong>ViewController.swift</strong> 中找到 <code>sayButtonClicked</code>，点击  <code>var name =</code>  左边的行号，一个蓝色的小旗子将会出现，这是一个激活了的断点，当你点击你 app 界面上的按钮时，调试器会让程序在这里暂停。再次点击它，它会变成浅浅的蓝色，这是一个未激活的断点，它将不会暂停代码，也不会启动调试器。要彻底移除一个断点，把它从行号那一条中拖出去即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-7286002933ce6d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>再次添加一个断点并运行你的 app，点击 <strong>Say Hello</strong> 按钮，Xcode 会移动到最顶层，并把有断点的那一行高亮显示。在 <strong>Editor</strong> 面板的最底部，将会有两个部分：<strong>Variables（变量）</strong>和 <strong>Console（控制台）</strong>。<strong>Variables</strong> 部分展示了此函数中用到的所有变量以及  <code>self</code>（也就是 View Controller）和 <code>sender</code>（也就是按钮）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-b02096c9aed0c4c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在 <strong>Variables</strong> 部分的上方有几个控制调试器的按钮。请把鼠标挨个放在这些按钮上，根据弹出的工具提示看看他们是做什么的。点击 <strong>Step Over</strong> 按钮来运行下一行代码。</p><p>在 <strong>Variables</strong> 部分中，你可以看到 <code>name</code> 是一个空的字符串，所以再连续点击 <strong>Step Over</strong> 按钮两次，调试器会移动到 <code>if</code>语句中，并把 <code>name</code> 变量设置为「World」。</p><p>在 <strong>Variables</strong> 部分中选中 <code>Name</code> 变量，点击下方的 <strong>Quick Look</strong> 按钮来查看具体的内容，电击 <strong>Print Description</strong> 按可以把它的信息输出到 <strong>Console</strong> 部分中。如果「World」没有被正确地设置，你应该能在这里看到，并想出对应的对策。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-1d3489b617788b79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当你检查完所有的变量内容后，点击 <strong>Continue program execution</strong> 按钮来停止调试，并让程序继续运行。你可以使用界面右上角的按钮来隐藏调试器。</p><h1 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h1><p>除了代码和 UI，你的 app 还需要一些图像。根据屏幕的不同（Apple 设备上分为 Retina 显示屏和非 Retina 显示屏），你经常需要为一套「资产」提供多个版本。为了简化这个流程，Xcode 使用 <strong>Asset Libraries</strong> 来存储和管理这些 app 需要的资产。</p><p>在 <strong>Project Navigator</strong> 中点击 <strong>Assets.xcassets</strong>，到目前为止里边只有一个 <strong>AppIcon</strong>，它包含了不同分辨率下的 app 的图标。点击 <strong>AppIcon</strong>，你会看到它需要 10 个不同的图片来覆盖所有的情况，但如果你只提供了一个，那么 Xcode 会尽量让它发挥最大功效，但这并不是一个正确的做法——你需要尽力为你的 app 提供所有尺寸的图标，但在这个简单的上手教程中，一个图标就够了，当你真正开始制作自己的 app 时，这些图标最好一个都别少。</p><p>下载 512×512 像素的<a href="https://koenig-media.raywenderlich.com/uploads/2017/02/rw_logo.png.zip" target="_blank" rel="noopener">示例图标</a>，把它拖动到 <strong>Mac 512pt 1x</strong> 的方框中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-9813e1e8d75fb779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>编译并运行你的 app，查看 Dock 栏中的图标，如果你看到的还是默认图标，请在 <strong>Product</strong> 菜单中选择 <strong>Clean</strong>，然后再次运行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-f51cb8591231f806.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="获得帮助"><a href="#获得帮助" class="headerlink" title="获得帮助"></a>获得帮助</h1><p>除了一个编辑器，Xcode 还包含了你编写 macOS app 所需要的所有文档。</p><p>在 <strong>Help</strong> 菜单中选择 <strong>Documentation and API Reference</strong>。搜索 <strong>NSButton</strong>，请确保当前选中的语言是 Swift，只需点击顶部的搜索结果，就可以找到所有关于按钮的信息了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-7508d1e9c3fe8bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>还有一种方法，可以在你的代码中直接查看相关的文档，返回 <strong>ViewController.swift</strong>，找到 <code>sayButtonClicked</code> 所在的行，按住 Option⌥ 键的同时点击 <code>stringValue</code>，一个快速的查询面板将会弹出，在底部还有一个 <strong>Property Reference</strong> 的链接，点击它就可以在文档中查看更多信息。</p><p><strong>Option⌥ +鼠标点击</strong>是一个特别好的学习方式，你甚至可以为你自己编写的函数添加自己编写的文档，以便今后快速查阅。</p><p><strong>Help</strong> 菜单中还包括了 <strong>Xcode Help</strong>，在这里你可以了解到更多的 Xcode 信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.raywenderlich.com/151741/macos-development-beginners-part-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raywe
      
    
    </summary>
    
    
      <category term="翻译" scheme="https://sr2k.top/blog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ray Wenderlich" scheme="https://sr2k.top/blog/tags/Ray-Wenderlich/"/>
    
      <category term="macOS" scheme="https://sr2k.top/blog/tags/macOS/"/>
    
      <category term="Swift" scheme="https://sr2k.top/blog/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之PHP发送模板消息</title>
    <link href="https://sr2k.top/blog/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8BPHP%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/"/>
    <id>https://sr2k.top/blog/2017/04/01/微信小程序之PHP发送模板消息/</id>
    <published>2017-04-01T04:04:42.000Z</published>
    <updated>2019-07-19T05:03:34.683Z</updated>
    
    <content type="html"><![CDATA[<p>小程序开放个人申请已经有个几天了，踩了无数的坑…折腾了半个多小时终于搞定了模板消息的推送，在这儿 share 一下咯</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>首先，发送模板消息需要准备几样东西，先解释一下他们都是啥：</p><ul><li><p><code>formId</code> 或 <code>prepay_id</code></p><p>用户必须得提交了表格或进行了支付才能推送模板消息，表格提交后能得到 <code>formId</code>，支付完成能得到 <code>prepay_id</code>，而且一个 <code>formId</code> 或 <code>prepay_id</code> 只能推送一条消息。</p><blockquote><p><strong>支付</strong><br>当用户在小程序内完成过支付行为，可允许开发者向用户在 7 天内推送有限条数的模板消息（1 次支付可下发 1 条，多次支付下发条数独立，互相不影响）<br><strong>提交表单</strong><br>当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）</p></blockquote></li><li><p><code>openID</code></p><p>“推送给谁”的用户标识符</p></li><li><p><code>template_id</code></p><p>模板消息的模板编号，可在微信小程序的后台申请</p></li><li><p><code>access_token</code></p><blockquote><p>access_token 是全局唯一接口调用凭据，开发者调用各接口时都需使用 access_token，请妥善保存。access_token 的存储至少要保留 512 个字符空间。access_token 的有效期目前为 2个小时，需定时刷新，重复获取将导致上次获取的 access_token 失效。</p></blockquote></li></ul><h1 id="获取-formID"><a href="#获取-formID" class="headerlink" title="获取 formID"></a>获取 <code>formID</code></h1><p>首先，个人小程序是无法进行支付的，所以只好用提交 form 的办法了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- submit.wxml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">bindsubmit</span>=<span class="string">"submit"</span> <span class="attr">report-submit</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里是表单的各种 &lt;input&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">formType</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在 JS 里接收 form 的 <code>formID</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// submit.js</span></span><br><span class="line"></span><br><span class="line">submit: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> formID = e.detail.formId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里用 wx.request 把数据提交给后端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="发送模板消息"><a href="#发送模板消息" class="headerlink" title="发送模板消息"></a>发送模板消息</h1><h2 id="获取-access-token"><a href="#获取-access-token" class="headerlink" title="获取 access_token"></a>获取 <code>access_token</code></h2><p><code>access_token</code> 需要用到自己小程序的 <code>appId</code> 和 <code>appsecret</code>，并调用微信的 API，PHP 脚本如下：</p><blockquote><p><strong>注</strong>：我自己是把关于小程序的方法都封装在了一个 <code>Utility</code> 类里，这里就当作单独的函数列出了。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getAccessToken.php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAccessToken</span> <span class="params">($appid, $appsecret)</span> </span>&#123;</span><br><span class="line">  $url=<span class="string">'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid='</span>.$appid.<span class="string">'&amp;secret='</span>.$appsecret;</span><br><span class="line">  $html = file_get_contents($url);</span><br><span class="line">  $output = json_decode($html, <span class="keyword">true</span>);</span><br><span class="line">  $access_token = $output[<span class="string">'access_token'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> $access_token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送模板消息-1"><a href="#发送模板消息-1" class="headerlink" title="发送模板消息"></a>发送模板消息</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sendNotice.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'getAccessToken.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据你的模板对应的关键字建立数组</span></span><br><span class="line"><span class="comment">// color 属性是可选项目，用来改变对应字段的颜色</span></span><br><span class="line">$data_arr = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">'keyword1'</span> =&gt; <span class="keyword">array</span>( <span class="string">"value"</span> =&gt; $value, <span class="string">"color"</span> =&gt; $color ) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$post_data = <span class="keyword">array</span> (</span><br><span class="line">  <span class="comment">// 用户的 openID，可用过 wx.getUserInfo 获取</span></span><br><span class="line">  <span class="string">"touser"</span>           =&gt; $openid,</span><br><span class="line">  <span class="comment">// 小程序后台申请到的模板编号</span></span><br><span class="line">  <span class="string">"template_id"</span>      =&gt; $templateid,</span><br><span class="line">  <span class="comment">// 点击模板消息后跳转到的页面，可以传递参数</span></span><br><span class="line">  <span class="string">"page"</span>             =&gt; <span class="string">"/pages/check/result?orderID="</span>.$orderID,</span><br><span class="line">  <span class="comment">// 第一步里获取到的 formID</span></span><br><span class="line">  <span class="string">"form_id"</span>          =&gt; $formid,</span><br><span class="line">  <span class="comment">// 数据</span></span><br><span class="line">  <span class="string">"data"</span>             =&gt; $data_arr,</span><br><span class="line">  <span class="comment">// 需要强调的关键字，会加大居中显示</span></span><br><span class="line">  <span class="string">"emphasis_keyword"</span> =&gt; <span class="string">"keyword2.DATA"</span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 POST 请求的函数</span></span><br><span class="line"><span class="comment">// 你也可以用 cUrl 或者其他网络库，简单的请求这个函数就够用了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send_post</span><span class="params">( $url, $post_data )</span> </span>&#123;</span><br><span class="line">  $options = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'http'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">      <span class="string">'method'</span>  =&gt; <span class="string">'POST'</span>,</span><br><span class="line">      <span class="comment">// header 需要设置为 JSON</span></span><br><span class="line">      <span class="string">'header'</span>  =&gt; <span class="string">'Content-type:application/json'</span>,</span><br><span class="line">      <span class="string">'content'</span> =&gt; $post_data,</span><br><span class="line">      <span class="comment">// 超时时间</span></span><br><span class="line">      <span class="string">'timeout'</span> =&gt; <span class="number">60</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  $context = stream_context_create( $options );</span><br><span class="line">  $result = file_get_contents( $url, <span class="keyword">false</span>, $context );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里替换为你的 appID 和 appSecret</span></span><br><span class="line">$url = <span class="string">"https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token="</span> . getAccessToken ($appid, $appsecret);  </span><br><span class="line"><span class="comment">// 将数组编码为 JSON</span></span><br><span class="line">$data = json_encode($post_data, <span class="keyword">true</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的返回值是一个 JSON，可通过 json_decode() 解码成数组</span></span><br><span class="line">$return = send_post( $url, $data);</span><br><span class="line">var_dump($return);</span><br></pre></td></tr></table></figure><h1 id="返回值（直接复制疼训爸爸的原话咯）"><a href="#返回值（直接复制疼训爸爸的原话咯）" class="headerlink" title="返回值（直接复制疼训爸爸的原话咯）"></a>返回值（直接复制疼训爸爸的原话咯）</h1><table><thead><tr><th style="text-align:center">返回码</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td>一切正常，推送成功</td></tr><tr><td style="text-align:center">40037</td><td><code>template_id</code> 不正确</td></tr><tr><td style="text-align:center">41028</td><td><code>form_id</code> 不正确，或者过期</td></tr><tr><td style="text-align:center">41029</td><td><code>form_id</code> 已被使用</td></tr><tr><td style="text-align:center">41030</td><td><code>page</code>不正确</td></tr><tr><td style="text-align:center">45009</td><td>接口调用超过限额（目前默认每个帐号日调用限额为100万）</td></tr></tbody></table><p>最终推送出来的效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/5477931-af139617f0311bd1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;小程序开放个人申请已经有个几天了，踩了无数的坑…折腾了半个多小时终于搞定了模板消息的推送，在这儿 share 一下咯&lt;/p&gt;
&lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h1
      
    
    </summary>
    
    
      <category term="小程序" scheme="https://sr2k.top/blog/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="PHP" scheme="https://sr2k.top/blog/tags/PHP/"/>
    
  </entry>
  
</feed>
